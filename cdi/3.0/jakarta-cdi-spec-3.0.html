<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="Jakarta Contexts and Dependency Injection Spec Project lead by Antoine Sabot-Durand">
<title>Jakarta Contexts and Dependency Injection</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<!-- Generate a nice TOC -->
<script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js"></script>
<!-- We do not need the tocify CSS because the asciidoc CSS already provides most of what we neeed -->

<style>
.tocify-subheader {
		font-style: normal;
		font-size: 95%;
}
.tocify ul {
		margin: 0;
}
.tocify-focus {
		background-color: #D3D3D3;
}
.tocify-focus > a {
		color: black;
}
</style>

<script type="text/javascript">
		$(function () {
				// Add a new container for the tocify toc into the existing toc so we can re-use its
				// styling
				$("#toc").append("<div id='generated-toc'></div>");
				$("#generated-toc").tocify({
						extendPage: true,
						context: "#content",
						highlightOnScroll: true,
						hideEffect: "slideUp",
						// Use the IDs that asciidoc already provides so that TOC links and intra-document
						// links are the same. Anything else might confuse users when they create bookmarks.
						hashGenerator: function(text, element) {
								return $(element).attr("id");
						},
						// Smooth scrolling doesn't work properly if we use the asciidoc IDs
						smoothScroll: false,
						// Set to 'none' to use the tocify classes
						theme: "none",
						// Handle book (may contain h1) and article (only h2 deeper)
						selectors: $( "#content" ).has( "h1" ).size() > 0 ? "h1,h2,h3,h4,h5" : "h2,h3,h4,h5",
						ignoreSelector: ".discrete"
				});

				// Switch between static asciidoc toc and dynamic tocify toc based on browser size
				// This is set to match the media selectors in the asciidoc CSS
				// Without this, we keep the dynamic toc even if it is moved from the side to preamble
				// position which will cause odd scrolling behavior
				var handleTocOnResize = function() {
						if ($(document).width() < 768) {
								$("#generated-toc").hide();
								$(".sectlevel0").show();
								$(".sectlevel1").show();
						}
						else {
								$("#generated-toc").show();
								$(".sectlevel0").hide();
								$(".sectlevel1").hide();
						}
				}
				$(window).resize(handleTocOnResize);
				handleTocOnResize();
				// Hide level 4
				$("ul.tocify-subheader[data-tag='4']").hide();
		});
</script>

</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Jakarta Contexts and Dependency Injection</h1>
<div class="details">
<span id="author" class="author">Jakarta Contexts and Dependency Injection Spec Project lead by Antoine Sabot-Durand</span><br>
<span id="email" class="email"><a href="mailto:cdi-dev@eclipse.org">cdi-dev@eclipse.org</a></span><br>
<span id="revnumber"> 3.0,</span>
<span id="revdate">July 30 2020</span>
<br><span id="revremark">Final</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_preface">Preface</a>
<ul class="sectlevel2">
<li><a href="#_evaluation_license">Evaluation license</a></li>
<li><a href="#_final_license">Final license</a></li>
<li><a href="#_eclipse_foundation_specification_license_v1_0">Eclipse Foundation Specification License - v1.0</a></li>
<li><a href="#_foreword">Foreword</a></li>
<li><a href="#doc_organisation">Organisation of this document</a></li>
<li><a href="#_major_changes">Major changes</a></li>
</ul>
</li>
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel1">
<li><a href="#architecture">1. Architecture</a>
<ul class="sectlevel2">
<li><a href="#_contracts">1.1. Contracts</a></li>
<li><a href="#_relationship_to_other_specifications">1.2. Relationship to other specifications</a>
<ul class="sectlevel3">
<li><a href="#_relationship_to_the_jakarta_ee_platform_specification">1.2.1. Relationship to the Jakarta EE platform specification</a></li>
<li><a href="#_relationship_to_jakarta_enterprise_bean">1.2.2. Relationship to Jakarta Enterprise Bean</a></li>
<li><a href="#_relationship_to_managed_beans">1.2.3. Relationship to managed beans</a></li>
<li><a href="#_relationship_to_jakarta_dependency_injection">1.2.4. Relationship to Jakarta Dependency Injection</a></li>
<li><a href="#_relationship_to_jakarta_interceptors">1.2.5. Relationship to Jakarta Interceptors</a></li>
<li><a href="#_relationship_to_jakarta_server_faces">1.2.6. Relationship to Jakarta Server Faces</a></li>
<li><a href="#_relationship_to_jakarta_bean_validation">1.2.7. Relationship to Jakarta Bean Validation</a></li>
</ul>
</li>
<li><a href="#_introductory_examples">1.3. Introductory examples</a>
<ul class="sectlevel3">
<li><a href="#_jakarta_server_faces_example">1.3.1. Jakarta Server Faces example</a></li>
<li><a href="#_jakarta_enterprise_bean_example">1.3.2. Jakarta Enterprise Bean example</a></li>
<li><a href="#_jakarta_ee_component_environment_example">1.3.3. Jakarta EE component environment example</a></li>
<li><a href="#_event_example">1.3.4. Event example</a></li>
<li><a href="#_injection_point_metadata_example">1.3.5. Injection point metadata example</a></li>
<li><a href="#_interceptor_example">1.3.6. Interceptor example</a></li>
<li><a href="#_decorator_example">1.3.7. Decorator example</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#part_1">Part I - Core CDI</a>
<ul class="sectlevel1">
<li><a href="#concepts">2. Concepts</a>
<ul class="sectlevel2">
<li><a href="#capabilities">2.1. Functionality provided by the container to the bean</a></li>
<li><a href="#bean_types">2.2. Bean types</a>
<ul class="sectlevel3">
<li><a href="#legal_bean_types">2.2.1. Legal bean types</a></li>
<li><a href="#restricting_bean_types">2.2.2. Restricting the bean types of a bean</a></li>
<li><a href="#typecasting_between_bean_types">2.2.3. Typecasting between bean types</a></li>
</ul>
</li>
<li><a href="#qualifiers">2.3. Qualifiers</a>
<ul class="sectlevel3">
<li><a href="#builtin_qualifiers">2.3.1. Built-in qualifier types</a></li>
<li><a href="#defining_qualifier_types">2.3.2. Defining new qualifier types</a></li>
<li><a href="#declaring_bean_qualifiers">2.3.3. Declaring the qualifiers of a bean</a></li>
<li><a href="#injected_field_qualifiers">2.3.4. Specifying qualifiers of an injected field</a></li>
<li><a href="#method_constructor_parameter_qualifiers">2.3.5. Specifying qualifiers of a method or constructor parameter</a></li>
<li><a href="#repeating_qualifiers">2.3.6. Repeating qualifiers</a></li>
</ul>
</li>
<li><a href="#scopes">2.4. Scopes</a>
<ul class="sectlevel3">
<li><a href="#builtin_scopes">2.4.1. Built-in scope types</a></li>
<li><a href="#defining_new_scope_type">2.4.2. Defining new scope types</a></li>
<li><a href="#declaring_bean_scope">2.4.3. Declaring the bean scope</a></li>
<li><a href="#default_scope">2.4.4. Default scope</a></li>
</ul>
</li>
<li><a href="#default_bean_discovery">2.5. Default bean discovery mode</a>
<ul class="sectlevel3">
<li><a href="#bean_defining_annotations">2.5.1. Bean defining annotations</a></li>
</ul>
</li>
<li><a href="#names">2.6. Bean names</a>
<ul class="sectlevel3">
<li><a href="#declaring_bean_name">2.6.1. Declaring the bean name</a></li>
<li><a href="#default_name">2.6.2. Default bean names</a></li>
<li><a href="#beans_with_no_name">2.6.3. Beans with no name</a></li>
</ul>
</li>
<li><a href="#alternatives">2.7. Alternatives</a>
<ul class="sectlevel3">
<li><a href="#declaring_alternative">2.7.1. Declaring an alternative</a></li>
</ul>
</li>
<li><a href="#stereotypes">2.8. Stereotypes</a>
<ul class="sectlevel3">
<li><a href="#defining_new_stereotype">2.8.1. Defining new stereotypes</a></li>
<li><a href="#declaring_stereotypes">2.8.2. Declaring the stereotypes for a bean</a></li>
<li><a href="#builtin_stereotypes">2.8.3. Built-in stereotypes</a></li>
</ul>
</li>
<li><a href="#exceptions">2.9. Problems detected automatically by the container</a></li>
</ul>
</li>
<li><a href="#implementation">3. Programming model</a>
<ul class="sectlevel2">
<li><a href="#managed_beans">3.1. Managed beans</a>
<ul class="sectlevel3">
<li><a href="#what_classes_are_beans">3.1.1. Which Java classes are managed beans?</a></li>
<li><a href="#managed_bean_types">3.1.2. Bean types of a managed bean</a></li>
<li><a href="#declaring_managed_bean">3.1.3. Declaring a managed bean</a></li>
<li><a href="#specialize_managed_bean">3.1.4. Specializing a managed bean</a></li>
<li><a href="#managed_bean_name">3.1.5. Default bean name for a managed bean</a></li>
</ul>
</li>
<li><a href="#producer_method">3.2. Producer methods</a>
<ul class="sectlevel3">
<li><a href="#producer_method_types">3.2.1. Bean types of a producer method</a></li>
<li><a href="#declaring_producer_method">3.2.2. Declaring a producer method</a></li>
<li><a href="#specialize_producer_method">3.2.3. Specializing a producer method</a></li>
<li><a href="#producer_method_name">3.2.4. Default bean name for a producer method</a></li>
</ul>
</li>
<li><a href="#producer_field">3.3. Producer fields</a>
<ul class="sectlevel3">
<li><a href="#producer_field_types">3.3.1. Bean types of a producer field</a></li>
<li><a href="#declaring_producer_field">3.3.2. Declaring a producer field</a></li>
<li><a href="#producer_field_name">3.3.3. Default bean name for a producer field</a></li>
</ul>
</li>
<li><a href="#disposer_method">3.4. Disposer methods</a>
<ul class="sectlevel3">
<li><a href="#disposer_method_disposed_parameter">3.4.1. Disposed parameter of a disposer method</a></li>
<li><a href="#declaring_disposer_method">3.4.2. Declaring a disposer method</a></li>
<li><a href="#disposer_method_resolution">3.4.3. Disposer method resolution</a></li>
</ul>
</li>
<li><a href="#bean_constructors">3.5. Bean constructors</a>
<ul class="sectlevel3">
<li><a href="#declaring_bean_constructor">3.5.1. Declaring a bean constructor</a></li>
</ul>
</li>
<li><a href="#injected_fields">3.6. Injected fields</a>
<ul class="sectlevel3">
<li><a href="#declaring_injected_field">3.6.1. Declaring an injected field</a></li>
</ul>
</li>
<li><a href="#initializer_methods">3.7. Initializer methods</a>
<ul class="sectlevel3">
<li><a href="#declaring_initializer">3.7.1. Declaring an initializer method</a></li>
</ul>
</li>
<li><a href="#injection_point_default_qualifier">3.8. The default qualifier at injection points</a></li>
<li><a href="#named_at_injection_point">3.9. The qualifier <code>@Named</code> at injection points</a></li>
<li><a href="#new">3.10. <code>@New</code> qualified beans</a></li>
<li><a href="#unproxyable">3.11. Unproxyable bean types</a></li>
</ul>
</li>
<li><a href="#inheritance">4. Inheritance and specialization</a>
<ul class="sectlevel2">
<li><a href="#type_level_inheritance">4.1. Inheritance of type-level metadata</a></li>
<li><a href="#member_level_inheritance">4.2. Inheritance of member-level metadata</a></li>
<li><a href="#specialization">4.3. Specialization</a>
<ul class="sectlevel3">
<li><a href="#direct_and_indirect_specialization">4.3.1. Direct and indirect specialization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#injection_and_resolution">5. Dependency injection and lookup</a>
<ul class="sectlevel2">
<li><a href="#selection">5.1. Modularity</a>
<ul class="sectlevel3">
<li><a href="#declaring_selected_alternatives">5.1.1. Declaring selected alternatives</a></li>
<li><a href="#enablement">5.1.2. Enabled and disabled beans</a></li>
<li><a href="#inconsistent_specialization">5.1.3. Inconsistent specialization</a></li>
<li><a href="#inter_module_injection">5.1.4. Inter-module injection</a></li>
</ul>
</li>
<li><a href="#typesafe_resolution">5.2. Typesafe resolution</a>
<ul class="sectlevel3">
<li><a href="#performing_typesafe_resolution">5.2.1. Performing typesafe resolution</a></li>
<li><a href="#unsatisfied_and_ambig_dependencies">5.2.2. Unsatisfied and ambiguous dependencies</a></li>
<li><a href="#legal_injection_point_types">5.2.3. Legal injection point types</a></li>
<li><a href="#assignable_parameters">5.2.4. Assignability of raw and parameterized types</a></li>
<li><a href="#primitive_types_and_null_values">5.2.5. Primitive types and null values</a></li>
<li><a href="#qualifier_annotation_members">5.2.6. Qualifier annotations with members</a></li>
<li><a href="#multiple_qualifiers">5.2.7. Multiple qualifiers</a></li>
</ul>
</li>
<li><a href="#name_resolution">5.3. Name resolution</a>
<ul class="sectlevel3">
<li><a href="#ambig_names">5.3.1. Ambiguous names</a></li>
</ul>
</li>
<li><a href="#client_proxies">5.4. Client proxies</a>
<ul class="sectlevel3">
<li><a href="#client_proxy_invocation">5.4.1. Client proxy invocation</a></li>
</ul>
</li>
<li><a href="#injection">5.5. Dependency injection</a>
<ul class="sectlevel3">
<li><a href="#instantiation">5.5.1. Injection using the bean constructor</a></li>
<li><a href="#fields_initializer_methods">5.5.2. Injection of fields and initializer methods</a></li>
<li><a href="#dependent_objects_destruction">5.5.3. Destruction of dependent objects</a></li>
<li><a href="#producer_or_disposer_methods_invocation">5.5.4. Invocation of producer or disposer methods</a></li>
<li><a href="#producer_fields_access">5.5.5. Access to producer field values</a></li>
<li><a href="#observers_method_invocation">5.5.6. Invocation of observer methods</a></li>
<li><a href="#injection_point">5.5.7. Injection point metadata</a></li>
<li><a href="#bean_metadata">5.5.8. Bean metadata</a></li>
</ul>
</li>
<li><a href="#programmatic_lookup">5.6. Programmatic lookup</a>
<ul class="sectlevel3">
<li><a href="#dynamic_lookup">5.6.1. The <code>Instance</code> interface</a></li>
<li><a href="#builtin_instance">5.6.2. The built-in <code>Instance</code></a></li>
<li><a href="#annotationliteral_typeliteral">5.6.3. Using <code>AnnotationLiteral</code> and <code>TypeLiteral</code></a></li>
<li><a href="#built_in_annotation_literals">5.6.4. Built-in annotation literals</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#contexts">6. Scopes and contexts</a>
<ul class="sectlevel2">
<li><a href="#contextual">6.1. The <code>Contextual</code> interface</a>
<ul class="sectlevel3">
<li><a href="#creational_context">6.1.1. The <code>CreationalContext</code> interface</a></li>
</ul>
</li>
<li><a href="#context">6.2. The <code>Context</code> interface</a></li>
<li><a href="#normal_scope">6.3. Normal scopes and pseudo-scopes</a></li>
<li><a href="#dependent_context">6.4. Dependent pseudo-scope</a>
<ul class="sectlevel3">
<li><a href="#dependent_objects">6.4.1. Dependent objects</a></li>
<li><a href="#dependent_destruction">6.4.2. Destruction of objects with scope <code>@Dependent</code></a></li>
</ul>
</li>
<li><a href="#contextual_instances_and_references">6.5. Contextual instances and contextual references</a>
<ul class="sectlevel3">
<li><a href="#active_context">6.5.1. The active context object for a scope</a></li>
<li><a href="#activating_builtin_contexts">6.5.2. Activating Built In Contexts</a></li>
<li><a href="#contextual_instance">6.5.3. Contextual instance of a bean</a></li>
<li><a href="#contextual_reference">6.5.4. Contextual reference for a bean</a></li>
<li><a href="#contextual_reference_validity">6.5.5. Contextual reference validity</a></li>
<li><a href="#injectable_reference">6.5.6. Injectable references</a></li>
<li><a href="#injectable_reference_validity">6.5.7. Injectable reference validity</a></li>
</ul>
</li>
<li><a href="#passivating_scope">6.6. Passivation and passivating scopes</a>
<ul class="sectlevel3">
<li><a href="#passivation_capable">6.6.1. Passivation capable beans</a></li>
<li><a href="#passivation_capable_injection_points">6.6.2. Passivation capable injection points</a></li>
<li><a href="#passivation_capable_dependency">6.6.3. Passivation capable dependencies</a></li>
<li><a href="#passivating_scopes">6.6.4. Passivating scopes</a></li>
<li><a href="#passivation_validation">6.6.5. Validation of passivation capable beans and dependencies</a></li>
</ul>
</li>
<li><a href="#builtin_contexts">6.7. Context management for built-in scopes</a>
<ul class="sectlevel3">
<li><a href="#request_context">6.7.1. Request context lifecycle</a></li>
<li><a href="#session_context">6.7.2. Session context lifecycle</a></li>
<li><a href="#application_context">6.7.3. Application context lifecycle</a></li>
<li><a href="#conversation_context">6.7.4. Conversation context lifecycle</a></li>
<li><a href="#conversation">6.7.5. The <code>Conversation</code> interface</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lifecycle">7. Lifecycle of contextual instances</a>
<ul class="sectlevel2">
<li><a href="#bean_instantiation_restriction">7.1. Restriction upon bean instantiation</a></li>
<li><a href="#biz_method">7.2. Container invocations and interception</a></li>
<li><a href="#contextual_instance_lifecycle">7.3. Lifecycle of contextual instances</a>
<ul class="sectlevel3">
<li><a href="#managed_bean_lifecycle">7.3.1. Lifecycle of managed beans</a></li>
<li><a href="#producer_method_lifecycle">7.3.2. Lifecycle of producer methods</a></li>
<li><a href="#producer_field_lifecycle">7.3.3. Lifecycle of producer fields</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#decorators">8. Decorators</a>
<ul class="sectlevel2">
<li><a href="#decorator_bean">8.1. Decorator beans</a>
<ul class="sectlevel3">
<li><a href="#decorator_annotation">8.1.1. Declaring a decorator</a></li>
<li><a href="#delegate_attribute">8.1.2. Decorator delegate injection points</a></li>
<li><a href="#decorated_types">8.1.3. Decorated types of a decorator</a></li>
</ul>
</li>
<li><a href="#enabled_decorators">8.2. Decorator enablement and ordering</a>
<ul class="sectlevel3">
<li><a href="#enabled_decorators_priority">8.2.1. Decorator enablement and ordering for an application</a></li>
<li><a href="#enabled_decorators_bean_archive">8.2.2. Decorator enablement and ordering for a bean archive</a></li>
</ul>
</li>
<li><a href="#decorator_resolution">8.3. Decorator resolution</a>
<ul class="sectlevel3">
<li><a href="#delegate_assignable_parameters">8.3.1. Assignability of raw and parameterized types for delegate injection points</a></li>
</ul>
</li>
<li><a href="#decorator_invocation">8.4. Decorator invocation</a></li>
</ul>
</li>
<li><a href="#interceptors">9. Interceptor bindings</a>
<ul class="sectlevel2">
<li><a href="#interceptor_bindings">9.1. Interceptor binding types</a>
<ul class="sectlevel3">
<li><a href="#stereotype_interceptor_bindings">9.1.1. Interceptor bindings for stereotypes</a></li>
</ul>
</li>
<li><a href="#declaring_interceptor">9.2. Declaring the interceptor bindings of an interceptor</a></li>
<li><a href="#binding_interceptor_to_bean">9.3. Binding an interceptor to a bean</a></li>
<li><a href="#enabled_interceptors">9.4. Interceptor enablement and ordering</a></li>
<li><a href="#interceptor_resolution">9.5. Interceptor resolution</a></li>
</ul>
</li>
<li><a href="#events">10. Events</a>
<ul class="sectlevel2">
<li><a href="#event_types_and_qualifier_types">10.1. Event types and qualifier types</a></li>
<li><a href="#firing_events">10.2. Firing events</a>
<ul class="sectlevel3">
<li><a href="#firing_events_synchronously">10.2.1. Firing events synchronously</a></li>
<li><a href="#firing_events_asynchronously">10.2.2. Firing events asynchronously</a></li>
<li><a href="#event">10.2.3. The <code>Event</code> interface</a></li>
<li><a href="#builtin_event">10.2.4. The built-in <code>Event</code></a></li>
</ul>
</li>
<li><a href="#observer_resolution">10.3. Observer resolution</a>
<ul class="sectlevel3">
<li><a href="#observers_assignability">10.3.1. Assignability of type variables, raw and parameterized types</a></li>
<li><a href="#event_qualifier_types_with_members">10.3.2. Event qualifier types with members</a></li>
<li><a href="#multiple_event_qualifiers">10.3.3. Multiple event qualifiers</a></li>
</ul>
</li>
<li><a href="#observer_methods">10.4. Observer methods</a>
<ul class="sectlevel3">
<li><a href="#observer_method_event_parameter">10.4.1. Event parameter of an observer method</a></li>
<li><a href="#observes">10.4.2. Declaring an observer method</a></li>
<li><a href="#event_metadata">10.4.3. The <code>EventMetadata</code> interface</a></li>
<li><a href="#conditional_observer_methods">10.4.4. Conditional observer methods</a></li>
<li><a href="#transactional_observer_methods">10.4.5. Transactional observer methods</a></li>
</ul>
</li>
<li><a href="#observer_notification">10.5. Observer notification</a>
<ul class="sectlevel3">
<li><a href="#async_exception">10.5.1. Handling multiple exceptions thrown during an asynchronous event</a></li>
<li><a href="#observer_ordering">10.5.2. Observer ordering</a></li>
<li><a href="#observer_method_invocation_context">10.5.3. Observer method invocation context</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spi">11. Portable extensions</a>
<ul class="sectlevel2">
<li><a href="#bean">11.1. The <code>Bean</code> interface</a>
<ul class="sectlevel3">
<li><a href="#decorator">11.1.1. The <code>Decorator</code> interface</a></li>
<li><a href="#interceptor">11.1.2. The <code>Interceptor</code> interface</a></li>
<li><a href="#observer_method">11.1.3. The <code>ObserverMethod</code> interface</a></li>
<li><a href="#prioritized">11.1.4. The <code>Prioritized</code> interface</a></li>
</ul>
</li>
<li><a href="#injectiontarget">11.2. The <code>Producer</code> and <code>InjectionTarget</code> interfaces</a></li>
<li><a href="#beanmanager">11.3. The <code>BeanManager</code> object</a>
<ul class="sectlevel3">
<li><a href="#provider">11.3.1. Obtaining a reference to the CDI container</a></li>
<li><a href="#bm_obtain_contextual_reference">11.3.2. Obtaining a contextual reference for a bean</a></li>
<li><a href="#bm_obtain_injectable_reference">11.3.3. Obtaining an injectable reference</a></li>
<li><a href="#bm_obtain_unmanaged_instance">11.3.4. Obtaining non-contextual instance</a></li>
<li><a href="#bm_obtain_creationalcontext">11.3.5. Obtaining a <code>CreationalContext</code></a></li>
<li><a href="#bm_obtain_bean_by_type">11.3.6. Obtaining a <code>Bean</code> by type</a></li>
<li><a href="#bm_obtain_bean_by_name">11.3.7. Obtaining a <code>Bean</code> by name</a></li>
<li><a href="#bm_obtain_passivation_capable_bean">11.3.8. Obtaining a passivation capable bean by identifier</a></li>
<li><a href="#bm_resolve_ambiguous_dep">11.3.9. Resolving an ambiguous dependency</a></li>
<li><a href="#bm_validate_ip">11.3.10. Validating an injection point</a></li>
<li><a href="#bm_fire_event">11.3.11. Firing an event</a></li>
<li><a href="#bm_observer_method_resolution">11.3.12. Observer method resolution</a></li>
<li><a href="#bm_decorator_resolution">11.3.13. Decorator resolution</a></li>
<li><a href="#bm_interceptor_resolution">11.3.14. Interceptor resolution</a></li>
<li><a href="#bm_determining_annotation">11.3.15. Determining if an annotation is a qualifier type, scope type, stereotype or interceptor binding type</a></li>
<li><a href="#bm_determining_hash">11.3.16. Determining the hash code and equivalence of qualifiers and interceptor bindings</a></li>
<li><a href="#bm_obtain_active_context">11.3.17. Obtaining the active <code>Context</code> for a scope</a></li>
<li><a href="#bm_obtain_elresolver">11.3.18. Obtaining the <code>ELResolver</code></a></li>
<li><a href="#bm_obtain_annotatedtype">11.3.19. Obtaining an <code>AnnotatedType</code> for a class</a></li>
<li><a href="#bm_obtain_injectiontarget">11.3.20. Obtaining an <code>InjectionTarget</code> for a class</a></li>
<li><a href="#bm_obtain_producer">11.3.21. Obtaining a <code>Producer</code> for a field or method</a></li>
<li><a href="#bm_obtain_injectionpoint">11.3.22. Obtaining an <code>InjectionPoint</code></a></li>
<li><a href="#bm_obtain_beanattributes">11.3.23. Obtaining a <code>BeanAttributes</code></a></li>
<li><a href="#bm_obtain_bean">11.3.24. Obtaining a <code>Bean</code></a></li>
<li><a href="#bm_obtain_extension">11.3.25. Obtaining the instance of an <code>Extension</code></a></li>
<li><a href="#bm_obtain_interception_factory">11.3.26. Obtain an <code>InterceptionFactory</code></a></li>
<li><a href="#bm_obtain_instance">11.3.27. Obtain an <code>Instance</code></a></li>
</ul>
</li>
<li><a href="#alternative_metadata_sources">11.4. Alternative metadata sources</a>
<ul class="sectlevel3">
<li><a href="#annotated_type_configurator">11.4.1. <code>AnnotatedTypeConfigurator</code> SPI</a></li>
</ul>
</li>
<li><a href="#init_events">11.5. Container lifecycle events</a>
<ul class="sectlevel3">
<li><a href="#before_bean_discovery">11.5.1. <code>BeforeBeanDiscovery</code> event</a></li>
<li><a href="#after_type_discovery">11.5.2. <code>AfterTypeDiscovery</code> event</a></li>
<li><a href="#after_bean_discovery">11.5.3. <code>AfterBeanDiscovery</code> event</a></li>
<li><a href="#after_deployment_validation">11.5.4. <code>AfterDeploymentValidation</code> event</a></li>
<li><a href="#before_shutdown">11.5.5. <code>BeforeShutdown</code> event</a></li>
<li><a href="#process_annotated_type">11.5.6. <code>ProcessAnnotatedType</code> event</a></li>
<li><a href="#process_injection_point">11.5.7. <code>ProcessInjectionPoint</code> event</a></li>
<li><a href="#process_injection_target">11.5.8. <code>ProcessInjectionTarget</code> event</a></li>
<li><a href="#process_bean_attributes">11.5.9. <code>ProcessBeanAttributes</code> event</a></li>
<li><a href="#process_bean">11.5.10. <code>ProcessBean</code> event</a></li>
<li><a href="#process_producer">11.5.11. <code>ProcessProducer</code> event</a></li>
<li><a href="#process_observer_method">11.5.12. <code>ProcessObserverMethod</code> event</a></li>
</ul>
</li>
<li><a href="#configurators">11.6. Configurators interfaces</a></li>
<li><a href="#interception_factory">11.7. The <code>InterceptionFactory</code> interface</a></li>
</ul>
</li>
<li><a href="#packaging_deployment">12. Packaging and deployment</a>
<ul class="sectlevel2">
<li><a href="#bean_archive">12.1. Bean archives</a></li>
<li><a href="#initialization">12.2. Application initialization lifecycle</a></li>
<li><a href="#shutdown">12.3. Application shutdown lifecycle</a></li>
<li><a href="#type_bean_discovery">12.4. Type and Bean discovery</a>
<ul class="sectlevel3">
<li><a href="#type_discovery_steps">12.4.1. Type discovery</a></li>
<li><a href="#exclude_filters">12.4.2. Exclude filters</a></li>
<li><a href="#trimmed_bean_archive">12.4.3. Trimmed bean archive</a></li>
<li><a href="#bean_discovery_steps">12.4.4. Bean discovery</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#part_2">Part II - CDI in Java SE</a>
<ul class="sectlevel1">
<li><a href="#se_bootstrap">13. Bootstrapping a CDI container in Java SE</a>
<ul class="sectlevel2">
<li><a href="#se_container_initializer">13.1. <code>SeContainerInitializer</code> class</a></li>
<li><a href="#se_container">13.2. <code>SeContainer</code> interface</a></li>
</ul>
</li>
<li><a href="#contexts_se">14. Scopes and contexts in Java SE</a>
<ul class="sectlevel2">
<li><a href="#builtin_contexts_se">14.1. Context management for built-in scopes in Java SE</a>
<ul class="sectlevel3">
<li><a href="#application_context_se">14.1.1. Application context lifecycle in Java SE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#packaging_deployment_se">15. Packaging and deployment in Java SE</a>
<ul class="sectlevel2">
<li><a href="#bean_archive_se">15.1. Bean archive in Java SE</a></li>
</ul>
</li>
<li><a href="#spi_se">16. Portable extensions in Java SE</a>
<ul class="sectlevel2">
<li><a href="#beanmanager_se">16.1. The <code>BeanManager</code> object in Java SE</a>
<ul class="sectlevel3">
<li><a href="#provider_se">16.1.1. Obtaining a reference to the CDI container in Java SE</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#part_3">Part III - CDI in Jakarta EE</a>
<ul class="sectlevel1">
<li><a href="#concepts_ee">17. Extended Concepts for Jakarta EE</a>
<ul class="sectlevel2">
<li><a href="#capabilities_ee">17.1. Functionality provided by the container to the bean in Jakarta EE</a></li>
<li><a href="#bean_types_ee">17.2. Bean types for Jakarta EE component</a></li>
<li><a href="#scopes_ee">17.3. Scopes</a>
<ul class="sectlevel3">
<li><a href="#builtin_scopes_ee">17.3.1. Built-in scope types in Jakarta EE</a></li>
</ul>
</li>
<li><a href="#default_bean_discovery_ee">17.4. Default bean discovery mode for Jakarta EE</a></li>
<li><a href="#names_ee">17.5. Bean names in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#default_name_ee">17.5.1. Default bean names for EJB session beans</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#implementation_ee">18. Addition to programming model for Jakarta EE</a>
<ul class="sectlevel2">
<li><a href="#managed_beans_ee">18.1. Managed beans in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#what_classes_are_beans_ee">18.1.1. Which Java classes are managed beans in Jakarta EE?</a></li>
</ul>
</li>
<li><a href="#session_beans">18.2. EJB Session beans</a>
<ul class="sectlevel3">
<li><a href="#session_bean_ejb_remove_method">18.2.1. EJB remove methods of session beans</a></li>
<li><a href="#session_bean_types">18.2.2. Bean types of a session bean</a></li>
<li><a href="#declaring_session_bean">18.2.3. Declaring a session bean</a></li>
<li><a href="#specialize_session_bean">18.2.4. Specializing a session bean</a></li>
<li><a href="#session_bean_name">18.2.5. Default bean name for a session bean</a></li>
</ul>
</li>
<li><a href="#producer_method_ee">18.3. Producer methods on EJB session bean</a>
<ul class="sectlevel3">
<li><a href="#declaring_producer_method_ee">18.3.1. Declaring a producer method in an EJB session bean</a></li>
</ul>
</li>
<li><a href="#producer_field_ee">18.4. Producer field on EJB session bean</a>
<ul class="sectlevel3">
<li><a href="#declaring_producer_field_ee">18.4.1. Declaring a producer field in an EJB session bean</a></li>
</ul>
</li>
<li><a href="#disposer_method_ee">18.5. Disposer methods on EJB session bean</a>
<ul class="sectlevel3">
<li><a href="#declaring_disposer_method_ee">18.5.1. Declaring a disposer method on an EJB session bean</a></li>
</ul>
</li>
<li><a href="#javaee_components">18.6. Jakarta EE components</a></li>
<li><a href="#resources">18.7. Resources</a>
<ul class="sectlevel3">
<li><a href="#declaring_resource">18.7.1. Declaring a resource</a></li>
<li><a href="#resource_types">18.7.2. Bean types of a resource</a></li>
</ul>
</li>
<li><a href="#additional_builtin_beans">18.8. Additional built-in beans</a></li>
<li><a href="#injected_fields_ee">18.9. Injected fields in Jakarta EE</a></li>
<li><a href="#initializer_methods_ee">18.10. Initializer methods in Jakarta EE</a></li>
<li><a href="#new_ee">18.11. <code>@New</code> qualified beans in Jakarta EE</a></li>
<li><a href="#type_level_inheritance_ee">18.12. Inheritance of type-level metadata in Jakarta EE</a></li>
<li><a href="#member_level_inheritance_ee">18.13. Inheritance of member-level metadata in Jakarta EE</a></li>
<li><a href="#specialization_ee">18.14. Specialization in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#direct_and_indirect_specialization_ee">18.14.1. Direct and indirect specialization in Jakarta EE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#injection_el_resolution_ee">19. Dependency injection, lookup and EL in Jakarta EE</a>
<ul class="sectlevel2">
<li><a href="#selection_ee">19.1. Modularity in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#declaring_selected_alternatives_application_ee">19.1.1. Declaring selected alternatives for an application in Jakarta EE</a></li>
<li><a href="#declaring_selected_alternatives_bean_archive_ee">19.1.2. Declaring selected alternatives for a bean archive in Jakarta EE</a></li>
<li><a href="#unsatisfied_and_ambig_dependencies_ee">19.1.3. Unsatisfied and ambiguous dependencies in Jakarta EE</a></li>
</ul>
</li>
<li><a href="#name_resolution_ee">19.2. EL name resolution</a>
<ul class="sectlevel3">
<li><a href="#ambig_names_ee">19.2.1. Ambiguous EL names</a></li>
</ul>
</li>
<li><a href="#injection_ee">19.3. Dependency injection in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#instantiation_ee">19.3.1. Injection using the bean constructor in Jakarta EE</a></li>
<li><a href="#fields_initializer_methods_ee">19.3.2. Injection of fields and initializer methods in Jakarta EE</a></li>
<li><a href="#dependent_objects_destruction_ee">19.3.3. Destruction of dependent objects in Jakarta EE</a></li>
<li><a href="#bean_metadata_ee">19.3.4. Bean metadata in Jakarta EE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#contexts_ee">20. Scopes and contexts in Jakarta EE</a>
<ul class="sectlevel2">
<li><a href="#dependent_context_ee">20.1. Dependent pseudo-scope in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#dependent_objects_ee">20.1.1. Dependent objects in Jakarta EE</a></li>
<li><a href="#dependent_destruction_ee">20.1.2. Destruction of objects with scope <code>@Dependent</code> in Jakarta EE</a></li>
<li><a href="#dependent_scope_el">20.1.3. Dependent pseudo-scope and Unified EL</a></li>
</ul>
</li>
<li><a href="#passivating_scope_ee">20.2. Passivation and passivating scopes in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#passivation_capable_ee">20.2.1. Passivation capable beans in Jakarta EE</a></li>
<li><a href="#passivation_capable_dependency_ee">20.2.2. Passivation capable dependencies in Jakarta EE</a></li>
<li><a href="#passivation_validation_ee">20.2.3. Validation of passivation capable beans and dependencies in Jakarta EE</a></li>
</ul>
</li>
<li><a href="#builtin_contexts_ee">20.3. Context management for built-in scopes in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#request_context_ee">20.3.1. Request context lifecycle in Jakarta EE</a></li>
<li><a href="#session_context_ee">20.3.2. Session context lifecycle in Jakarta EE</a></li>
<li><a href="#application_context_ee">20.3.3. Application context lifecycle in Jakarta EE</a></li>
<li><a href="#conversation_context_ee">20.3.4. Conversation context lifecycle in Jakarta EE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#lifecycle_ee">21. Lifecycle of contextual instances</a>
<ul class="sectlevel2">
<li><a href="#biz_method_ee">21.1. Container invocations and interception in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#stateful_lifecycle">21.1.1. Lifecycle of EJB stateful session beans</a></li>
<li><a href="#stateless_lifecycle">21.1.2. Lifecycle of EJB stateless and singleton session beans</a></li>
<li><a href="#resource_lifecycle">21.1.3. Lifecycle of resources</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#decorators_ee">22. Decorators in Jakarta EE</a>
<ul class="sectlevel2">
<li><a href="#decorator_bean_ee">22.1. Decorator beans in Jakarta EE</a></li>
</ul>
</li>
<li><a href="#interceptors_ee">23. Interceptor bindings in Jakarta EE</a>
<ul class="sectlevel2">
<li><a href="#enabled_interceptors_ee">23.1. Interceptor enablement and ordering in Jakarta EE</a></li>
<li><a href="#interceptor_resolution_ee">23.2. Interceptor resolution in Jakarta EE</a></li>
</ul>
</li>
<li><a href="#events_ee">24. Events in Jakarta EE</a>
<ul class="sectlevel2">
<li><a href="#observer_methods_ee">24.1. Observer methods in EJB session beans</a>
<ul class="sectlevel3">
<li><a href="#observes_ee">24.1.1. Declaring an observer method in an EJB</a></li>
<li><a href="#observer_method_invocation_context_ee">24.1.2. Observer method invocation context in Jakarta EE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spi_ee">25. Portable extensions in Jakarta EE</a>
<ul class="sectlevel2">
<li><a href="#bean_ee">25.1. The <code>Bean</code> interface in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#interceptor_ee">25.1.1. The <code>Interceptor</code> interface in Jakarta EE</a></li>
</ul>
</li>
<li><a href="#injectiontarget_ee">25.2. <code>InjectionTarget</code> interface in Jakarta EE</a></li>
<li><a href="#beanmanager_ee">25.3. The <code>BeanManager</code> object in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#provider_ee">25.3.1. Obtaining a reference to the CDI container in Jakarta EE</a></li>
<li><a href="#bm_wrap_expressionfactory">25.3.2. Wrapping a Unified EL <code>ExpressionFactory</code></a></li>
</ul>
</li>
<li><a href="#alternative_metadata_sources_ee">25.4. Alternative metadata sources and EJB</a></li>
<li><a href="#init_events_ee">25.5. Addition to Container lifecycle events in Jakarta EE</a>
<ul class="sectlevel3">
<li><a href="#process_annotated_type_ee">25.5.1. <code>ProcessAnnotatedType</code> event in Jakarta EE</a></li>
<li><a href="#process_injection_point_ee">25.5.2. <code>ProcessInjectionPoint</code> event and EJB</a></li>
<li><a href="#process_injection_target_ee">25.5.3. <code>ProcessInjectionTarget</code> event and EJB</a></li>
<li><a href="#process_bean_attributes_ee">25.5.4. <code>ProcessBeanAttributes</code> event and EJB</a></li>
<li><a href="#process_bean_ee">25.5.5. <code>ProcessBean</code> event and EJB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#packaging_deployment_ee">26. Packaging and deployment in Jakarta EE</a>
<ul class="sectlevel2">
<li><a href="#bean_archive_ee">26.1. Bean archive with EJB Session Beans</a></li>
<li><a href="#type_bean_discovery_ee">26.2. Type and Bean discovery for EJB</a>
<ul class="sectlevel3">
<li><a href="#bean_discovery_steps_ee">26.2.1. Bean discovery in Jakarta EE</a></li>
<li><a href="#trimmed_bean_archive_ee">26.2.2. Trimmed bean archive in Jakarta EE</a></li>
</ul>
</li>
<li><a href="#el">26.3. Integration with Unified EL</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_preface"><a class="anchor" href="#_preface"></a>Preface</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_evaluation_license"><a class="anchor" href="#_evaluation_license"></a>Evaluation license</h3>
<div class="literalblock">
<div class="content">
<pre>Specification: Jakarta Contexts and Dependency Injection

Version: 3.0

Status: Final

Release: July 30 2020</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_final_license"><a class="anchor" href="#_final_license"></a>Final license</h3>
<div class="paragraph">
<p>Copyright 2018,2020 Eclipse Foundation.</p>
</div>
<div class="paragraph">
<p>This specification is licensed under the Eclipse Foundation Specification License 1.0; this specification is based on material that is licensed under the Apache License, version 2.0.</p>
</div>
</div>
<div class="sect2">
<h3 id="_eclipse_foundation_specification_license_v1_0"><a class="anchor" href="#_eclipse_foundation_specification_license_v1_0"></a>Eclipse Foundation Specification License - v1.0</h3>
<div class="paragraph">
<p>(Copy of the EFSL license <a href="https://www.eclipse.org/legal/efsl.php">here</a>)</p>
</div>
<div class="paragraph">
<p>By using and/or copying this document, or the Eclipse Foundation document from which this statement is linked, you (the licensee) agree that you have read, understood, and will comply with the following terms and conditions:</p>
</div>
<div class="paragraph">
<p>Permission to copy, and distribute the contents of this document, or the Eclipse Foundation document from which this statement is linked, in any medium for any purpose and without fee or royalty is hereby granted, provided that you include the following on ALL copies of the document, or portions thereof, that you use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>link or URL to the original Eclipse Foundation document.</p>
</li>
<li>
<p>All existing copyright notices, or if one does not exist, a notice (hypertext is preferred, but a textual representation is permitted) of the form:
"Copyright © [$date-of-document] Eclipse Foundation, Inc. <a href="https://www.eclipse.org/legal/efsl.php">EFSL</a>"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Inclusion of the full text of this NOTICE must be provided. We request that authorship attribution be provided in any software, documents, or other items or products that you create pursuant to the implementation of the contents of this document, or any portion thereof.</p>
</div>
<div class="paragraph">
<p>No right to create modifications or derivatives of Eclipse Foundation documents is granted pursuant to this license, except anyone may prepare and distribute derivative works and portions of this document in software that implements the specification, in supporting materials accompanying such software, and in documentation of such software, PROVIDED that all such works include the notice below. HOWEVER, the publication of derivative works of this document for use as a technical specification is expressly prohibited.</p>
</div>
<div class="paragraph">
<p>The notice is:</p>
</div>
<div class="paragraph">
<p>Copyright © 2018,2020 Eclipse Foundation. This software or document includes material copied from or derived from Jakarta Contexts and Dependency Injection <a href="https://projects.eclipse.org/projects/ee4j.cdi" class="bare">https://projects.eclipse.org/projects/ee4j.cdi</a></p>
</div>
<div class="paragraph">
<p>Disclaimers</p>
</div>
<div class="paragraph">
<p>THIS DOCUMENT IS PROVIDED "AS IS," AND THE COPYRIGHT HOLDERS AND THE ECLIPSE FOUNDATION MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THE DOCUMENT ARE SUITABLE FOR ANY PURPOSE; NOR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.</p>
</div>
<div class="paragraph">
<p>THE COPYRIGHT HOLDERS AND THE ECLIPSE FOUNDATION WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENT OR THE PERFORMANCE OR IMPLEMENTATION OF THE CONTENTS THEREOF.</p>
</div>
<div class="paragraph">
<p>The name and trademarks of the copyright holders or the Eclipse Foundation may NOT be used in advertising or publicity pertaining to this document or its contents without specific, written prior permission. Title to copyright in this document will at all times remain with copyright holders.</p>
</div>
</div>
<div class="sect2">
<h3 id="_foreword"><a class="anchor" href="#_foreword"></a>Foreword</h3>
<div class="paragraph">
<p>Jakarta Contexts and Dependency Injection 3.0 (<a href="https://jakarta.ee/specifications/cdi/3.0/">CDI 3.0</a>) is an update to Jakarta Contexts and Dependency Injection 2.0 (<a href="https://jakarta.ee/specifications/cdi/3.0/">CDI 2.0</a>).</p>
</div>
<div class="paragraph">
<p>Starting with version 2.0 CDI targets Java SE and Jakarta EE platforms.
CDI in Java SE and CDI in a Jakarta EE container share the features defined in core CDI.</p>
</div>
</div>
<div class="sect2">
<h3 id="doc_organisation"><a class="anchor" href="#doc_organisation"></a>Organisation of this document</h3>
<div class="paragraph">
<p>This document is organized in 4 parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An introduction (this part), which is not part of the specification but introduces CDI concepts and give examples.</p>
</li>
<li>
<p>The core CDI specification: <a href="#part_1">Part I - Core CDI</a>.</p>
</li>
<li>
<p>Specific CDI features for Java SE: <a href="#part_2">Part II - CDI in Java SE</a>.</p>
</li>
<li>
<p>Specific CDI features for Jakarta EE: <a href="#part_3">Part III - CDI in Jakarta EE</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_major_changes"><a class="anchor" href="#_major_changes"></a>Major changes</h3>
<div class="paragraph">
<p>This CDI 3.0 includes a change in the base namespace used by the APIs from
javax to jakarta. For example, the <code>BeanManager</code> interface has moved from
<code>javax.enterprise.inject.spi.BeanManager</code> to <code>jakarta.enterprise.inject.spi.BeanManager</code>.</p>
</div>
<div class="paragraph">
<p>There is a new beans.xml 3.0 schema file has been added and the namespace of the
beans_3_0.xsd schema file has changed from xmlns:javaee="http://xmlns.jcp.org/xml/ns/javaee" to
xmlns:jakartaee="https://jakarta.ee/xml/ns/jakartaee".</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<h1 id="introduction" class="sect0"><a class="anchor" href="#introduction"></a>Introduction</h1>
<div class="sect1">
<h2 id="architecture"><a class="anchor" href="#architecture"></a>1. Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This specification defines a powerful set of complementary services that help to improve the structure of application code.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A well-defined lifecycle for stateful objects bound to <em>lifecycle contexts</em>, where the set of contexts is extensible</p>
</li>
<li>
<p>A sophisticated, typesafe <em>dependency injection</em> mechanism, including the ability to select dependencies at either development or deployment time, without verbose configuration</p>
</li>
<li>
<p>Support for Jakarta EE modularity and the Jakarta EE component architecture - the modular structure of a Jakarta EE application is taken into account when resolving dependencies between Jakarta EE components</p>
</li>
<li>
<p>Integration with the Jakarta Unified Expression Language (EL), allowing any contextual object to be used directly within a Jakarta Server Faces or JSP page</p>
</li>
<li>
<p>The ability to <em>decorate</em> injected objects</p>
</li>
<li>
<p>The ability to associate interceptors to objects via typesafe <em>interceptor bindings</em></p>
</li>
<li>
<p>An <em>event notification</em> model</p>
</li>
<li>
<p>A web <em>conversation context</em> in addition to the three standard web contexts defined by the Jakarta Servlets specification</p>
</li>
<li>
<p>An SPI allowing <em>portable extensions</em> to integrate cleanly with the container</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The services defined by this specification allow objects to be bound to lifecycle contexts, to be injected, to be associated with interceptors and decorators, and to interact in a loosely coupled fashion by firing and observing events.
Various kinds of objects are injectable, including Jakarta Enterprise Bean 3 session beans, managed beans and Jakarta EE resources.
We refer to these objects in general terms as <em>beans</em> and to instances of beans that belong to contexts as <em>contextual instances</em>.
Contextual instances may be injected into other objects by the dependency injection service.</p>
</div>
<div class="paragraph">
<p>To take advantage of these facilities, the developer provides additional bean-level metadata in the form of Java annotations and application-level metadata in the form of an XML descriptor.</p>
</div>
<div class="paragraph">
<p>The use of these services significantly simplifies the task of creating Jakarta EE applications by integrating the Jakarta EE web tier with Jakarta EE enterprise services.
In particular, Jakarta Enterprise Bean components may be used as Jakarta Server Faces managed beans, thus integrating the programming models of Jakarta Enterprise Bean and Jakarta Server Faces.</p>
</div>
<div class="paragraph">
<p>It&#8217;s even possible to integrate with third-party frameworks.
A portable extension may provide objects to be injected or obtain contextual instances using the dependency injection service. The framework may even raise and observe events using the event notification service.</p>
</div>
<div class="paragraph">
<p>An application that takes advantage of these services may be designed to execute in either the Jakarta EE environment or the Java SE environment.
If the application uses Jakarta EE services such as transaction management and persistence in the Java SE environment, the services are usually restricted to, at most, the subset defined for embedded usage by the Jakarta Enterprise Bean specification.</p>
</div>
<div class="sect2">
<h3 id="_contracts"><a class="anchor" href="#_contracts"></a>1.1. Contracts</h3>
<div class="paragraph">
<p>This specification defines the responsibilities of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the application developer who uses these services, and</p>
</li>
<li>
<p>the vendor who implements the functionality defined by this specification and provides a runtime environment in which the application executes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This runtime environment is called the <em>container</em>.
For example, the container might be a Jakarta EE container or an embeddable Jakarta Enterprise Bean container.</p>
</div>
<div class="paragraph">
<p><a href="#concepts">Concepts</a>, <a href="#implementation">Programming model</a>, <a href="#inheritance">Inheritance and specialization</a>, <a href="#interceptors">Interceptor bindings</a>, <a href="#decorator_bean">Decorator beans</a> and <a href="#observer_methods">Observer methods</a> define the programming model for Jakarta EE components that take advantage of the services defined by this specification, the responsibilities of the component developer, and the annotations used by the component developer to specify metadata.</p>
</div>
<div class="paragraph">
<p><a href="#injection_and_resolution">Dependency injection and lookup</a>, <a href="#contexts">Scopes and contexts</a>, <a href="#lifecycle">Lifecycle of contextual instances</a>, <a href="#decorators">Decorators</a>, <a href="#events">Events</a> and <a href="#interceptor_resolution">Interceptor resolution</a> define the semantics and behavior of the services, the responsibilities of the container implementation and the APIs used by the application to interact directly with the container.</p>
</div>
<div class="paragraph">
<p><a href="#packaging_deployment">Packaging and deployment</a> defines how Jakarta EE applications that use the services defined by this specification must be packaged into bean archives, and the responsibilities of the container implementation at application initialization time.</p>
</div>
<div class="paragraph">
<p><a href="#spi">Portable extensions</a>, <a href="#contextual">The <code>Contextual</code> interface</a> and <a href="#context">The <code>Context</code> interface</a> define an SPI that allows portable extensions to integrate with the container.</p>
</div>
</div>
<div class="sect2">
<h3 id="_relationship_to_other_specifications"><a class="anchor" href="#_relationship_to_other_specifications"></a>1.2. Relationship to other specifications</h3>
<div class="paragraph">
<p>An application developer creates container-managed components such as Jakarta Enterprise Beans, Jakarta Enterprise Beans or servlets and then provides additional metadata that declares additional behavior defined by this specification.
These components may take advantage of the services defined by this specification, together with the enterprise and presentational aspects defined by other Jakarta EE platform technologies.</p>
</div>
<div class="paragraph">
<p>In addition, this specification defines an SPI that allows alternative, non-platform technologies to integrate with the container and the Jakarta EE environment, for example, alternative web presentation technologies.</p>
</div>
<div class="sect3">
<h4 id="_relationship_to_the_jakarta_ee_platform_specification"><a class="anchor" href="#_relationship_to_the_jakarta_ee_platform_specification"></a>1.2.1. Relationship to the Jakarta EE platform specification</h4>
<div class="paragraph">
<p>In the Jakarta EE environment, all <em>component classes supporting injection</em>, as defined by the Jakarta EE platform specification, may inject beans via the dependency injection service.</p>
</div>
<div class="paragraph">
<p>The Jakarta EE platform specification defines a facility for injecting <em>resources</em> that exist in the <em>Jakarta EE component environment</em>.
Resources are identified by string-based names.
This specification bolsters that functionality, adding the ability to inject an open-ended set of object types, including, but not limited to, component environment resources, based upon typesafe qualifiers.</p>
</div>
</div>
<div class="sect3">
<h4 id="_relationship_to_jakarta_enterprise_bean"><a class="anchor" href="#_relationship_to_jakarta_enterprise_bean"></a>1.2.2. Relationship to Jakarta Enterprise Bean</h4>
<div class="paragraph">
<p>Jakarta Enterprise Bean defines a programming model for application components that access transactional resources in a multi-user environment.
Jakarta Enterprise Bean allows concerns such as role-based security, transaction demarcation, concurrency and scalability to be specified declaratively using annotations and XML deployment descriptors and enforced by the Jakarta Enterprise Bean container at runtime.</p>
</div>
<div class="paragraph">
<p>Jakarta Enterprise Bean components may be stateful, but are not by nature contextual.
References to stateful component instances must be explicitly passed between clients and stateful instances must be explicitly destroyed by the application.</p>
</div>
<div class="paragraph">
<p>This specification enhances the Jakarta Enterprise Bean component model with contextual lifecycle management.</p>
</div>
<div class="paragraph">
<p>Any session bean instance obtained via the dependency injection service is a contextual instance. It is bound to a lifecycle context and is available to other objects that execute in that context.
The container automatically creates the instance when it is needed by a client.
When the context ends, the container automatically destroys the instance.</p>
</div>
<div class="paragraph">
<p>Message-driven and entity beans are by nature non-contextual objects and may not be injected into other objects.</p>
</div>
<div class="paragraph">
<p>The container performs dependency injection on all session and message-driven bean instances, even those which are not contextual instances.</p>
</div>
</div>
<div class="sect3">
<h4 id="_relationship_to_managed_beans"><a class="anchor" href="#_relationship_to_managed_beans"></a>1.2.3. Relationship to managed beans</h4>
<div class="paragraph">
<p>The Managed Beans specification defines the basic programming model for application components managed by the Jakarta EE container.</p>
</div>
<div class="paragraph">
<p>As defined by this specification, most Java classes, including all Jakarta Enterprise Beans, are managed beans.</p>
</div>
<div class="paragraph">
<p>This specification defines contextual lifecycle management and dependency injection as generic services applicable to all managed beans.</p>
</div>
<div class="paragraph">
<p>Any managed bean instance obtained via the dependency injection service is a contextual instance. It is bound to a lifecycle context and is available to other objects that execute in that context.
The container automatically creates the instance when it is needed by a client.
When the context ends, the container automatically destroys the instance.</p>
</div>
<div class="paragraph">
<p>The container performs dependency injection on all managed bean instances, even those which are not contextual instances.</p>
</div>
</div>
<div class="sect3">
<h4 id="_relationship_to_jakarta_dependency_injection"><a class="anchor" href="#_relationship_to_jakarta_dependency_injection"></a>1.2.4. Relationship to Jakarta Dependency Injection</h4>
<div class="paragraph">
<p>The Jakarta Dependency Injection specification defines a set of annotations for the declaring injected fields, methods and constructors of a bean.
The dependency injection service makes use of these annotations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_relationship_to_jakarta_interceptors"><a class="anchor" href="#_relationship_to_jakarta_interceptors"></a>1.2.5. Relationship to Jakarta Interceptors</h4>
<div class="paragraph">
<p>The Jakarta Interceptors specification defines the basic programming model and semantics for interceptors.
This specification enhances that model by providing the ability to associate interceptors with beans using typesafe interceptor bindings.</p>
</div>
</div>
<div class="sect3">
<h4 id="_relationship_to_jakarta_server_faces"><a class="anchor" href="#_relationship_to_jakarta_server_faces"></a>1.2.6. Relationship to Jakarta Server Faces</h4>
<div class="paragraph">
<p>Jakarta Server Faces is a web-tier presentation framework that provides a component model for graphical user interface components and an event-driven interaction model that binds user interface components to objects accessible via Unified EL.</p>
</div>
<div class="paragraph">
<p>This specification allows any bean to be assigned a name. Thus, a Jakarta Server Faces application may take advantage of the sophisticated context and dependency injection model defined by this specification.</p>
</div>
</div>
<div class="sect3">
<h4 id="_relationship_to_jakarta_bean_validation"><a class="anchor" href="#_relationship_to_jakarta_bean_validation"></a>1.2.7. Relationship to Jakarta Bean Validation</h4>
<div class="paragraph">
<p>Jakarta Bean Validation provides a unified way of declaring and defining constraints on an object model, defines a runtime engine to validate objects and provides method validation.</p>
</div>
<div class="paragraph">
<p>The Jakarta Bean Validation specification defines beans for Bean Validation managed objects including <code>Validator</code> and <code>ValidatorFactory</code>.
A number of Bean Validation managed instances, including <code>ConstraintValidator</code> s can take advantage of dependency injection.
Bean Validation also provides support for method parameter validation on any bean.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_introductory_examples"><a class="anchor" href="#_introductory_examples"></a>1.3. Introductory examples</h3>
<div class="paragraph">
<p>The following examples demonstrate the use of lifecycle contexts and dependency injection.</p>
</div>
<div class="sect3">
<h4 id="_jakarta_server_faces_example"><a class="anchor" href="#_jakarta_server_faces_example"></a>1.3.1. Jakarta Server Faces example</h4>
<div class="paragraph">
<p>The following Jakarta Server Faces page defines a login prompt for a web application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;f:view&gt;</span>
    <span class="tag">&lt;h:form&gt;</span>
        <span class="tag">&lt;h:panelGrid</span> <span class="attribute-name">columns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">rendered</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{!login.loggedIn}</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
            <span class="tag">&lt;h:outputLabel</span> <span class="attribute-name">for</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>Username:<span class="tag">&lt;/h:outputLabel&gt;</span>
            <span class="tag">&lt;h:inputText</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{credentials.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
            <span class="tag">&lt;h:outputLabel</span> <span class="attribute-name">for</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>Password:<span class="tag">&lt;/h:outputLabel&gt;</span>
            <span class="tag">&lt;h:inputText</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{credentials.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/h:panelGrid&gt;</span>
        <span class="tag">&lt;h:commandButton</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Login</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">action</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{login.login}</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">rendered</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{!login.loggedIn}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;h:commandButton</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Logout</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">action</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{login.logout}</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">rendered</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{login.loggedIn}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
    <span class="tag">&lt;/h:form&gt;</span>
<span class="tag">&lt;/f:view&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Jakarta EL expressions in this page refer to beans named <code>credentials</code> and <code>login</code>.</p>
</div>
<div class="paragraph">
<p>The <code>Credentials</code> bean has a lifecycle that is bound to the Jakarta Server Faces request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Model</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Credentials</span> {

    <span class="directive">private</span> <span class="predefined-type">String</span> username;
    <span class="directive">private</span> <span class="predefined-type">String</span> password;

    <span class="directive">public</span> <span class="predefined-type">String</span> getUsername() { <span class="keyword">return</span> username; }
    <span class="directive">public</span> <span class="type">void</span> setUsername(<span class="predefined-type">String</span> username) { <span class="local-variable">this</span>.username = username; }

    <span class="directive">public</span> <span class="predefined-type">String</span> getPassword() { <span class="keyword">return</span> password; }
    <span class="directive">public</span> <span class="type">void</span> setPassword(<span class="predefined-type">String</span> password) { <span class="local-variable">this</span>.password = password; }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Model</code> annotation defined in <a href="#builtin_stereotypes">Built-in stereotypes</a> is a <em>stereotype</em> that identifies the <code>Credentials</code> bean as a model object in an MVC architecture.</p>
</div>
<div class="paragraph">
<p>The <code>Login</code> bean has a lifecycle that is bound to the HTTP session:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SessionScoped</span> <span class="annotation">@Model</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Login</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span> {

    <span class="annotation">@Inject</span> Credentials credentials;
    <span class="annotation">@Inject</span> <span class="annotation">@Users</span> EntityManager userDatabase;

    <span class="directive">private</span> CriteriaQuery&lt;User&gt; query;
    <span class="directive">private</span> Parameter&lt;<span class="predefined-type">String</span>&gt; usernameParam;
    <span class="directive">private</span> Parameter&lt;<span class="predefined-type">String</span>&gt; passwordParam;

    <span class="directive">private</span> User user;

    <span class="annotation">@Inject</span>
    <span class="type">void</span> initQuery(<span class="annotation">@Users</span> EntityManagerFactory emf) {
        CriteriaBuilder cb = emf.getCriteriaBuilder();
        usernameParam = cb.parameter(<span class="predefined-type">String</span>.class);
        passwordParam = cb.parameter(<span class="predefined-type">String</span>.class);
        query = cb.createQuery(User.class);
        Root&lt;User&gt; u = query.from(User.class);
        query.select(u);
        query.where( cb.equal(u.get(User_.username), usernameParam),
                     cb.equal(u.get(User_.password), passwordParam) );
    }

    <span class="directive">public</span> <span class="type">void</span> login() {

        <span class="predefined-type">List</span>&lt;User&gt; results = userDatabase.createQuery(query)
            .setParameter(usernameParam, credentials.getUsername())
            .setParameter(passwordParam, credentials.getPassword())
            .getResultList();

        <span class="keyword">if</span> ( !results.isEmpty() ) {
            user = results.get(<span class="integer">0</span>);
        }

    }

    <span class="directive">public</span> <span class="type">void</span> logout() {
        user = <span class="predefined-constant">null</span>;
    }

    <span class="directive">public</span> <span class="type">boolean</span> isLoggedIn() {
        <span class="keyword">return</span> user!=<span class="predefined-constant">null</span>;
    }

    <span class="annotation">@Produces</span> <span class="annotation">@LoggedIn</span> User getCurrentUser() {
        <span class="keyword">if</span> (user==<span class="predefined-constant">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> NotLoggedInException();
        }
        <span class="keyword">else</span> {
            <span class="keyword">return</span> user;
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@SessionScoped</code> annotation defined in <a href="#builtin_scopes">Built-in scope types</a> is a <em>scope type</em> that specifies the lifecycle of instances of <code>Login</code>. Managed beans with this scope must be serializable.</p>
</div>
<div class="paragraph">
<p>The <code>@Inject</code> annotation defined by the Jakarta Dependency Injection specification identifies an <em>injected field</em> which is initialized by the container when the bean is instantiated, or an <em>initializer method</em> which is called by the container after the bean is instantiated, with injected parameters.</p>
</div>
<div class="paragraph">
<p>The <code>@Users</code> annotation is a qualifier type defined by the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Qualifier</span>
<span class="annotation">@Retention</span>(RUNTIME)
<span class="annotation">@Target</span>({METHOD, FIELD, PARAMETER, TYPE})
<span class="directive">public</span> <span class="annotation">@interface</span> Users {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@LoggedIn</code> annotation is another qualifier type defined by the application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Qualifier</span>
<span class="annotation">@Retention</span>(RUNTIME)
<span class="annotation">@Target</span>({METHOD, FIELD, PARAMETER, TYPE})
<span class="directive">public</span> <span class="annotation">@interface</span> LoggedIn {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Produces</code> annotation defined in <a href="#declaring_producer_method">Declaring a producer method</a> identifies the method <code>getCurrentUser()</code> as a <em>producer method</em>, which will be called whenever another bean in the system needs the currently logged-in user, for example, whenever the <code>user</code> attribute of the <code>DocumentEditor</code> class is injected by the container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Model</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">DocumentEditor</span> {

    <span class="annotation">@Inject</span> <span class="predefined-type">Document</span> document;
    <span class="annotation">@Inject</span> <span class="annotation">@LoggedIn</span> User currentUser;
    <span class="annotation">@Inject</span> <span class="annotation">@Documents</span> EntityManager docDatabase;

    <span class="directive">public</span> <span class="type">void</span> save() {
        document.setCreatedBy(currentUser);
        em.persist(document);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Documents</code> annotation is another application-defined qualifier type. The use of distinct qualifier types enables the container to distinguish which Jakarta Persistence persistence unit is required.</p>
</div>
<div class="paragraph">
<p>When the login form is submitted, Jakarta Server Faces assigns the entered username and password to an instance of the <code>Credentials</code> bean that is automatically instantiated by the container.
Next, Jakarta Server Faces calls the <code>login()</code> method of an instance of <code>Login</code> that is automatically instantiated by the container.
This instance continues to exist for and be available to other requests in the same HTTP session, and provides the <code>User</code> object representing the current user to any other bean that requires it (for example, <code>DocumentEditor</code>). If the producer method is called before the <code>login()</code> method initializes the user object, it throws a <code>NotLoggedInException</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_jakarta_enterprise_bean_example"><a class="anchor" href="#_jakarta_enterprise_bean_example"></a>1.3.2. Jakarta Enterprise Bean example</h4>
<div class="paragraph">
<p>Alternatively, we could write our <code>Login</code> bean to take advantage of the functionality defined by Jakarta Enterprise Bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Stateful</span> <span class="annotation">@SessionScoped</span> <span class="annotation">@Model</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Login</span> {

    <span class="annotation">@Inject</span> Credentials credentials;
    <span class="annotation">@Inject</span> <span class="annotation">@Users</span> EntityManager userDatabase;

    ...

    private User user;

    <span class="annotation">@Inject</span>
    <span class="type">void</span> initQuery(<span class="annotation">@Users</span> EntityManagerFactory emf) {
       ...
    }

    <span class="annotation">@TransactionAttribute</span>(REQUIRES_NEW)
    <span class="annotation">@RolesAllowed</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">guest</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> login() {
        ...
    }

    <span class="directive">public</span> <span class="type">void</span> logout() {
        user = <span class="predefined-constant">null</span>;
    }

    <span class="directive">public</span> <span class="type">boolean</span> isLoggedIn() {
        <span class="keyword">return</span> user!=<span class="predefined-constant">null</span>;
    }

    <span class="annotation">@RolesAllowed</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Produces</span> <span class="annotation">@LoggedIn</span> User getCurrentUser() {
        ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Jakarta Enterprise Bean <code>@Stateful</code> annotation specifies that this bean is an Jakarta Enterprise Bean stateful session bean.
The Jakarta Enterprise Bean <code>@TransactionAttribute</code> and <code>@RolesAllowed</code> annotations declare the Jakarta Enterprise Bean transaction demarcation and security attributes of the annotated methods.</p>
</div>
</div>
<div class="sect3">
<h4 id="_jakarta_ee_component_environment_example"><a class="anchor" href="#_jakarta_ee_component_environment_example"></a>1.3.3. Jakarta EE component environment example</h4>
<div class="paragraph">
<p>In the previous examples, we injected container-managed persistence contexts using qualifier types.
We need to tell the container what persistence context is being referred to by which qualifier type. We can declare references to persistence contexts and other resources in the Jakarta EE component environment in Java code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Databases</span> {

    <span class="annotation">@Produces</span> <span class="annotation">@PersistenceContext</span>(unitName=<span class="string"><span class="delimiter">&quot;</span><span class="content">UserData</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Users</span> EntityManager userDatabaseEntityManager;

    <span class="annotation">@Produces</span> <span class="annotation">@PersistenceUnit</span>(unitName=<span class="string"><span class="delimiter">&quot;</span><span class="content">UserData</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Users</span> EntityManagerFactory userDatabaseEntityManagerFactory;

    <span class="annotation">@Produces</span> <span class="annotation">@PersistenceContext</span>(unitName=<span class="string"><span class="delimiter">&quot;</span><span class="content">DocumentData</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Documents</span> EntityManager docDatabaseEntityManager;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Jakarta Persistence <code>@PersistenceContext</code> and <code>@PersistenceUnit</code> annotations identify the Jakarta Persistence persistence unit.</p>
</div>
</div>
<div class="sect3">
<h4 id="_event_example"><a class="anchor" href="#_event_example"></a>1.3.4. Event example</h4>
<div class="paragraph">
<p>Beans may raise events.
For example, our <code>Login</code> class could raise events when a user logs in or out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SessionScoped</span> <span class="annotation">@Model</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Login</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span> {

    <span class="annotation">@Inject</span> Credentials credentials;
    <span class="annotation">@Inject</span> <span class="annotation">@Users</span> EntityManager userDatabase;

    <span class="annotation">@Inject</span> <span class="annotation">@LoggedIn</span> <span class="predefined-type">Event</span>&lt;User&gt; userLoggedInEvent;
    <span class="annotation">@Inject</span> <span class="annotation">@LoggedOut</span> <span class="predefined-type">Event</span>&lt;User&gt; userLoggedOutEvent;

    ...

    private User user;

    <span class="annotation">@Inject</span>
    <span class="type">void</span> initQuery(<span class="annotation">@Users</span> EntityManagerFactory emf) {
       ...
    }

    <span class="directive">public</span> <span class="type">void</span> login() {

        <span class="predefined-type">List</span>&lt;User&gt; results = ... ;

        <span class="keyword">if</span> ( !results.isEmpty() ) {
            user = results.get(<span class="integer">0</span>);
            userLoggedInEvent.fire(user);
        }

    }

    <span class="directive">public</span> <span class="type">void</span> logout() {
        userLoggedOutEvent.fire(user);
        user = <span class="predefined-constant">null</span>;
    }

    <span class="directive">public</span> <span class="type">boolean</span> isLoggedIn() {
        <span class="keyword">return</span> user!=<span class="predefined-constant">null</span>;
    }

    <span class="annotation">@Produces</span> <span class="annotation">@LoggedIn</span> User getCurrentUser() {
        ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>fire()</code> of the built-in bean of type <code>Event</code> defined in <a href="#event">The <code>Event</code> interface</a> allows the application to fire events.
Events consist of an <em>event object</em> - in this case the <code>User</code> - and event qualifiers.
Event qualifier - such as <code>@LoggedIn</code> and <code>@LoggedOut</code> - allow event consumers to specify which events of a certain type they are interested in.</p>
</div>
<div class="paragraph">
<p>Other beans may observe these events and use them to synchronize their internal state, with no coupling to the bean producing the events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SessionScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Permissions</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span> {

    <span class="annotation">@Produces</span>
    <span class="directive">private</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Permission</span>&gt; permissions = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">Permission</span>&gt;();

    <span class="annotation">@Inject</span> <span class="annotation">@Users</span> EntityManager userDatabase;
    Parameter&lt;<span class="predefined-type">String</span>&gt; usernameParam;
    CriteriaQuery&lt;<span class="predefined-type">Permission</span>&gt; query;

    <span class="annotation">@Inject</span>
    <span class="type">void</span> initQuery(<span class="annotation">@Users</span> EntityManagerFactory emf) {
        CriteriaBuilder cb = emf.getCriteriaBuilder();
        usernameParam = cb.parameter(<span class="predefined-type">String</span>.class);
        query = cb.createQuery(<span class="predefined-type">Permission</span>.class);
        Root&lt;<span class="predefined-type">Permission</span>&gt; p = query.from(<span class="predefined-type">Permission</span>.class);
        query.select(p);
        query.where( cb.equal(p.get(Permission_.user).get(User_.username),
                     usernameParam) );
    }

    <span class="type">void</span> onLogin(<span class="annotation">@Observes</span> <span class="annotation">@LoggedIn</span> User user) {
        permissions = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">Permission</span>&gt;( userDatabase.createQuery(query)
            .setParameter(usernameParam, user.getUsername())
            .getResultList() );
    }

    <span class="type">void</span> onLogout(<span class="annotation">@Observes</span> <span class="annotation">@LoggedOut</span> User user {
        permissions.clear();
    }


}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Produces</code> annotation applied to a field identifies the field as a producer field, as defined in <a href="#producer_field">Producer fields</a>, a kind of shortcut version of a producer method.
This producer field allows the permissions of the current user to be injected to an injection point of type <code>Set&lt;Permission&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The <code>@Observes</code> annotation defined in <a href="#observes">Declaring an observer method</a> identifies the method with the annotated parameter as an <em>observer method</em> that is called by the container whenever an event matching the type and qualifiers of the annotated parameter is fired.</p>
</div>
</div>
<div class="sect3">
<h4 id="_injection_point_metadata_example"><a class="anchor" href="#_injection_point_metadata_example"></a>1.3.5. Injection point metadata example</h4>
<div class="paragraph">
<p>It is possible to implement generic beans that introspect the injection point to which they belong. This makes it possible to implement injection for <code>Logger</code> s, for example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Loggers</span> {

    <span class="annotation">@Produces</span> <span class="predefined-type">Logger</span> getLogger(InjectionPoint injectionPoint) {
        <span class="keyword">return</span> <span class="predefined-type">Logger</span>.getLogger( injectionPoint.getMember().getDeclaringClass().getSimpleName() );
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>InjectionPoint</code> interface defined in <a href="#injection_point">Injection point metadata</a>, provides metadata about the injection point to the object being injected into it.</p>
</div>
<div class="paragraph">
<p>Then this class will have a <code>Logger</code> named <code>"Permissions"</code> injected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SessionScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Permissions</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span> {

    <span class="annotation">@Inject</span> <span class="predefined-type">Logger</span> log;

    ...

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_interceptor_example"><a class="anchor" href="#_interceptor_example"></a>1.3.6. Interceptor example</h4>
<div class="paragraph">
<p><em>Interceptors</em> allow common, cross-cutting concerns to be applied to beans via custom annotations.
Interceptor types may be individually enabled or disabled at deployment time.</p>
</div>
<div class="paragraph">
<p>The <code>AuthorizationInterceptor</code> class defines a custom authorization check:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Secure</span> <span class="annotation">@Interceptor</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AuthorizationInterceptor</span> {

    <span class="annotation">@Inject</span> <span class="annotation">@LoggedIn</span> User user;
    <span class="annotation">@Inject</span> <span class="predefined-type">Logger</span> log;

    <span class="annotation">@AroundInvoke</span>
    <span class="directive">public</span> <span class="predefined-type">Object</span> authorize(InvocationContext ic) <span class="directive">throws</span> <span class="exception">Exception</span> {
        <span class="keyword">try</span> {
            <span class="keyword">if</span> ( !user.isBanned() ) {
                log.fine(<span class="string"><span class="delimiter">&quot;</span><span class="content">Authorized</span><span class="delimiter">&quot;</span></span>);
                <span class="keyword">return</span> ic.proceed();
            }
            <span class="keyword">else</span> {
                log.fine(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not authorized</span><span class="delimiter">&quot;</span></span>);
                <span class="keyword">throw</span> <span class="keyword">new</span> NotAuthorizedException();
            }
        }
        <span class="keyword">catch</span> (NotAuthenticatedException nae) {
            log.fine(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not authenticated</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">throw</span> nae;
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Interceptor</code> annotation, defined in <a href="#declaring_interceptor">Declaring the interceptor bindings of an interceptor</a>, identifies the <code>AuthorizationInterceptor</code> class as an interceptor.
The <code>@Secure</code> annotation is a custom <em>interceptor binding type</em>, as defined in <a href="#interceptor_bindings">Interceptor binding types</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inherited</span>
<span class="annotation">@InterceptorBinding</span>
<span class="annotation">@Target</span>({TYPE, METHOD})
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> Secure {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Secure</code> annotation is used to apply the interceptor to a bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Model</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">DocumentEditor</span> {

    <span class="annotation">@Inject</span> <span class="predefined-type">Document</span> document;
    <span class="annotation">@Inject</span> <span class="annotation">@LoggedIn</span> User user;
    <span class="annotation">@Inject</span> <span class="annotation">@Documents</span> EntityManager em;

    <span class="annotation">@Secure</span>
    <span class="directive">public</span> <span class="type">void</span> save() {
        document.setCreatedBy(currentUser);
        em.persist(document);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>save()</code> method is invoked, the <code>authorize()</code> method of the interceptor will be called.
The invocation will proceed to the <code>DocumentEditor</code> class only if the authorization check is successful.</p>
</div>
</div>
<div class="sect3">
<h4 id="_decorator_example"><a class="anchor" href="#_decorator_example"></a>1.3.7. Decorator example</h4>
<div class="paragraph">
<p><em>Decorators</em> are similar to interceptors, but apply only to beans of a particular Java interface. Like interceptors, decorators may be easily enabled or disabled at deployment time. Unlike interceptors, decorators are aware of the semantics of the intercepted method.</p>
</div>
<div class="paragraph">
<p>For example, the <code>DataAccess</code> interface might be implemented by many beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">DataAccess</span>&lt;T, V&gt; {

    <span class="directive">public</span> V getId(T object);
    <span class="directive">public</span> T load(V id);
    <span class="directive">public</span> <span class="type">void</span> save(T object);
    <span class="directive">public</span> <span class="type">void</span> delete(T object);

    <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;T&gt; getDataType();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DataAccessAuthorizationDecorator</code> class defines the authorization checks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Decorator</span>
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">DataAccessAuthorizationDecorator</span>&lt;T, V&gt; <span class="directive">implements</span> DataAccess&lt;T, V&gt; {

    <span class="annotation">@Inject</span> <span class="annotation">@Delegate</span> DataAccess&lt;T, V&gt; delegate;

    <span class="annotation">@Inject</span> <span class="predefined-type">Logger</span> log;
    <span class="annotation">@Inject</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Permission</span>&gt; permissions;

    <span class="directive">public</span> <span class="type">void</span> save(T object) {
        authorize(SecureAction.SAVE, object);
        delegate.save(object);
    }

    <span class="directive">public</span> <span class="type">void</span> delete(T object) {
        authorize(SecureAction.DELETE, object);
        delegate.delete(object);
    }

    <span class="directive">private</span> <span class="type">void</span> authorize(SecureAction action, T object) {
        V id = delegate.getId(object);
        <span class="predefined-type">Class</span>&lt;T&gt; type = delegate.getDataType();
        <span class="keyword">if</span> ( permissions.contains( <span class="keyword">new</span> <span class="predefined-type">Permission</span>(action, type, id) ) ) {
            log.fine(<span class="string"><span class="delimiter">&quot;</span><span class="content">Authorized for </span><span class="delimiter">&quot;</span></span> + action);
        }
        <span class="keyword">else</span> {
            log.fine(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not authorized for </span><span class="delimiter">&quot;</span></span> + action);
            <span class="keyword">throw</span> <span class="keyword">new</span> NotAuthorizedException(action);
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Decorator</code> annotation defined in <a href="#decorator_annotation">Declaring a decorator</a> identifies the <code>DataAccessAuthorizationDecorator</code> class as a decorator.
The <code>@Delegate</code> annotation defined in <a href="#delegate_attribute">Decorator delegate injection points</a> identifies the <em>delegate</em>, which the decorator uses to delegate method calls to the container.
The decorator applies to any bean that implements <code>DataAccess</code>.</p>
</div>
<div class="paragraph">
<p>The decorator intercepts invocations just like an interceptor.
However, unlike an interceptor, the decorator contains functionality that is specific to the semantics of the method being called.</p>
</div>
<div class="paragraph">
<p>Decorators may be declared abstract, relieving the developer of the responsibility of implementing all methods of the decorated interface. If a decorator does not implement a method of a decorated interface, the decorator will simply not be called when that method is invoked upon the decorated bean.</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="part_1" class="sect0"><a class="anchor" href="#part_1"></a>Part I - Core CDI</h1>
<div class="sect1">
<h2 id="concepts"><a class="anchor" href="#concepts"></a>2. Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A bean is a source of contextual objects which define application state and/or logic.
These objects are called <em>contextual instances of the bean</em>.
The container creates and destroys these instances and associates them with the appropriate context.
Contextual instances of a bean may be injected into other objects (including other bean instances) that execute in the same context.
A bean may bear metadata defining its lifecycle and interactions with other beans.</p>
</div>
<div class="paragraph">
<p>A bean comprises the following attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A (nonempty) set of bean types</p>
</li>
<li>
<p>A (nonempty) set of qualifiers</p>
</li>
<li>
<p>A scope</p>
</li>
<li>
<p>Optionally, a bean name</p>
</li>
<li>
<p>A set of interceptor bindings</p>
</li>
<li>
<p>A bean implementation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Furthermore, a bean may or may not be an alternative.</p>
</div>
<div class="paragraph">
<p>A bean developer provides the bean implementation by writing business logic in Java code.
The developer then defines the remaining attributes by explicitly annotating the bean class, or by allowing them to be defaulted by the container, as specified in <a href="#implementation">Programming model</a>.</p>
</div>
<div class="paragraph">
<p>The bean types and qualifiers of a bean determine where its instances will be injected by the container, as defined in <a href="#injection_and_resolution">Dependency injection and lookup</a>.</p>
</div>
<div class="paragraph">
<p>The bean developer may also create interceptors and/or decorators or reuse existing interceptors and/or decorators.
The interceptor bindings of a bean determine which interceptors will be applied at runtime.
The bean types and qualifiers of a bean determine which decorators will be applied at runtime.
Interceptors are defined by Java interceptors specification, and interceptor bindings are specified in <a href="#interceptors">Interceptor bindings</a>.
Decorators are defined in <a href="#decorators">Decorators</a>.</p>
</div>
<div class="sect2">
<h3 id="capabilities"><a class="anchor" href="#capabilities"></a>2.1. Functionality provided by the container to the bean</h3>
<div class="paragraph">
<p>A bean is provided by the container with the following capabilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>transparent creation and destruction and scoping to a particular context, specified in <a href="#contexts">Scopes and contexts</a> and <a href="#lifecycle">Lifecycle of contextual instances</a>,</p>
</li>
<li>
<p>scoped resolution by bean type and qualifier annotation type when injected into a Java-based client, as defined by <a href="#typesafe_resolution">Typesafe resolution</a>,</p>
</li>
<li>
<p>lifecycle callbacks and automatic injection of other bean instances, specified in <a href="#implementation">Programming model</a> and <a href="#injection_and_resolution">Dependency injection and lookup</a>,</p>
</li>
<li>
<p>method interception, callback interception, and decoration, as defined in <a href="#interceptors">Interceptor bindings</a> and <a href="#decorators">Decorators</a>, and</p>
</li>
<li>
<p>event notification, as defined in <a href="#events">Events</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bean_types"><a class="anchor" href="#bean_types"></a>2.2. Bean types</h3>
<div class="paragraph">
<p>A bean type defines a client-visible type of the bean.
A bean may have multiple bean types.
For example, the following bean has four bean types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BookShop</span>
        <span class="directive">extends</span> Business
        <span class="directive">implements</span> Shop&lt;<span class="predefined-type">Book</span>&gt; {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean types are <code>BookShop</code>, <code>Business</code>, <code>Shop&lt;Book&gt;</code> and <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>The rules for determining the (unrestricted) set of bean types for a bean are defined in <a href="#managed_bean_types">Bean types of a managed bean</a>, <a href="#producer_method_types">Bean types of a producer method</a> and <a href="#producer_field_types">Bean types of a producer field</a>.</p>
</div>
<div class="paragraph">
<p>All beans have the bean type <code>java.lang.Object</code>.</p>
</div>
<div class="paragraph">
<p>The bean types of a bean are used by the rules of typesafe resolution defined in <a href="#typesafe_resolution">Typesafe resolution</a>.</p>
</div>
<div class="sect3">
<h4 id="legal_bean_types"><a class="anchor" href="#legal_bean_types"></a>2.2.1. Legal bean types</h4>
<div class="paragraph">
<p>Almost any Java type may be a bean type of a bean:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A bean type may be an interface, a concrete class or an abstract class, and may be declared final or have final methods.</p>
</li>
<li>
<p>A bean type may be a parameterized type with actual type parameters and type variables.</p>
</li>
<li>
<p>A bean type may be an array type.
Two array types are considered identical only if the element type is identical.</p>
</li>
<li>
<p>A bean type may be a primitive type.
Primitive types are considered to be identical to their corresponding wrapper types in <code>java.lang</code>.</p>
</li>
<li>
<p>A bean type may be a raw type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, some Java types are not legal bean types :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A type variable is not a legal bean type.</p>
</li>
<li>
<p>A parameterized type that contains a wildcard type parameter is not a legal bean type.</p>
</li>
<li>
<p>An array type whose component type is not a legal bean type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that certain additional restrictions are specified in <a href="#unproxyable">Unproxyable bean types</a> for beans with a normal scope, as defined in <a href="#normal_scope">Normal scopes and pseudo-scopes</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="restricting_bean_types"><a class="anchor" href="#restricting_bean_types"></a>2.2.2. Restricting the bean types of a bean</h4>
<div class="paragraph">
<p>The bean types of a bean may be restricted by annotating the bean class or producer method or field with the annotation <code>@jakarta.enterprise.inject.Typed</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Typed</span>(Shop.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">BookShop</span>
        <span class="directive">extends</span> Business
        <span class="directive">implements</span> Shop&lt;<span class="predefined-type">Book</span>&gt; {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a <code>@Typed</code> annotation is explicitly specified, only the types whose classes are explicitly listed using the <code>value</code> member, together with <code>java.lang.Object</code>, are bean types of the bean.</p>
</div>
<div class="paragraph">
<p>In the example, the bean has a two bean types: <code>Shop&lt;Book&gt;</code> and <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>If a bean class or producer method or field specifies a <code>@Typed</code> annotation, and the <code>value</code> member specifies a class which does not correspond to a type in the unrestricted set of bean types of a bean, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
<div class="sect3">
<h4 id="typecasting_between_bean_types"><a class="anchor" href="#typecasting_between_bean_types"></a>2.2.3. Typecasting between bean types</h4>
<div class="paragraph">
<p>A client of a bean may typecast its contextual reference to a bean to any bean type of the bean which is a Java interface.
However, the client may not in general typecast its contextual reference to an arbitrary concrete bean type of the bean.
For example, if our managed bean was injected to the following field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> Business biz;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the following typecast is legal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Shop&lt;<span class="predefined-type">Book</span>&gt; bookShop = (Shop&lt;<span class="predefined-type">Book</span>&gt;) biz;</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the following typecast is not legal and might result in an exception at runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">BookShop bookShop = (BookShop) biz;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="qualifiers"><a class="anchor" href="#qualifiers"></a>2.3. Qualifiers</h3>
<div class="paragraph">
<p>For a given bean type, there may be multiple beans which implement the type.
For example, an application may have two implementations of the interface <code>PaymentProcessor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">SynchronousPaymentProcessor</span>
        <span class="directive">implements</span> PaymentProcessor {
    ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">AsynchronousPaymentProcessor</span>
        <span class="directive">implements</span> PaymentProcessor {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A client that needs a <code>PaymentProcessor</code> that processes payments synchronously needs some way to distinguish between the two different implementations.
One approach would be for the client to explicitly specify the class that implements the <code>PaymentProcessor</code> interface.
However, this approach creates a hard dependence between client and implementation - exactly what use of the interface was designed to avoid!</p>
</div>
<div class="paragraph">
<p>A <em>qualifier type</em> represents some client-visible semantic associated with a type that is satisfied by some implementations of the type (and not by others). For example, we could introduce qualifier types representing synchronicity and asynchronicity.
In Java code, qualifier types are represented by annotations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Synchronous</span>
<span class="type">class</span> <span class="class">SynchronousPaymentProcessor</span>
        <span class="directive">implements</span> PaymentProcessor {
    ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Asynchronous</span>
<span class="type">class</span> <span class="class">AsynchronousPaymentProcessor</span>
        <span class="directive">implements</span> PaymentProcessor {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, qualifier types are applied to injection points to distinguish which implementation is required by the client.
For example, when the container encounters the following injected field, an instance of <code>SynchronousPaymentProcessor</code> will be injected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Synchronous</span> PaymentProcessor paymentProcessor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>But in this case, an instance of <code>AsynchronousPaymentProcessor</code> will be injected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Asynchronous</span> PaymentProcessor paymentProcessor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The container inspects the qualifier annotations and type of the injected attribute to determine the bean instance to be injected, according to the rules of typesafe resolution defined in <a href="#typesafe_resolution">Typesafe resolution</a>.</p>
</div>
<div class="paragraph">
<p>An injection point may even specify multiple qualifiers.</p>
</div>
<div class="paragraph">
<p>Qualifier types are also used as event selectors by event consumers, as defined in <a href="#events">Events</a>, and to bind decorators to beans, as specified in <a href="#decorators">Decorators</a>.</p>
</div>
<div class="sect3">
<h4 id="builtin_qualifiers"><a class="anchor" href="#builtin_qualifiers"></a>2.3.1. Built-in qualifier types</h4>
<div class="paragraph">
<p>Three standard qualifier types are defined in the package <code>jakarta.enterprise.inject</code>. In addition, the built-in qualifier type <code>@Named</code> is defined by the package <code>jakarta.inject</code>.</p>
</div>
<div class="paragraph">
<p>Every bean has the built-in qualifier <code>@Any</code>, even if it does not explicitly declare this qualifier, except for the special <code>@New</code> qualified beans defined in <a href="#new"><code>@New</code> qualified beans</a>.</p>
</div>
<div class="paragraph">
<p>If a bean does not explicitly declare a qualifier other than <code>@Named</code> or <code>@Any</code>, the bean has exactly one additional qualifier, of type <code>@Default</code>. This is called the <em>default qualifier</em>.</p>
</div>
<div class="paragraph">
<p>The following declarations are equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Default</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both declarations result in a bean with two qualifiers: <code>@Any</code> and <code>@Default</code>.</p>
</div>
<div class="paragraph">
<p>The following declaration results in a bean with three qualifiers: <code>@Any</code>, <code>@Default</code> and <code>@Named("ord")</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">ord</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default qualifier is also assumed for any injection point that does not explicitly declare a qualifier, as defined in <a href="#injection_point_default_qualifier">The default qualifier at injection points</a>.
The following declarations, in which the use of the <code>@Inject</code> annotation identifies the constructor parameter as an injection point, are equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> {
    <span class="annotation">@Inject</span>
    <span class="directive">public</span> Order(<span class="annotation">@Default</span> OrderProcessor processor) { ... }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> {
    <span class="annotation">@Inject</span>
    <span class="directive">public</span> Order(OrderProcessor processor) { ... }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="defining_qualifier_types"><a class="anchor" href="#defining_qualifier_types"></a>2.3.2. Defining new qualifier types</h4>
<div class="paragraph">
<p>A qualifier type is a Java annotation defined as <code>@Retention(RUNTIME)</code>. Typically a qualifier type is defined as <code>@Target({METHOD, FIELD, PARAMETER, TYPE})</code>.</p>
</div>
<div class="paragraph">
<p>A qualifier type may be declared by specifying the <code>@jakarta.inject.Qualifier</code> meta-annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Qualifier</span>
<span class="annotation">@Retention</span>(RUNTIME)
<span class="annotation">@Target</span>({METHOD, FIELD, PARAMETER, TYPE})
<span class="directive">public</span> <span class="annotation">@interface</span> Synchronous {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Qualifier</span>
<span class="annotation">@Retention</span>(RUNTIME)
<span class="annotation">@Target</span>({METHOD, FIELD, PARAMETER, TYPE})
<span class="directive">public</span> <span class="annotation">@interface</span> Asynchronous {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A qualifier type may define annotation members.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Qualifier</span>
<span class="annotation">@Retention</span>(RUNTIME)
<span class="annotation">@Target</span>({METHOD, FIELD, PARAMETER, TYPE})
<span class="directive">public</span> <span class="annotation">@interface</span> PayBy {
    PaymentMethod value();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="declaring_bean_qualifiers"><a class="anchor" href="#declaring_bean_qualifiers"></a>2.3.3. Declaring the qualifiers of a bean</h4>
<div class="paragraph">
<p>The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@LDAP</span>
<span class="type">class</span> <span class="class">LdapAuthenticator</span>
        <span class="directive">implements</span> <span class="predefined-type">Authenticator</span> {
    ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Shop</span> {

   <span class="annotation">@Produces</span> <span class="annotation">@All</span>
   <span class="directive">public</span> <span class="predefined-type">List</span>&lt;Product&gt; getAllProducts() { ... }

   <span class="annotation">@Produces</span> <span class="annotation">@WishList</span>
   <span class="directive">public</span> <span class="predefined-type">List</span>&lt;Product&gt; getWishList() { ... }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any bean may declare multiple qualifier types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Synchronous</span> <span class="annotation">@Reliable</span>
<span class="type">class</span> <span class="class">SynchronousReliablePaymentProcessor</span>
        <span class="directive">implements</span> PaymentProcessor {
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="injected_field_qualifiers"><a class="anchor" href="#injected_field_qualifiers"></a>2.3.4. Specifying qualifiers of an injected field</h4>
<div class="paragraph">
<p>Qualifier types may be applied to injected fields (see <a href="#injected_fields">Injected fields</a>) to determine the bean that is injected, according to the rules of typesafe resolution defined in <a href="#typesafe_resolution">Typesafe resolution</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@LDAP</span> <span class="predefined-type">Authenticator</span> authenticator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A bean may only be injected to an injection point if it has all the qualifiers of the injection point.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Synchronous</span> <span class="annotation">@Reliable</span> PaymentProcessor paymentProcessor;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@All</span> <span class="predefined-type">List</span>&lt;Product&gt; catalog;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@WishList</span> <span class="predefined-type">List</span>&lt;Product&gt; wishList;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="method_constructor_parameter_qualifiers"><a class="anchor" href="#method_constructor_parameter_qualifiers"></a>2.3.5. Specifying qualifiers of a method or constructor parameter</h4>
<div class="paragraph">
<p>Qualifier types may be applied to parameters of producer methods, initializer methods, disposer methods, observer methods or bean constructors (see <a href="#implementation">Programming model</a>) to determine the bean instance that is passed when the method is called by the container.
The container uses the rules of typesafe resolution defined in <a href="#typesafe_resolution">Typesafe resolution</a> to determine values for these parameters.</p>
</div>
<div class="paragraph">
<p>For example, when the container encounters the following producer method, an instance of <code>SynchronousPaymentProcessor</code> will be passed to the first parameter and an instance of <code>AsynchronousPaymentProcessor</code> will be passed to the second parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span>
PaymentProcessor getPaymentProcessor(<span class="annotation">@Synchronous</span> PaymentProcessor sync,
                                     <span class="annotation">@Asynchronous</span> PaymentProcessor async) {
    <span class="keyword">return</span> isSynchronous() ? sync : async;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repeating_qualifiers"><a class="anchor" href="#repeating_qualifiers"></a>2.3.6. Repeating qualifiers</h4>
<div class="paragraph">
<p>In some cases, it may be useful to have a repeated qualifier for your type safe resolution.  A repeated qualifier behaves just as any other qualifier does.  For example, the below qualifier is a repeatable qualifier</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({ PARAMETER, FIELD, METHOD, TYPE })
<span class="annotation">@Retention</span>(RUNTIME)
<span class="annotation">@Documented</span>
<span class="annotation">@Qualifier</span>
<span class="annotation">@Repeatable</span>(Locations.class)
<span class="directive">public</span> <span class="annotation">@interface</span> Location {
    <span class="predefined-type">String</span> value();
}

<span class="annotation">@Target</span>({ PARAMETER, FIELD, METHOD, TYPE })
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> Locations {
    Location<span class="type">[]</span> value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can define appropriate producers and injection points for repeated qualifiers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span>
<span class="annotation">@Location</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">north</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@Location</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">south</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> Coordinate createCoordinate() {
   <span class="comment">// ...</span>
}

<span class="annotation">@Inject</span>
<span class="annotation">@Location</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">north</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@Location</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">south</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> Coordinate coordinate;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A partial match injection point will still work in this case (from the same producer method)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span>
<span class="annotation">@Location</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">south</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> Coordinate coordinate;</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, adding the follow producer method will continue to give you an ambiguous resolution error (assuming the other producer exists as well)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span>
<span class="annotation">@Location</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">south</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> Coordinate createSouthCoordinate() {
   <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scopes"><a class="anchor" href="#scopes"></a>2.4. Scopes</h3>
<div class="paragraph">
<p>Scoped objects, exist in a well-defined lifecycle context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>they may be automatically created when needed and then automatically destroyed when the context in which they were created ends, and</p>
</li>
<li>
<p>their state is automatically shared by clients that execute in the same context.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All beans have a scope.
The scope of a bean determines the lifecycle of its instances, and which instances of the bean are visible to instances of other beans, as defined in <a href="#contexts">Scopes and contexts</a>.
A scope type is represented by an annotation type.</p>
</div>
<div class="paragraph">
<p>For example, an object that represents the current user is represented by a session scoped object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@SessionScoped</span> User getCurrentUser() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>An object that represents an order is represented by a conversation scoped object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ConversationScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A list that contains the results of a search screen might be represented by a request scoped object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@RequestScoped</span> <span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">orders</span><span class="delimiter">&quot;</span></span>)
<span class="predefined-type">List</span>&lt;Order&gt; getOrderSearchResults() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The set of scope types is extensible.</p>
</div>
<div class="sect3">
<h4 id="builtin_scopes"><a class="anchor" href="#builtin_scopes"></a>2.4.1. Built-in scope types</h4>
<div class="paragraph">
<p>There are five standard scope types defined by this specification, all defined in the package <code>jakarta.enterprise.context</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The container must provide an implementation of the @RequestScoped, @ApplicationScoped and @SessionScoped annotations defined in <a href="#builtin_contexts">Context management for built-in scopes</a>.
Note that these standard scopes can be extended by third-party extensions as defined in <a href="#context">The <code>Context</code> interface</a></p>
</li>
<li>
<p>The <code>@ConversationScoped</code> annotation represents the conversation scope defined in <a href="#conversation_context">Conversation context lifecycle</a>.</p>
</li>
<li>
<p>Finally, there is a <code>@Dependent</code> pseudo-scope for dependent objects, as defined in <a href="#dependent_context">Dependent pseudo-scope</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If an interceptor or decorator has any scope other than <code>@Dependent</code>, non-portable behavior results.</p>
</div>
</div>
<div class="sect3">
<h4 id="defining_new_scope_type"><a class="anchor" href="#defining_new_scope_type"></a>2.4.2. Defining new scope types</h4>
<div class="paragraph">
<p>A scope type is a Java annotation defined as <code>@Retention(RUNTIME)</code>. Typically a scope type is defined as <code>@Target({TYPE, METHOD, FIELD})</code>. All scope types must also specify the <code>@jakarta.inject.Scope</code> or <code>@jakarta.enterprise.context.NormalScope</code> meta-annotation.</p>
</div>
<div class="paragraph">
<p>A scope type must not have any attributes.
If a scope type has attributes non-portable behavior results.</p>
</div>
<div class="paragraph">
<p>For example, the following annotation declares a "business process scope":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inherited</span>
<span class="annotation">@NormalScope</span>
<span class="annotation">@Target</span>({TYPE, METHOD, FIELD})
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> BusinessProcessScoped {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Custom scopes are normally defined by portable extensions, which must also provide a <em>context object</em>, as defined in <a href="#context">The <code>Context</code> interface</a>, that implements the custom scope.</p>
</div>
</div>
<div class="sect3">
<h4 id="declaring_bean_scope"><a class="anchor" href="#declaring_bean_scope"></a>2.4.3. Declaring the bean scope</h4>
<div class="paragraph">
<p>The scope of a bean is defined by annotating the bean class or producer method or field with a scope type.</p>
</div>
<div class="paragraph">
<p>A bean class or producer method or field may specify at most one scope type annotation.
If a bean class or producer method or field specifies multiple scope type annotations, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Shop</span> {

   <span class="annotation">@Produces</span> <span class="annotation">@ApplicationScoped</span> <span class="annotation">@All</span>
   <span class="directive">public</span> <span class="predefined-type">List</span>&lt;Product&gt; getAllProducts() { ... }

   <span class="annotation">@Produces</span> <span class="annotation">@SessionScoped</span> <span class="annotation">@WishList</span>
   <span class="directive">public</span> <span class="predefined-type">List</span>&lt;Product&gt; getWishList() { ..... }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Likewise, a bean with the custom business process scope may be declared by annotating it with the <code>@BusinessProcessScoped</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@BusinessProcessScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, a scope type may be specified using a stereotype annotation, as defined in <a href="#declaring_stereotypes">Declaring the stereotypes for a bean</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="default_scope"><a class="anchor" href="#default_scope"></a>2.4.4. Default scope</h4>
<div class="paragraph">
<p>When no scope is explicitly declared by annotating the bean class or producer method or field the scope of a bean is defaulted.</p>
</div>
<div class="paragraph">
<p>The <em>default scope</em> for a bean which does not explicitly declare a scope depends upon its declared stereotypes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the bean does not declare any stereotype with a declared default scope, the default scope for the bean is <code>@Dependent</code>.</p>
</li>
<li>
<p>If all stereotypes declared by the bean that have some declared default scope have the same default scope, then that scope is the default scope for the bean.</p>
</li>
<li>
<p>If there are two different stereotypes declared by the bean that declare different default scopes, then there is no default scope and the bean must explicitly declare a scope.
If it does not explicitly declare a scope, the container automatically detects the problem and treats it as a definition error.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a bean explicitly declares a scope, any default scopes declared by stereotypes are ignored.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="default_bean_discovery"><a class="anchor" href="#default_bean_discovery"></a>2.5. Default bean discovery mode</h3>
<div class="paragraph">
<p>The default <em>bean discovery mode</em> for a bean archive is <code>annotated</code>, and such a bean archive is said to be an <em>implicit bean archive</em> as defined in <a href="#bean_archive">Bean archives</a>.</p>
</div>
<div class="paragraph">
<p>If the <em>bean discovery mode</em> is <code>annotated</code> then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>bean classes that don&#8217;t have <em>bean defining annotation</em> (as defined in <a href="#bean_defining_annotations">Bean defining annotations</a>) are not discovered, and</p>
</li>
<li>
<p>producer methods (as defined in <a href="#producer_method">Producer methods</a>) whose bean class does not have a <em>bean defining annotation</em> are not discovered, and</p>
</li>
<li>
<p>producer fields (as defined in <a href="#producer_field">Producer fields</a>) whose bean class does not have a <em>bean defining annotation</em> are not discovered, and</p>
</li>
<li>
<p>disposer methods (as defined in <a href="#disposer_method">Disposer methods</a>) whose bean class does not have a <em>bean defining annotation</em> are not discovered, and</p>
</li>
<li>
<p>observer methods (as defined in <a href="#observes">Declaring an observer method</a>) whose bean class does not have a <em>bean defining annotation</em> are not discovered.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="bean_defining_annotations"><a class="anchor" href="#bean_defining_annotations"></a>2.5.1. Bean defining annotations</h4>
<div class="paragraph">
<p>A bean class may have a <em>bean defining annotation</em>, allowing it to be placed anywhere in an application, as defined in <a href="#bean_archive">Bean archives</a>.
A bean class with a <em>bean defining annotation</em> is said to be an <em>implicit bean</em>.</p>
</div>
<div class="paragraph">
<p>The set of bean defining annotations contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@ApplicationScoped</code>, <code>@SessionScoped</code>, <code>@ConversationScoped</code> and <code>@RequestScoped</code> annotations,</p>
</li>
<li>
<p>all other normal scope types,</p>
</li>
<li>
<p><code>@Interceptor</code> and <code>@Decorator</code> annotations,</p>
</li>
<li>
<p>all stereotype annotations (i.e. annotations annotated with <code>@Stereotype</code>),</p>
</li>
<li>
<p>and the <code>@Dependent</code> scope annotation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If one of these annotations is declared on a bean class, then the bean class is said to have a bean defining annotation.
For example, this dependent scoped bean has a bean defining annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Dependent</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">BookShop</span>
        <span class="directive">extends</span> Business
        <span class="directive">implements</span> Shop&lt;<span class="predefined-type">Book</span>&gt; {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>whilst this dependent scoped bean does not have a bean defining annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CoffeeShop</span>
        <span class="directive">extends</span> Business
        <span class="directive">implements</span> Shop&lt;Coffee&gt; {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that to ensure compatibility with other JSR-330 implementations, all pseudo-scope annotations except <code>@Dependent</code> <strong>are not</strong> bean defining annotations.
However, a stereotype annotation including a pseudo-scope annotation <strong>is</strong> a bean defining annotation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="names"><a class="anchor" href="#names"></a>2.6. Bean names</h3>
<div class="paragraph">
<p>A bean may have a <em>bean name</em>.
A bean with a name may be referred to by its name when used in a non typesafe environment (like the Unified Expression Language). A valid bean name is a period-separated list of valid EL identifiers.</p>
</div>
<div class="paragraph">
<p>The following strings are valid bean names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>com.acme.settings</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>orderManager</pre>
</div>
</div>
<div class="paragraph">
<p>Subject to the restrictions defined in <a href="#ambig_names">Ambiguous names</a>, multiple beans may share the same bean name.</p>
</div>
<div class="paragraph">
<p>Bean names are used by the rules of bean name resolution defined in <a href="#name_resolution">Name resolution</a>.</p>
</div>
<div class="sect3">
<h4 id="declaring_bean_name"><a class="anchor" href="#declaring_bean_name"></a>2.6.1. Declaring the bean name</h4>
<div class="paragraph">
<p>To specify the name of a bean, the qualifier <code>@jakarta.inject.Named</code> is applied to the bean class or producer method or field.
This bean is named <code>currentOrder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">currentOrder</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="default_name"><a class="anchor" href="#default_name"></a>2.6.2. Default bean names</h4>
<div class="paragraph">
<p>In the following circumstances, a <em>default name</em> must be assigned by the container:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A bean class or producer method or field of a bean declares a <code>@Named</code> annotation and no bean name is explicitly specified by the <code>value</code> member.</p>
</li>
<li>
<p>A bean declares a stereotype that declares an empty <code>@Named</code> annotation, and the bean does not explicitly specify a bean name.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The default name for a bean depends upon the kind of the bean.
The rules for determining the default name for a bean are defined in <a href="#managed_bean_name">Default bean name for a managed bean</a>, <a href="#producer_method_name">Default bean name for a producer method</a> and <a href="#producer_field_name">Default bean name for a producer field</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans_with_no_name"><a class="anchor" href="#beans_with_no_name"></a>2.6.3. Beans with no name</h4>
<div class="paragraph">
<p>If <code>@Named</code> is not declared by the bean, nor by its stereotypes, a bean has no name.</p>
</div>
<div class="paragraph">
<p>If an interceptor or decorator has a name, non-portable behavior results.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="alternatives"><a class="anchor" href="#alternatives"></a>2.7. Alternatives</h3>
<div class="paragraph">
<p>An <em>alternative</em> is a bean that must be explicitly selected if it should be available for lookup, injection or name resolution.</p>
</div>
<div class="sect3">
<h4 id="declaring_alternative"><a class="anchor" href="#declaring_alternative"></a>2.7.1. Declaring an alternative</h4>
<div class="paragraph">
<p>An alternative may be declared by annotating the bean class or producer method or field with the <code>@Alternative</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Alternative</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockOrder</span> <span class="directive">extends</span> Order { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, an alternative may be declared by annotating a bean, producer method or producer field with a stereotype that declares an <code>@Alternative</code> annotation.</p>
</div>
<div class="paragraph">
<p>If an interceptor or decorator is an alternative, non-portable behavior results.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stereotypes"><a class="anchor" href="#stereotypes"></a>2.8. Stereotypes</h3>
<div class="paragraph">
<p>In many systems, use of architectural patterns produces a set of recurring bean roles.
A <em>stereotype</em> allows a framework developer to identify such a role and declare some common metadata for beans with that role in a central place.</p>
</div>
<div class="paragraph">
<p>A stereotype encapsulates any combination of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a default scope, and</p>
</li>
<li>
<p>a set of interceptor bindings.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A stereotype may also specify that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>all beans with the stereotype have defaulted bean names, or that</p>
</li>
<li>
<p>all beans with the stereotype are alternatives.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A bean may declare zero, one or multiple stereotypes.</p>
</div>
<div class="sect3">
<h4 id="defining_new_stereotype"><a class="anchor" href="#defining_new_stereotype"></a>2.8.1. Defining new stereotypes</h4>
<div class="paragraph">
<p>A bean stereotype is a Java annotation defined as <code>@Retention(RUNTIME)</code>. Typically a bean stereotype is defined as <code>@Target({TYPE, METHOD, FIELD})</code>, <code>@Target(TYPE)</code>, <code>@Target(METHOD)</code>, <code>@Target(FIELD)</code> or <code>@Target({METHOD, FIELD})</code>.</p>
</div>
<div class="paragraph">
<p>A stereotype may be declared by specifying the <code>@jakarta.enterprise.inject.Stereotype</code> meta-annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Stereotype</span>
<span class="annotation">@Target</span>(TYPE)
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> <span class="predefined-type">Action</span> {}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="stereotype_default_scope"><a class="anchor" href="#stereotype_default_scope"></a>2.8.1.1. Declaring the default scope for a stereotype</h5>
<div class="paragraph">
<p>The default scope of a stereotype is defined by annotating the stereotype with a scope type.
A stereotype may declare at most one scope.
If a stereotype declares more than one scope, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>For example, the following stereotype might be used to identify action classes in a web application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RequestScoped</span>
<span class="annotation">@Stereotype</span>
<span class="annotation">@Target</span>(TYPE)
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> <span class="predefined-type">Action</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then actions would have scope <code>@RequestScoped</code> unless the scope is explicitly specified by the bean.</p>
</div>
</div>
<div class="sect4">
<h5 id="specify_stereotype_interceptor_bindings"><a class="anchor" href="#specify_stereotype_interceptor_bindings"></a>2.8.1.2. Specifying interceptor bindings for a stereotype</h5>
<div class="paragraph">
<p>The interceptor bindings of a stereotype are defined by annotating the stereotype with the interceptor binding types.
A stereotype may declare zero, one or multiple interceptor bindings, as defined in <a href="#stereotype_interceptor_bindings">Interceptor bindings for stereotypes</a>.</p>
</div>
<div class="paragraph">
<p>We may specify interceptor bindings that apply to all actions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RequestScoped</span>
<span class="annotation">@Secure</span>
<span class="annotation">@Transactional</span>
<span class="annotation">@Stereotype</span>
<span class="annotation">@Target</span>(TYPE)
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> <span class="predefined-type">Action</span> {}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="named_stereotype"><a class="anchor" href="#named_stereotype"></a>2.8.1.3. Declaring a <code>@Named</code> stereotype</h5>
<div class="paragraph">
<p>A stereotype may declare an empty <code>@Named</code> annotation, which specifies that every bean with the stereotype has a defaulted name when a name is not explicitly specified by the bean.
A <code>@Named</code> qualifier declared by a stereotype is not added to the qualifiers of a bean with the stereotype.</p>
</div>
<div class="paragraph">
<p>If a stereotype declares a non-empty <code>@Named</code> annotation, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>We may specify that all actions have bean names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@RequestScoped</span>
<span class="annotation">@Secure</span>
<span class="annotation">@Transactional</span>
<span class="annotation">@Named</span>
<span class="annotation">@Stereotype</span>
<span class="annotation">@Target</span>(TYPE)
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> <span class="predefined-type">Action</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A stereotype should not declare any qualifier annotation other than <code>@Named</code>. If a stereotype declares any other qualifier annotation, non-portable behavior results.</p>
</div>
<div class="paragraph">
<p>A stereotype should not be annotated <code>@Typed</code>. If a stereotype is annotated <code>@Typed</code>, non-portable behavior results.</p>
</div>
</div>
<div class="sect4">
<h5 id="alternative_stereotype"><a class="anchor" href="#alternative_stereotype"></a>2.8.1.4. Declaring an <code>@Alternative</code> stereotype</h5>
<div class="paragraph">
<p>A stereotype may declare an <code>@Alternative</code> annotation, which specifies that every bean with the stereotype is an alternative.</p>
</div>
<div class="paragraph">
<p>We may specify that all mock objects are alternatives:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Alternative</span>
<span class="annotation">@Stereotype</span>
<span class="annotation">@Target</span>(TYPE)
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> Mock {}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="stereotypes_with_additional_stereotypes"><a class="anchor" href="#stereotypes_with_additional_stereotypes"></a>2.8.1.5. Stereotypes with additional stereotypes</h5>
<div class="paragraph">
<p>A stereotype may declare other stereotypes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Auditable</span>
<span class="annotation">@Action</span>
<span class="annotation">@Stereotype</span>
<span class="annotation">@Target</span>(TYPE)
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> AuditableAction {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stereotype declarations are transitive - a stereotype declared by a second stereotype is inherited by all beans and other stereotypes that declare the second stereotype.</p>
</div>
<div class="paragraph">
<p>Stereotypes declared <code>@Target(TYPE)</code> may not be applied to stereotypes declared <code>@Target({TYPE, METHOD, FIELD})</code>, <code>@Target(METHOD)</code>, <code>@Target(FIELD)</code> or <code>@Target({METHOD, FIELD})</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="declaring_stereotypes"><a class="anchor" href="#declaring_stereotypes"></a>2.8.2. Declaring the stereotypes for a bean</h4>
<div class="paragraph">
<p>Stereotype annotations may be applied to a bean class or producer method or field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Action</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">LoginAction</span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default scope declared by the stereotype may be overridden by the bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Mock</span> <span class="annotation">@ApplicationScoped</span> <span class="annotation">@Action</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockLoginAction</span> <span class="directive">extends</span> LoginAction { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple stereotypes may be applied to the same bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Dao</span> <span class="annotation">@Action</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">LoginAction</span> { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="builtin_stereotypes"><a class="anchor" href="#builtin_stereotypes"></a>2.8.3. Built-in stereotypes</h4>
<div class="paragraph">
<p>The built-in stereotype <code>@jakarta.enterprise.inject.Model</code> is intended for use with beans that define the <em>model</em> layer of an MVC web application architecture such as JSF:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Named</span>
<span class="annotation">@RequestScoped</span>
<span class="annotation">@Stereotype</span>
<span class="annotation">@Target</span>({TYPE, METHOD, FIELD})
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> Model {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, the special-purpose <code>@Interceptor</code> and <code>@Decorator</code> stereotypes are defined in <a href="#declaring_interceptor">Declaring the interceptor bindings of an interceptor</a> and <a href="#decorator_annotation">Declaring a decorator</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="exceptions"><a class="anchor" href="#exceptions"></a>2.9. Problems detected automatically by the container</h3>
<div class="paragraph">
<p>When the application violates a rule defined by this specification, the container automatically detects the problem.
There are three kinds of problem:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Definition errors - occur when a single bean definition violates the rules of this specification.
If a definition error exists, the container must throw a subclass of <code>jakarta.enterprise.inject.spi.DefinitionException</code>.</p>
</li>
<li>
<p>Deployment problems - occur when there are problems resolving dependencies, or inconsistent specialization, in a particular deployment.
If a deployment problem occurs, the container must throw a subclass of <code>jakarta.enterprise.inject.spi.DeploymentException</code>.</p>
</li>
<li>
<p>Exceptions - occur at runtime</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Definition errors are <em>developer errors</em>.
They may be detected by tooling at development time, and are also detected by the container at initialization time.
If a definition error exists in a deployment, initialization will be aborted by the container.</p>
</div>
<div class="paragraph">
<p>Deployment problems are detected by the container at initialization time.
If a deployment problem exists in a deployment, initialization will be aborted by the container.</p>
</div>
<div class="paragraph">
<p>The container is permitted to define a non-portable mode, for use at development time, in which some definition errors and deployment problems do not cause application initialization to abort.</p>
</div>
<div class="paragraph">
<p>Exceptions represent problems that may not be detected until they actually occur at runtime.
All exceptions defined by this specification are unchecked exceptions.
All exceptions defined by this specification may be safely caught and handled by the application.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementation"><a class="anchor" href="#implementation"></a>3. Programming model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The container provides built-in support for injection and contextual lifecycle management of the following kinds of bean:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Managed beans</p>
</li>
<li>
<p>Producer methods and fields</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All containers must support managed beans, producer methods and producer fields.</p>
</div>
<div class="paragraph">
<p>A portable extension may provide other kinds of beans by implementing the interface <code>Bean</code> defined in <a href="#bean">The <code>Bean</code> interface</a>.</p>
</div>
<div class="sect2">
<h3 id="managed_beans"><a class="anchor" href="#managed_beans"></a>3.1. Managed beans</h3>
<div class="paragraph">
<p>A <em>managed bean</em> is a bean that is implemented by a Java class.
This class is called the <em>bean class</em> of the managed bean.
The basic lifecycle and semantics of managed beans are defined by the Managed Beans specification.</p>
</div>
<div class="paragraph">
<p>If the bean class of a managed bean is annotated with both <code>@Interceptor</code> and <code>@Decorator</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a managed bean has a non-static public field, it must have scope <code>@Dependent</code>. If a managed bean with a non-static public field declares any scope other than <code>@Dependent</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If the managed bean class is a generic type, it must have scope <code>@Dependent</code>. If a managed bean with a parameterized bean class declares any scope other than <code>@Dependent</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="sect3">
<h4 id="what_classes_are_beans"><a class="anchor" href="#what_classes_are_beans"></a>3.1.1. Which Java classes are managed beans?</h4>
<div class="paragraph">
<p>A Java class is a managed bean if it meets all of the following conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is not an inner class.</p>
</li>
<li>
<p>It is a non-abstract class, or is annotated <code>@Decorator</code>.</p>
</li>
<li>
<p>It does not implement <code>jakarta.enterprise.inject.spi.Extension</code>.</p>
</li>
<li>
<p>It is not annotated <code>@Vetoed</code> or in a package annotated <code>@Vetoed</code>.</p>
</li>
<li>
<p>It has an appropriate constructor - either:</p>
<div class="ulist">
<ul>
<li>
<p>the class has a constructor with no parameters, or</p>
</li>
<li>
<p>the class declares a constructor annotated <code>@Inject</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>All Java classes that meet these conditions are managed beans and thus no special declaration is required to define a managed bean.</p>
</div>
<div class="paragraph">
<p>If packages annotated <code>@Vetoed</code> are split across classpath entries, non-portable behavior results.
An application can prevent packages being split across jars by sealing the package as defined by the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#sealing">JAR File Specification</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="managed_bean_types"><a class="anchor" href="#managed_bean_types"></a>3.1.2. Bean types of a managed bean</h4>
<div class="paragraph">
<p>The unrestricted set of bean types for a managed bean contains the bean class, every superclass and all interfaces it implements directly or indirectly.</p>
</div>
<div class="paragraph">
<p>The resulting set of bean types for a managed bean consists only of <a href="#legal_bean_types">legal bean types</a>, all other types are removed from the set of bean types.</p>
</div>
<div class="paragraph">
<p>Note the additional restrictions upon bean types of beans with normal scopes defined in <a href="#unproxyable">Unproxyable bean types</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="declaring_managed_bean"><a class="anchor" href="#declaring_managed_bean"></a>3.1.3. Declaring a managed bean</h4>
<div class="paragraph">
<p>A managed bean with a constructor that takes no parameters does not require any special annotations.
The following classes are beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Shop</span> { .. }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">PaymentProcessorImpl</span> <span class="directive">implements</span> PaymentProcessor { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the managed bean does not have a constructor that takes no parameters, it must have a constructor annotated <code>@Inject</code>. No additional special annotations are required.</p>
</div>
<div class="paragraph">
<p>A bean class may specify a scope, bean name, stereotypes and/or qualifiers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ConversationScoped</span> <span class="annotation">@Default</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ShoppingCart</span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A managed bean may extend another managed bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">loginAction</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">LoginAction</span> { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Mock</span>
<span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">loginAction</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockLoginAction</span> <span class="directive">extends</span> LoginAction { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second bean is a "mock object" that overrides the implementation of <code>LoginAction</code> when running in an embedded CDI based integration testing environment.</p>
</div>
</div>
<div class="sect3">
<h4 id="specialize_managed_bean"><a class="anchor" href="#specialize_managed_bean"></a>3.1.4. Specializing a managed bean</h4>
<div class="paragraph">
<p>If a bean class of a managed bean X is annotated <code>@Specializes</code>, then the bean class of X must directly extend the bean class of another managed bean Y.
Then X <em>directly specializes</em> Y, as defined in <a href="#specialization">Specialization</a>.</p>
</div>
<div class="paragraph">
<p>If the bean class of X does not directly extend the bean class of another managed bean, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>For example, <code>MockLoginAction</code> directly specializes <code>LoginAction</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">LoginAction</span> { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Mock</span> <span class="annotation">@Specializes</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockLoginAction</span> <span class="directive">extends</span> LoginAction { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="managed_bean_name"><a class="anchor" href="#managed_bean_name"></a>3.1.5. Default bean name for a managed bean</h4>
<div class="paragraph">
<p>The default name for a managed bean is the unqualified class name of the bean class, after converting the first character to lower case.</p>
</div>
<div class="paragraph">
<p>For example, if the bean class is named <code>ProductList</code>, the default bean name is <code>productList</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producer_method"><a class="anchor" href="#producer_method"></a>3.2. Producer methods</h3>
<div class="paragraph">
<p>A <em>producer method</em> acts as a source of objects to be injected, where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the objects to be injected are not required to be instances of beans, or</p>
</li>
<li>
<p>the concrete type of the objects to be injected may vary at runtime, or</p>
</li>
<li>
<p>the objects require some custom initialization that is not performed by the bean constructor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A producer method must be a default-access, public, protected or private, non-abstract method of a managed bean class.
A producer method may be either static or non-static.</p>
</div>
<div class="paragraph">
<p>If a producer method sometimes returns a null value, then the producer method must have scope <code>@Dependent</code>. If a producer method returns a null value at runtime, and the producer method declares any other scope, an <code>IllegalProductException</code> is thrown by the container.
This restriction allows the container to use a client proxy, as defined in <a href="#client_proxies">Client proxies</a>.</p>
</div>
<div class="paragraph">
<p>If the producer method return type is a parameterized type, it must specify an actual type parameter or type variable for each type parameter.</p>
</div>
<div class="paragraph">
<p>If a producer method return type contains a wildcard type parameter or is an array type whose component type contains a wildcard type parameter, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If the producer method return type is a parameterized type with a type variable, it must have scope <code>@Dependent</code>. If a producer method with a parameterized return type with a type variable declares any scope other than <code>@Dependent</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a producer method return type is a type variable or an array type whose component type is a type variable the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>The application may call producer methods directly.
However, if the application calls a producer method directly, no parameters will be passed to the producer method by the container; the returned object is not bound to any context; and its lifecycle is not managed by the container.</p>
</div>
<div class="paragraph">
<p>A bean may declare multiple producer methods.</p>
</div>
<div class="sect3">
<h4 id="producer_method_types"><a class="anchor" href="#producer_method_types"></a>3.2.1. Bean types of a producer method</h4>
<div class="paragraph">
<p>The bean types of a producer method depend upon the method return type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the return type is an interface, the unrestricted set of bean types contains the return type, all interfaces it extends directly or indirectly and <code>java.lang.Object</code>.</p>
</li>
<li>
<p>If a return type is primitive or is a Java array type, the unrestricted set of bean types contains exactly two types: the method return type and <code>java.lang.Object</code>.</p>
</li>
<li>
<p>If the return type is a class, the unrestricted set of bean types contains the return type, every superclass and all interfaces it implements directly or indirectly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The resulting set of bean types for a producer method consists only of <a href="#legal_bean_types">legal bean types</a>, all other types are removed from the set of bean types.</p>
</div>
<div class="paragraph">
<p>Note the additional restrictions upon bean types of beans with normal scopes defined in <a href="#unproxyable">Unproxyable bean types</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="declaring_producer_method"><a class="anchor" href="#declaring_producer_method"></a>3.2.2. Declaring a producer method</h4>
<div class="paragraph">
<p>A producer method may be declared by annotating a method with the <code>@jakarta.enterprise.inject.Produces</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Shop</span> {
   <span class="annotation">@Produces</span> PaymentProcessor getPaymentProcessor() { ... }
   <span class="annotation">@Produces</span> <span class="predefined-type">List</span>&lt;Product&gt; getProducts() { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A producer method may also specify scope, bean name, stereotypes and/or qualifiers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Shop</span> {
   <span class="annotation">@Produces</span> <span class="annotation">@ApplicationScoped</span> <span class="annotation">@Catalog</span> <span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">catalog</span><span class="delimiter">&quot;</span></span>)
   <span class="predefined-type">List</span>&lt;Product&gt; getProducts() { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a producer method is annotated <code>@Inject</code>, has a parameter annotated <code>@Disposes</code>, has a parameter annotated <code>@Observes</code>, or has a parameter annotated <code>@ObservesAsync</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>Interceptors and decorators may not declare producer methods.
If an interceptor or decorator has a method annotated <code>@Produces</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>A producer method may have any number of parameters.
All producer method parameters are injection points.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">OrderFactory</span> {

   <span class="annotation">@Produces</span> <span class="annotation">@ConversationScoped</span>
   <span class="directive">public</span> Order createCurrentOrder(Shop shop, <span class="annotation">@Selected</span> Product product) {
       Order order = <span class="keyword">new</span> Order(product, shop);
       <span class="keyword">return</span> order;
   }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="specialize_producer_method"><a class="anchor" href="#specialize_producer_method"></a>3.2.3. Specializing a producer method</h4>
<div class="paragraph">
<p>If a producer method X is annotated <code>@Specializes</code>, then it must be non-static and directly override another producer method Y.
Then X <em>directly specializes</em> Y, as defined in <a href="#specialization">Specialization</a>.</p>
</div>
<div class="paragraph">
<p>If the method is static or does not directly override another producer method, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Mock</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockShop</span> <span class="directive">extends</span> Shop {

   <span class="annotation">@Override</span> <span class="annotation">@Specializes</span>
   <span class="annotation">@Produces</span>
   PaymentProcessor getPaymentProcessor() {
      <span class="keyword">return</span> <span class="keyword">new</span> MockPaymentProcessor();
   }

   <span class="annotation">@Override</span> <span class="annotation">@Specializes</span>
   <span class="annotation">@Produces</span>
   <span class="predefined-type">List</span>&lt;Product&gt; getProducts() {
      <span class="keyword">return</span> PRODUCTS;
   }

   ...

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="producer_method_name"><a class="anchor" href="#producer_method_name"></a>3.2.4. Default bean name for a producer method</h4>
<div class="paragraph">
<p>The default name for a producer method is the method name, unless the method follows the JavaBeans property getter naming convention, in which case the default name is the JavaBeans property name.</p>
</div>
<div class="paragraph">
<p>For example, this producer method is named <code>products</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@Named</span>
<span class="directive">public</span> <span class="predefined-type">List</span>&lt;Product&gt; getProducts() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This producer method is named <code>paymentProcessor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@Named</span>
<span class="directive">public</span> PaymentProcessor paymentProcessor() { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producer_field"><a class="anchor" href="#producer_field"></a>3.3. Producer fields</h3>
<div class="paragraph">
<p>A <em>producer field</em> is a slightly simpler alternative to a producer method.</p>
</div>
<div class="paragraph">
<p>A producer field must be a default-access, public, protected or private, field of a managed bean class.
A producer field may be either static or non-static.</p>
</div>
<div class="paragraph">
<p>If a producer field sometimes contains a null value when accessed, then the producer field must have scope <code>@Dependent</code>. If a producer field contains a null value at runtime, and the producer field declares any other scope, an <code>IllegalProductException</code> is thrown by the container.
This restriction allows the container to use a client proxy, as defined in <a href="#client_proxies">Client proxies</a>.</p>
</div>
<div class="paragraph">
<p>If the producer field type is a parameterized type, it must specify an actual type parameter or type variable for each type parameter.</p>
</div>
<div class="paragraph">
<p>If a producer field type contains a wildcard type parameter or is an array type whose component type contains a wildcard parameter, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If the producer field type is a parameterized type with a type variable, it must have scope <code>@Dependent</code>. If a producer field with a parameterized type with a type variable declares any scope other than <code>@Dependent</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a producer field type is a type variable or is an array type whose component type is a type variable the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>The application may access producer fields directly.
However, if the application accesses a producer field directly, the returned object is not bound to any context; and its lifecycle is not managed by the container.</p>
</div>
<div class="paragraph">
<p>A bean may declare multiple producer fields.</p>
</div>
<div class="sect3">
<h4 id="producer_field_types"><a class="anchor" href="#producer_field_types"></a>3.3.1. Bean types of a producer field</h4>
<div class="paragraph">
<p>The bean types of a producer field depend upon the field type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the field type is an interface, the unrestricted set of bean types contains the field type, all interfaces it extends directly or indirectly and <code>java.lang.Object</code>.</p>
</li>
<li>
<p>If a field type is primitive or is a Java array type, the unrestricted set of bean types contains exactly two types: the field type and <code>java.lang.Object</code>.</p>
</li>
<li>
<p>If the field type is a class, the unrestricted set of bean types contains the field type, every superclass and all interfaces it implements directly or indirectly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The resulting set of bean types for a producer field consists only of <a href="#legal_bean_types">legal bean types</a>, all other types are removed from the set of bean types.</p>
</div>
<div class="paragraph">
<p>Note the additional restrictions upon bean types of beans with normal scopes defined in <a href="#unproxyable">Unproxyable bean types</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="declaring_producer_field"><a class="anchor" href="#declaring_producer_field"></a>3.3.2. Declaring a producer field</h4>
<div class="paragraph">
<p>A producer field may be declared by annotating a field with the <code>@jakarta.enterprise.inject.Produces</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Shop</span> {
   <span class="annotation">@Produces</span> PaymentProcessor paymentProcessor = ....;
   <span class="annotation">@Produces</span> <span class="predefined-type">List</span>&lt;Product&gt; products = ....;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A producer field may also specify scope, bean name, stereotypes and/or qualifiers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Shop</span> {
   <span class="annotation">@Produces</span> <span class="annotation">@ApplicationScoped</span> <span class="annotation">@Catalog</span> <span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">catalog</span><span class="delimiter">&quot;</span></span>)
   <span class="predefined-type">List</span>&lt;Product&gt; products = ....;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a producer field is annotated <code>@Inject</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>Interceptors and decorators may not declare producer fields.
If an interceptor or decorator has a field annotated <code>@Produces</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
<div class="sect3">
<h4 id="producer_field_name"><a class="anchor" href="#producer_field_name"></a>3.3.3. Default bean name for a producer field</h4>
<div class="paragraph">
<p>The default name for a producer field is the field name.</p>
</div>
<div class="paragraph">
<p>For example, this producer field is named <code>products</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@Named</span>
<span class="directive">public</span> <span class="predefined-type">List</span>&lt;Product&gt; products = ...;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="disposer_method"><a class="anchor" href="#disposer_method"></a>3.4. Disposer methods</h3>
<div class="paragraph">
<p>A disposer method allows the application to perform customized cleanup of an object returned by a producer method or producer field.</p>
</div>
<div class="paragraph">
<p>A disposer method must be a default-access, public, protected or private, non-abstract method of a managed bean class.
A disposer method may be either static or non-static.</p>
</div>
<div class="paragraph">
<p>A bean may declare multiple disposer methods.</p>
</div>
<div class="sect3">
<h4 id="disposer_method_disposed_parameter"><a class="anchor" href="#disposer_method_disposed_parameter"></a>3.4.1. Disposed parameter of a disposer method</h4>
<div class="paragraph">
<p>Each disposer method must have exactly one <em>disposed parameter</em>, of the same type as the corresponding producer method return type or producer field type.
When searching for disposer methods for a producer method or producer field the container considers the type and qualifiers of the disposed parameter.
If a producer method or producer field declared by the same bean class is assignable to the disposed parameter, according to the rules of typesafe resolution defined in <a href="#typesafe_resolution">Typesafe resolution</a>, the container must call this method when destroying any instance returned by that producer method or producer field.</p>
</div>
<div class="paragraph">
<p>A disposer method may resolve to multiple producer methods or producer fields declared by the bean class, in which case the container must call it when destroying any instance returned by any of these producer methods or producer fields.</p>
</div>
</div>
<div class="sect3">
<h4 id="declaring_disposer_method"><a class="anchor" href="#declaring_disposer_method"></a>3.4.2. Declaring a disposer method</h4>
<div class="paragraph">
<p>A disposer method may be declared by annotating a parameter <code>@jakarta.enterprise.inject.Disposes</code>. That parameter is the disposed parameter.
Qualifiers may be declared by annotating the disposed parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">UserDatabaseEntityManager</span> {

    <span class="annotation">@Produces</span> <span class="annotation">@ConversationScoped</span> <span class="annotation">@UserDatabase</span>
    <span class="directive">public</span> EntityManager create(EntityManagerFactory emf) {
        <span class="keyword">return</span> emf.createEntityManager();
    }

    <span class="directive">public</span> <span class="type">void</span> close(<span class="annotation">@Disposes</span> <span class="annotation">@UserDatabase</span> EntityManager em) {
        em.close();
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Resources</span> {

    <span class="directive">private</span> EntityManagerFactory emf;

    <span class="annotation">@PostConstruct</span>
    <span class="directive">public</span> <span class="type">void</span> setupEntityManagerFactory() {
        emf = Persistence.createEntityManagerFactory(<span class="string"><span class="delimiter">&quot;</span><span class="content">userDatabase</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="annotation">@Produces</span> <span class="annotation">@UserDatabase</span>
    <span class="directive">public</span> EntityManager start() {
        <span class="keyword">return</span> emf.createEntityManager();
    }

    <span class="directive">public</span> <span class="type">void</span> close(<span class="annotation">@Disposes</span> <span class="annotation">@UserDatabase</span> EntityManager em) {
        em.close();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a method has more than one parameter annotated <code>@Disposes</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a disposer method is annotated <code>@Produces</code> or <code>@Inject</code> has a parameter annotated <code>@Observes</code> or has a parameter annotated <code>@ObservesAsync</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>Interceptors and decorators may not declare disposer methods.
If an interceptor or decorator has a method annotated <code>@Disposes</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>In addition to the disposed parameter, a disposer method may declare additional parameters, which may also specify qualifiers.
These additional parameters are injection points.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> close(<span class="annotation">@Disposes</span> <span class="annotation">@UserDatabase</span> EntityManager em, <span class="predefined-type">Logger</span> log) { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="disposer_method_resolution"><a class="anchor" href="#disposer_method_resolution"></a>3.4.3. Disposer method resolution</h4>
<div class="paragraph">
<p>A disposer method is bound to a producer method or producer field if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the producer method or producer field is declared by the same bean class as the disposer method, and</p>
</li>
<li>
<p>the producer method or producer field is assignable to the disposed parameter, according to the rules of typesafe resolution defined in <a href="#typesafe_resolution">Typesafe resolution</a> (using <a href="#assignable_parameters">Assignability of raw and parameterized types</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there are multiple disposer methods for a single producer method or producer field, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If there is no producer method or producer field declared by the bean class that is assignable to the disposed parameter of a disposer method, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bean_constructors"><a class="anchor" href="#bean_constructors"></a>3.5. Bean constructors</h3>
<div class="paragraph">
<p>When the container instantiates a bean class, it calls the <em>bean constructor</em>.
The bean constructor is a default-access, public, protected or private constructor of the bean class.</p>
</div>
<div class="paragraph">
<p>The application may call bean constructors directly.
However, if the application directly instantiates the bean, no parameters are passed to the constructor by the container; the returned object is not bound to any context; no dependencies are injected by the container; and the lifecycle of the new instance is not managed by the container.</p>
</div>
<div class="sect3">
<h4 id="declaring_bean_constructor"><a class="anchor" href="#declaring_bean_constructor"></a>3.5.1. Declaring a bean constructor</h4>
<div class="paragraph">
<p>The bean constructor may be identified by annotating the constructor <code>@Inject</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SessionScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ShoppingCart</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span> {

   <span class="directive">private</span> User customer;

   <span class="annotation">@Inject</span>
   <span class="directive">public</span> ShoppingCart(User customer) {
       <span class="local-variable">this</span>.customer = customer;
   }

   <span class="directive">public</span> ShoppingCart(ShoppingCart original) {
       <span class="local-variable">this</span>.customer = original.customer;
   }

   ShoppingCart() {}

   ...

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ConversationScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> {

   <span class="directive">private</span> Product product;
   <span class="directive">private</span> User customer;

   <span class="annotation">@Inject</span>
   <span class="directive">public</span> Order(<span class="annotation">@Selected</span> Product product, User customer) {
       <span class="local-variable">this</span>.product = product;
       <span class="local-variable">this</span>.customer = customer;
   }

   <span class="directive">public</span> Order(Order original) {
       <span class="local-variable">this</span>.product = original.product;
       <span class="local-variable">this</span>.customer = original.customer;
   }

   Order() {}

   ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a bean class does not explicitly declare a constructor using <code>@Inject</code>, the constructor that accepts no parameters is the bean constructor.</p>
</div>
<div class="paragraph">
<p>If a bean class has more than one constructor annotated <code>@Inject</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a bean constructor has a parameter annotated <code>@Disposes</code>, <code>@Observes</code>, or <code>@ObservesAsync</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>A bean constructor may have any number of parameters.
All parameters of a bean constructor are injection points.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="injected_fields"><a class="anchor" href="#injected_fields"></a>3.6. Injected fields</h3>
<div class="paragraph">
<p>An <em>injected field</em> is a non-static, non-final field of a bean class or of any other classes supporting injection.</p>
</div>
<div class="sect3">
<h4 id="declaring_injected_field"><a class="anchor" href="#declaring_injected_field"></a>3.6.1. Declaring an injected field</h4>
<div class="paragraph">
<p>An injected field may be declared by annotating the field <code>@jakarta.inject.Inject</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ConversationScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> {

   <span class="annotation">@Inject</span> <span class="annotation">@Selected</span> Product product;
   <span class="annotation">@Inject</span> User customer;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an injected field is annotated <code>@Produces</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="initializer_methods"><a class="anchor" href="#initializer_methods"></a>3.7. Initializer methods</h3>
<div class="paragraph">
<p>An <em>initializer method</em> is a default-access, public, protected or private, non-abstract, non-static, non-generic method of a bean class or of any other classes supporting injection.</p>
</div>
<div class="paragraph">
<p>A bean class may declare multiple (or zero) initializer methods.</p>
</div>
<div class="paragraph">
<p>Method interceptors are never called when the container calls an initializer method.</p>
</div>
<div class="paragraph">
<p>The application may call initializer methods directly, but then no parameters will be passed to the method by the container.</p>
</div>
<div class="sect3">
<h4 id="declaring_initializer"><a class="anchor" href="#declaring_initializer"></a>3.7.1. Declaring an initializer method</h4>
<div class="paragraph">
<p>An initializer method may be declared by annotating the method <code>@jakarta.inject.Inject</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ConversationScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> {

   <span class="directive">private</span> Product product;
   <span class="directive">private</span> User customer;

   <span class="annotation">@Inject</span>
   <span class="type">void</span> setProduct(<span class="annotation">@Selected</span> Product product) {
       <span class="local-variable">this</span>.product = product;
   }

   <span class="annotation">@Inject</span>
   <span class="directive">public</span> <span class="type">void</span> setCustomer(User customer) {
       <span class="local-variable">this</span>.customer = customer;
   }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a generic method of a bean is annotated <code>@Inject</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If an initializer method is annotated <code>@Produces</code>, has a parameter annotated <code>@Disposes</code>, has a parameter annotated <code>@Observes</code>, or has a parameter annotated <code>@ObservesAsync</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>An initializer method may have any number of parameters.
All initializer method parameters are injection points.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="injection_point_default_qualifier"><a class="anchor" href="#injection_point_default_qualifier"></a>3.8. The default qualifier at injection points</h3>
<div class="paragraph">
<p>If an injection point declares no qualifier, the injection point has exactly one qualifier, the default qualifier <code>@Default</code>.</p>
</div>
<div class="paragraph">
<p>The following are equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ConversationScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> {

   <span class="directive">private</span> Product product;
   <span class="directive">private</span> User customer;

   <span class="annotation">@Inject</span>
   <span class="directive">public</span> <span class="type">void</span> init(<span class="annotation">@Selected</span> Product product, User customer) {
       <span class="local-variable">this</span>.product = product;
       <span class="local-variable">this</span>.customer = customer;
   }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ConversationScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Order</span> {

   <span class="directive">private</span> Product product;
   <span class="directive">private</span> User customer;

   <span class="annotation">@Inject</span>
   <span class="directive">public</span> <span class="type">void</span> init(<span class="annotation">@Selected</span> Product product, <span class="annotation">@Default</span> User customer) {
       <span class="local-variable">this</span>.product = product;
       <span class="local-variable">this</span>.customer = customer;
   }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following definitions are equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Payment</span> {

   <span class="directive">public</span> Payment(<span class="predefined-type">BigDecimal</span> amount) { ... }

   <span class="annotation">@Inject</span> Payment(Order order) {
      <span class="local-variable">this</span>(order.getAmount();
   }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Payment</span> {

   <span class="directive">public</span> Payment(<span class="predefined-type">BigDecimal</span> amount) { ... }

   <span class="annotation">@Inject</span> Payment(<span class="annotation">@Default</span> Order order) {
      <span class="local-variable">this</span>(order.getAmount();
   }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the following are equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> Order order;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Default</span> Order order;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="named_at_injection_point"><a class="anchor" href="#named_at_injection_point"></a>3.9. The qualifier <code>@Named</code> at injection points</h3>
<div class="paragraph">
<p>The use of <code>@Named</code> as an injection point qualifier is not recommended, except in the case of integration with legacy code that uses string-based names to identify beans.</p>
</div>
<div class="paragraph">
<p>If an injected field declares a <code>@Named</code> annotation that does not specify the <code>value</code> member, the name of the field is assumed.
For example, the following field has the qualifier <code>@Named("paymentService")</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Named</span> PaymentService paymentService;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any other injection point declares a <code>@Named</code> annotation that does not specify the <code>value</code> member, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
<div class="sect2">
<h3 id="new"><a class="anchor" href="#new"></a>3.10. <code>@New</code> qualified beans</h3>
<div class="paragraph">
<p><em>The @New qualifier was deprecated in CDI 1.1.
CDI applications are encouraged to inject @Dependent scoped beans instead.</em></p>
</div>
<div class="paragraph">
<p>For each managed bean, a second bean exists which:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>has the same bean class,</p>
</li>
<li>
<p>has the same bean types,</p>
</li>
<li>
<p>has the same bean constructor, initializer methods and injected fields, and</p>
</li>
<li>
<p>has the same interceptor bindings.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, this second bean:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>has scope <code>@Dependent</code>,</p>
</li>
<li>
<p>has exactly one qualifier: <code>@jakarta.enterprise.inject.New(X.class)</code> where <code>X</code> is the bean class,</p>
</li>
<li>
<p>has no bean name,</p>
</li>
<li>
<p>has no stereotypes,</p>
</li>
<li>
<p>has no observer methods, producer methods or fields or disposer methods, and</p>
</li>
<li>
<p>is not an alternative, and</p>
</li>
<li>
<p>is enabled, in the sense of <a href="#enablement">Enabled and disabled beans</a>, if and only if some other enabled bean has an injection point with the qualifier <code>@New(X.class)</code> where <code>X</code> is the bean class.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This bean is called the <em>@New qualified bean</em> for the class <code>X</code>.</p>
</div>
<div class="paragraph">
<p>Note that this second bean exists - and may be enabled and available for injection - even if the first bean is disabled, as defined by <a href="#enablement">Enabled and disabled beans</a>, or if the bean class is deployed outside of a bean archive, as defined in <a href="#bean_archive">Bean archives</a>, and is therefore not discovered during the bean discovery process defined in <a href="#packaging_deployment">Packaging and deployment</a>.
The container discovers <code>@New</code> qualified beans by inspecting injection points of other enabled beans.</p>
</div>
<div class="paragraph">
<p>This allows the application to obtain a new instance of a bean which is not bound to the declared scope, but has had dependency injection performed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@ConversationScoped</span>
<span class="annotation">@Special</span> Order getSpecialOrder(<span class="annotation">@New</span>(Order.class) Order order) {
    ...
    return order;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the qualifier <code>@New</code> is specified at an injection point and no <code>value</code> member is explicitly specified, the container defaults the <code>value</code> to the declared type of the injection point.
So the following injection point has qualifier <code>@New(Order.class)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@ConversationScoped</span>
<span class="annotation">@Special</span> Order getSpecialOrder(<span class="annotation">@New</span> Order order) { ... }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unproxyable"><a class="anchor" href="#unproxyable"></a>3.11. Unproxyable bean types</h3>
<div class="paragraph">
<p>The container uses proxies to provide certain functionality.
Certain legal bean types cannot be proxied by the container:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>classes which don&#8217;t have a non-private constructor with no parameters,</p>
</li>
<li>
<p>classes which are declared final,</p>
</li>
<li>
<p>classes which have non-static, final methods with public, protected or default visibility,</p>
</li>
<li>
<p>primitive types,</p>
</li>
<li>
<p>and array types.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A bean type must be proxyable if an injection point resolves to a bean:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>that requires a client proxy, or</p>
</li>
<li>
<p>that has an associated decorator, or</p>
</li>
<li>
<p>that has a bound interceptor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Otherwise, the container automatically detects the problem, and treats it as a deployment problem.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="inheritance"><a class="anchor" href="#inheritance"></a>4. Inheritance and specialization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A bean may inherit type-level metadata and members from its superclasses.</p>
</div>
<div class="paragraph">
<p>Inheritance of type-level metadata by beans from their superclasses is controlled via use of the Java <code>@Inherited</code> meta-annotation.
Type-level metadata is never inherited from interfaces implemented by a bean.</p>
</div>
<div class="paragraph">
<p>Member-level metadata is not inherited.
However, injected fields, initializer methods, lifecycle callback methods and non-static observer methods are inherited by beans from their superclasses.</p>
</div>
<div class="paragraph">
<p>The implementation of a bean may be extended by the implementation of a second bean.
This specification recognizes two distinct scenarios in which this situation occurs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The second bean <em>specializes</em> the first bean in certain deployment scenarios.
In these deployments, the second bean completely replaces the first, fulfilling the same role in the system.</p>
</li>
<li>
<p>The second bean is simply reusing the Java implementation, and otherwise bears no relation to the first bean.
The first bean may not even have been designed for use as a contextual object.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The two cases are quite dissimilar.</p>
</div>
<div class="paragraph">
<p>By default, Java implementation reuse is assumed.
In this case, the two beans have different roles in the system, and may both be available in a particular deployment.</p>
</div>
<div class="paragraph">
<p>The bean developer may explicitly specify that the second bean specializes the first.
Then the second bean inherits, and may not override, the qualifiers and bean name of the first bean.
The second bean is able to serve the same role in the system as the first.
In a particular deployment, only one of the two beans may fulfill that role.</p>
</div>
<div class="sect2">
<h3 id="type_level_inheritance"><a class="anchor" href="#type_level_inheritance"></a>4.1. Inheritance of type-level metadata</h3>
<div class="paragraph">
<p>Suppose a class X is extended directly or indirectly by the bean class of a managed bean Y.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If X is annotated with a qualifier type, stereotype or interceptor binding type Z then Y inherits the annotation if and only if Z declares the <code>@Inherited</code> meta-annotation and neither Y nor any intermediate class that is a subclass of X and a superclass of Y declares an annotation of type Z.
(This behavior is defined by the Java Language Specification.)</p>
</li>
<li>
<p>If X is annotated with a scope type Z then Y inherits the annotation if and only if Z declares the <code>@Inherited</code> meta-annotation and neither Y nor any intermediate class that is a subclass of X and a superclass of Y declares a scope type.
(This behavior is different to what is defined in the Java Language Specification.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A scope type explicitly declared by X and inherited by Y from X takes precedence over default scopes of stereotypes declared or inherited by Y.</p>
</div>
<div class="paragraph">
<p>For annotations defined by the application or third-party extensions, it is recommended that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>scope types should be declared <code>@Inherited</code>,</p>
</li>
<li>
<p>qualifier types should not be declared <code>@Inherited</code>,</p>
</li>
<li>
<p>interceptor binding types should be declared <code>@Inherited</code>, and</p>
</li>
<li>
<p>stereotypes may be declared <code>@Inherited</code>, depending upon the semantics of the stereotype.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All scope types, qualifier types, and interceptor binding types defined by this specification adhere to these recommendations.</p>
</div>
<div class="paragraph">
<p>The stereotypes defined by this specification are not declared <code>@Inherited</code>.</p>
</div>
<div class="paragraph">
<p>However, in special circumstances, these recommendations may be ignored.</p>
</div>
<div class="paragraph">
<p>Note that the <code>@Named</code> annotation is not declared <code>@Inherited</code> and bean names are not inherited unless specialization is used.</p>
</div>
</div>
<div class="sect2">
<h3 id="member_level_inheritance"><a class="anchor" href="#member_level_inheritance"></a>4.2. Inheritance of member-level metadata</h3>
<div class="paragraph">
<p>Suppose a class X is extended directly or indirectly by the bean class of a managed bean Y.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If X declares an injected field <code>x</code> then Y inherits <code>x</code>.
(This behavior is defined by the Common Annotations for the Java Platform specification.)</p>
</li>
<li>
<p>If X declares an initializer, non-static observer, <code>@PostConstruct</code> or <code>@PreDestroy</code> method <code>x()</code> then Y inherits <code>x()</code> if and only if neither Y nor any intermediate class that is a subclass of X and a superclass of Y overrides the method <code>x()</code>.
(This behavior is defined by the Common Annotations for the Java Platform specification.)</p>
</li>
<li>
<p>If X declares a non-static method <code>x()</code> annotated with an interceptor binding type Z then Y inherits the binding if and only if neither Y nor any intermediate class that is a subclass of X and a superclass of Y overrides the method <code>x()</code>.
(This behavior is defined by the Common Annotations for the Java Platform specification.)</p>
</li>
<li>
<p>If X declares a non-static producer or disposer method <code>x()</code> then Y does not inherit this method.
(This behavior is different to what is defined in the Common Annotations for the Java Platform specification.)</p>
</li>
<li>
<p>If X declares a non-static producer field <code>x</code> then Y does not inherit this field.
(This behavior is different to what is defined in the Common Annotations for the Java Platform specification.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If X is a generic type, and an injection point or observer method declared by X is inherited by Y, and the declared type of the injection point or event parameter contains type variables declared by X, the type of the injection point or event parameter inherited in Y is the declared type, after substitution of actual type arguments declared by Y or any intermediate class that is a subclass of X and a superclass of Y.</p>
</div>
<div class="paragraph">
<p>For example, the bean <code>DaoClient</code> has an injection point of type <code>Dao&lt;T&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DaoClient</span>&lt;T&gt; {

    <span class="annotation">@Inject</span> Dao&lt;T&gt; dao;
    ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This injection point is inherited by <code>UserDaoClient</code>, but the type of the inherited injection point is <code>Dao&lt;User&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">UserDaoClient</span>
        <span class="directive">extends</span> DaoClient&lt;User&gt; { ... }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="specialization"><a class="anchor" href="#specialization"></a>4.3. Specialization</h3>
<div class="paragraph">
<p>If two beans both support a certain bean type, and share at least one qualifier, then they are both eligible for injection to any injection point with that declared type and qualifier.</p>
</div>
<div class="paragraph">
<p>Consider the following beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Default</span> <span class="annotation">@Asynchronous</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AsynchronousService</span> <span class="directive">implements</span> Service {
    ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Alternative</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockAsynchronousService</span> <span class="directive">extends</span> AsynchronousService {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Suppose that the <code>MockAsynchronousService</code> alternative is selected, as defined in <a href="#selection">Modularity</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Alternative</span> <span class="annotation">@Priority</span>(jakarta.interceptor.Interceptor.Priority.APPLICATION+<span class="integer">100</span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockAsynchronousService</span> <span class="directive">extends</span> AsynchronousService {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, according to the rules of <a href="#unsatisfied_and_ambig_dependencies">Unsatisfied and ambiguous dependencies</a>, the following ambiguous dependency is resolvable, and so the attribute will receive an instance of <code>MockAsynchronousService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> Service service;</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the following attribute will receive an instance of <code>AsynchronousService</code>, even though <code>MockAsynchronousService</code> is a selected alternative, because <code>MockAsynchronousService</code> does not have the qualifier <code>@Asynchronous</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Asynchronous</span> Service service;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a useful behavior in some circumstances, however, it is not always what is intended by the developer.</p>
</div>
<div class="paragraph">
<p>The only way one bean can completely override a second bean at all injection points is if it implements all the bean types and declares all the qualifiers of the second bean.
However, if the second bean declares a producer method or observer method, then even this is not enough to ensure that the second bean is never called!</p>
</div>
<div class="paragraph">
<p>To help prevent developer error, the first bean may:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>directly extend the bean class of the second bean, or</p>
</li>
<li>
<p>directly override the producer method, in the case that the second bean is a producer method, and then</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>explicitly declare that it <em>specializes</em> the second bean.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Specializes</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockAsynchronousService</span> <span class="directive">extends</span> AsynchronousService {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When an enabled bean, as defined in <a href="#enablement">Enabled and disabled beans</a>, specializes a second bean, we can be certain that the second bean is never instantiated or called by the container.
Even if the second bean defines a producer or observer method, the method will never be called.</p>
</div>
<div class="sect3">
<h4 id="direct_and_indirect_specialization"><a class="anchor" href="#direct_and_indirect_specialization"></a>4.3.1. Direct and indirect specialization</h4>
<div class="paragraph">
<p>The annotation <code>@jakarta.enterprise.inject.Specializes</code> is used to indicate that one bean <em>directly specializes</em> another bean, as defined in <a href="#specialize_managed_bean">Specializing a managed bean</a> and <a href="#specialize_producer_method">Specializing a producer method</a>.</p>
</div>
<div class="paragraph">
<p>Formally, a bean X is said to <em>specialize</em> another bean Y if there is either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>direct specialization, where X directly specializes Y, or</p>
</li>
<li>
<p>transitive specialization, where a bean Z exists, such that X directly specializes Z and Z specializes Y.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Then X will inherit the qualifiers and bean name of Y:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the qualifiers of X include all qualifiers of Y, together with all qualifiers declared explicitly by X, and</p>
</li>
<li>
<p>if Y has a bean name, the bean name of X is the same as the bean name of Y.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Furthermore, X must have all the bean types of Y.
If X does not have some bean type of Y, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If Y has a bean name and X declares a bean name explicitly the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>For example, the following bean would have the inherited qualifiers <code>@Default</code> and <code>@Asynchronous</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Mock</span> <span class="annotation">@Specializes</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockAsynchronousService</span> <span class="directive">extends</span> AsynchronousService {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>AsynchronousService</code> declared a bean name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Default</span> <span class="annotation">@Asynchronous</span> <span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">asyncService</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AsynchronousService</span> <span class="directive">implements</span> Service{
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the bean name would also automatically be inherited by <code>MockAsynchronousService</code>.</p>
</div>
<div class="paragraph">
<p>If an interceptor or decorator is annotated <code>@Specializes</code>, non-portable behavior results.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="injection_and_resolution"><a class="anchor" href="#injection_and_resolution"></a>5. Dependency injection and lookup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The container injects references to contextual instances to the following kinds of <em>injection point</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any injected field of a bean class</p>
</li>
<li>
<p>Any parameter of a bean constructor, bean initializer method, producer method or disposer method</p>
</li>
<li>
<p>Any parameter of an observer method, except for the event parameter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>References to contextual instances may also be obtained by programmatic lookup.</p>
</div>
<div class="paragraph">
<p>In general, a bean type or bean name does not uniquely identify a bean.
When resolving a bean at an injection point, the container considers bean type, qualifiers and selected alternatives.
This allows bean developers to decouple type from implementation.</p>
</div>
<div class="paragraph">
<p>The container is required to support circularities in the bean dependency graph where at least one bean participating in every circular chain of dependencies has a normal scope, as defined in <a href="#normal_scope">Normal scopes and pseudo-scopes</a>.
The container is not required to support circular chains of dependencies where every bean participating in the chain has a pseudo-scope.</p>
</div>
<div class="sect2">
<h3 id="selection"><a class="anchor" href="#selection"></a>5.1. Modularity</h3>
<div class="paragraph">
<p>Beans and their clients may be deployed in <em>modules</em> in a module architecture.
In a module architecture, certain modules are considered <em>bean archives</em>.
The library may be an explicit bean archive or an implicit bean archive, as defined in <a href="#bean_archive">Bean archives</a>.</p>
</div>
<div class="paragraph">
<p>A bean packaged in a certain module is available for injection, lookup and name resolution to classes packaged in some other module if and only if the bean class of the bean is required to be <em>accessible</em> to the other module by the class accessibility requirements of the module architecture.</p>
</div>
<div class="paragraph">
<p>An alternative is not available for injection, lookup or name resolution to classes in a module unless the module is a bean archive and the alternative is explicitly <em>selected</em> for the bean archive or the application.</p>
</div>
<div class="sect3">
<h4 id="declaring_selected_alternatives"><a class="anchor" href="#declaring_selected_alternatives"></a>5.1.1. Declaring selected alternatives</h4>
<div class="paragraph">
<p>This specification defines two methods of selecting alternatives.
From Contexts and Dependency Injection 1.1 onwards the <code>@Priority</code> annotation allows an alternative to be selected for an entire application.
Contexts and Dependency Injection 1.0 allowed only for an alternative to be selected for a bean archive.</p>
</div>
<div class="sect4">
<h5 id="declaring_selected_alternatives_application"><a class="anchor" href="#declaring_selected_alternatives_application"></a>5.1.1.1. Declaring selected alternatives for an application</h5>
<div class="paragraph">
<p>An alternative may be given a priority for the application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by placing the <code>@Priority</code> annotation on the bean class of a managed bean, or</p>
</li>
<li>
<p>by placing the <code>@Priority</code> annotation on the bean class that declares the producer method, field or resource.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Custom bean implementations which are also alternatives may implement <a href="#prioritized">Prioritized interface</a> in which case they will be enabled for entire application with given priority.</p>
</div>
</div>
<div class="sect4">
<h5 id="declaring_selected_alternatives_bean_archive"><a class="anchor" href="#declaring_selected_alternatives_bean_archive"></a>5.1.1.2. Declaring selected alternatives for a bean archive</h5>
<div class="paragraph">
<p>An alternative may be explicitly declared using the <code>&lt;alternatives&gt;</code> element of the <code>beans.xml</code> file of the bean archive.
The <code>&lt;alternatives&gt;</code> element contains a list of bean classes and stereotypes.
An alternative is selected for the bean archive if either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the alternative is a managed bean and the bean class of the bean is listed,</p>
</li>
<li>
<p>the alternative is a producer method, field or resource, and the bean class that declares the method or field is listed, or</p>
</li>
<li>
<p>any <code>@Alternative</code> stereotype of the alternative is listed.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_3_0.xsd</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">version</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
   <span class="tag">&lt;alternatives&gt;</span>
      <span class="tag">&lt;class&gt;</span>com.acme.myfwk.InMemoryDatabase<span class="tag">&lt;/class&gt;</span>
      <span class="tag">&lt;stereotype&gt;</span>com.acme.myfwk.Mock<span class="tag">&lt;/stereotype&gt;</span>
      <span class="tag">&lt;stereotype&gt;</span>com.acme.site.Australian<span class="tag">&lt;/stereotype&gt;</span>
   <span class="tag">&lt;/alternatives&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For each child <code>&lt;class&gt;</code> element the container verifies that either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a class with the specified name exists and is annotated with <code>@Alternative</code> or an <a href="#alternative_stereotype"><code>@Alternative</code> stereotype</a>, or</p>
</li>
<li>
<p>a class with the specified name exists and declares a field or method annotated with <code>@Produces</code> and, at the same time, annotated with <code>@Alternative</code> or an <a href="#alternative_stereotype"><code>@Alternative</code> stereotype</a>, or</p>
</li>
<li>
<p>an alternative bean whose bean class has the specified name exists.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Otherwise, the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>Each child <code>&lt;stereotype&gt;</code> element must specify the name of an <code>@Alternative</code> stereotype annotation.
If there is no annotation with the specified name, or the annotation is not an <code>@Alternative</code> stereotype, the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>If the same type is listed twice under the <code>&lt;alternatives&gt;</code> element, the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>Bean</code> interface defined in <a href="#bean">The <code>Bean</code> interface</a>, the container calls <code>isAlternative()</code> to determine whether the bean is an alternative, and <code>getBeanClass()</code> and <code>getStereotypes()</code> to determine whether an alternative is selected in a certain bean archive.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="enablement"><a class="anchor" href="#enablement"></a>5.1.2. Enabled and disabled beans</h4>
<div class="paragraph">
<p>A bean is said to be <em>enabled</em> if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is deployed in a bean archive, and</p>
</li>
<li>
<p>it is not a producer method or field of a disabled bean, and</p>
</li>
<li>
<p>it is not specialized by any other enabled bean, as defined in <a href="#specialization">Specialization</a>, and either</p>
</li>
<li>
<p>it is not an alternative, or it is a selected alternative of at least one bean archive or the application.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Otherwise, the bean is said to be disabled.</p>
</div>
<div class="paragraph">
<p>Note that <a href="#new"><code>@New</code> qualified beans</a> defines a special rule that determines whether a <code>@New</code> qualified bean is enabled or disabled.
This rule applies as only to <code>@New</code> qualified beans, as an exception to the normal rule defined here.</p>
</div>
</div>
<div class="sect3">
<h4 id="inconsistent_specialization"><a class="anchor" href="#inconsistent_specialization"></a>5.1.3. Inconsistent specialization</h4>
<div class="paragraph">
<p>Suppose an enabled bean X specializes a second bean Y.
If there is another enabled bean that specializes Y we say that <em>inconsistent specialization</em> exists.
The container automatically detects inconsistent specialization and treats it as a deployment problem.</p>
</div>
</div>
<div class="sect3">
<h4 id="inter_module_injection"><a class="anchor" href="#inter_module_injection"></a>5.1.4. Inter-module injection</h4>
<div class="paragraph">
<p>A bean is <em>available for injection</em> in a certain module if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the bean is not an interceptor or decorator,</p>
</li>
<li>
<p>the bean is enabled,</p>
</li>
<li>
<p>the bean is either not an alternative, or the module is a bean archive and the bean is a selected alternative of the bean archive, or the bean is a selected alternative of the application,  and</p>
</li>
<li>
<p>the bean class is required to be accessible to classes in the module, according to the class accessibility requirements of the module architecture.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>Bean</code> interface defined in <a href="#bean">The <code>Bean</code> interface</a>, the container calls <code>getBeanClass()</code> to determine the bean class of the bean and <code>InjectionPoint.getMember()</code> and then <code>Member.getDeclaringClass()</code> to determine the class that declares an injection point.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="typesafe_resolution"><a class="anchor" href="#typesafe_resolution"></a>5.2. Typesafe resolution</h3>
<div class="paragraph">
<p>The process of matching a bean to an injection point is called <em>typesafe resolution</em>.
Typesafe resolution usually occurs at application initialization time, allowing the container to warn the user if any enabled beans have unsatisfied or unresolvable ambiguous dependencies.</p>
</div>
<div class="sect3">
<h4 id="performing_typesafe_resolution"><a class="anchor" href="#performing_typesafe_resolution"></a>5.2.1. Performing typesafe resolution</h4>
<div class="paragraph">
<p>The container considers bean type and qualifiers when resolving a bean to be injected to an injection point.
The type and qualifiers of the injection point are called the <em>required type</em> and <em>required qualifiers</em>.</p>
</div>
<div class="paragraph">
<p>A bean is <em>assignable</em> to a given injection point if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The bean has a bean type that matches the required type.
For this purpose, primitive types are considered to match their corresponding wrapper types in <code>java.lang</code> and array types are considered to match only if their element types are identical.
Parameterized and raw types are considered to match if they are identical or if the bean type is <em>assignable</em> to the required type, as defined in <a href="#assignable_parameters">Assignability of raw and parameterized types</a> or <a href="#delegate_assignable_parameters">Assignability of raw and parameterized types for delegate injection points</a>.</p>
</li>
<li>
<p>The bean has all the required qualifiers.
If no required qualifiers were explicitly specified, the container assumes the required qualifier <code>@Default</code>. A bean has a required qualifier if it has a qualifier with (a) the same type and (b) the same annotation member value for each member which is not annotated <code>@jakarta.enterprise.util.Nonbinding</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A bean is eligible for injection to a certain injection point if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it is available for injection in the module that contains the class that declares the injection point, and</p>
</li>
<li>
<p>it is assignable to the injection point (using <a href="#assignable_parameters">Assignability of raw and parameterized types</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>Bean</code> interface defined in <a href="#bean">The <code>Bean</code> interface</a>, the container calls <code>getTypes()</code> and <code>getQualifiers()</code> to determine the bean types and qualifiers.</p>
</div>
</div>
<div class="sect3">
<h4 id="unsatisfied_and_ambig_dependencies"><a class="anchor" href="#unsatisfied_and_ambig_dependencies"></a>5.2.2. Unsatisfied and ambiguous dependencies</h4>
<div class="paragraph">
<p>An <em>unsatisfied dependency</em> exists at an injection point when no bean is eligible for injection to the injection point.
An <em>ambiguous dependency</em> exists at an injection point when multiple beans are eligible for injection to the injection point.</p>
</div>
<div class="paragraph">
<p>Note that an unsatisfied or ambiguous dependency cannot exist for a decorator delegate injection point, defined in <a href="#delegate_attribute">Decorator delegate injection points</a>.</p>
</div>
<div class="paragraph">
<p>When an ambiguous dependency exists, the container attempts to resolve the ambiguity.
The container eliminates all eligible beans that are not alternatives, except for producer methods and fields of beans that are alternatives.
If:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>there is exactly one bean remaining, the container will select this bean, and the ambiguous dependency is called resolvable.</p>
</li>
<li>
<p>all the beans left are alternatives with a priority, or producer methods or fields of beans that are alternatives with a priority, then the container will determine the highest priority value, and eliminate all beans, except for alternatives with the highest priority and producer methods and fields of alternatives with the highest priority value.
If there is exactly one bean remaining, the container will select this bean, and the ambiguous dependency is called resolvable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container must validate all injection points of all enabled beans, all observer methods and all disposer methods when the application is initialized to ensure that there are no unsatisfied or unresolvable ambiguous dependencies.
If an unsatisfied or unresolvable ambiguous dependency exists, the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>Bean</code> interface defined in <a href="#bean">The <code>Bean</code> interface</a>, the container calls <code>getInjectionPoints()</code> to determine the set of injection points.</p>
</div>
</div>
<div class="sect3">
<h4 id="legal_injection_point_types"><a class="anchor" href="#legal_injection_point_types"></a>5.2.3. Legal injection point types</h4>
<div class="paragraph">
<p>Any legal bean type, as defined in <a href="#legal_bean_types">Legal bean types</a> may be the required type of an injection point.
Furthermore, the required type of an injection point may contain a wildcard type parameter.
However, a type variable is not a legal injection point type.</p>
</div>
<div class="paragraph">
<p>If an injection point type is a type variable, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
<div class="sect3">
<h4 id="assignable_parameters"><a class="anchor" href="#assignable_parameters"></a>5.2.4. Assignability of raw and parameterized types</h4>
<div class="paragraph">
<p>A parameterized bean type is considered assignable to a raw required type if the raw types are identical and all type parameters of the bean type are either unbounded type variables or <code>java.lang.Object</code>.</p>
</div>
<div class="paragraph">
<p>A parameterized bean type is considered assignable to a parameterized required type if they have identical raw type and for each parameter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the required type parameter and the bean type parameter are actual types with identical raw type, and, if the type is parameterized, the bean type parameter is assignable to the required type parameter according to these rules, or</p>
</li>
<li>
<p>the required type parameter is a wildcard, the bean type parameter is an actual type and the actual type is assignable to the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or</p>
</li>
<li>
<p>the required type parameter is a wildcard, the bean type parameter is a type variable and the upper bound of the type variable is assignable to or assignable from the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or</p>
</li>
<li>
<p>the required type parameter is an actual type, the bean type parameter is a type variable and the actual type is assignable to the upper bound, if any, of the type variable, or</p>
</li>
<li>
<p>the required type parameter and the bean type parameter are both type variables and the upper bound of the required type parameter is assignable to the upper bound, if any, of the bean type parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, <code>Dao</code> is eligible for injection to any injection point of type <code>@Default Dao&lt;Order&gt;</code>, <code>@Default Dao&lt;User&gt;</code>, <code>@Default Dao&lt;?&gt;</code>, <code>@Default Dao&lt;? extends Persistent&gt;</code> or <code>@Default Dao&lt;X extends Persistent&gt;</code> where <code>X</code> is a type variable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Dao</span>&lt;T <span class="directive">extends</span> Persistent&gt; { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore, <code>UserDao</code> is eligible for injection to any injection point of type <code>@Default Dao&lt;User&gt;</code>, <code>@Default Dao&lt;?&gt;</code>, <code>@Default Dao&lt;? extends Persistent&gt;</code> or <code>@Default Dao&lt;? extends User&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">UserDao</span> <span class="directive">extends</span> Dao&lt;User&gt; { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A raw bean type is considered assignable to a parameterized required type if the raw types are identical and all type parameters of the required type are either unbounded type variables or java.lang.Object.</p>
</div>
<div class="paragraph">
<p>Note that a special set of rules, defined in <a href="#delegate_assignable_parameters">Assignability of raw and parameterized types for delegate injection points</a>, apply if and only if the injection point is a decorator delegate injection point.</p>
</div>
</div>
<div class="sect3">
<h4 id="primitive_types_and_null_values"><a class="anchor" href="#primitive_types_and_null_values"></a>5.2.5. Primitive types and null values</h4>
<div class="paragraph">
<p>For the purposes of typesafe resolution and dependency injection, primitive types and their corresponding wrapper types in the package <code>java.lang</code> are considered identical and assignable.
If necessary, the container performs boxing or unboxing when it injects a value to a field or parameter of primitive or wrapper type.</p>
</div>
<div class="paragraph">
<p>If an injection point of primitive type resolves to a producer method or producer field that returns a null value at runtime, the container must inject the primitive type&#8217;s default value as defined by the Java Language Specification.</p>
</div>
</div>
<div class="sect3">
<h4 id="qualifier_annotation_members"><a class="anchor" href="#qualifier_annotation_members"></a>5.2.6. Qualifier annotations with members</h4>
<div class="paragraph">
<p>Qualifier types may have annotation members.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PayBy</span>(CHEQUE) <span class="type">class</span> <span class="class">ChequePaymentProcessor</span> <span class="directive">implements</span> PaymentProcessor { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@PayBy</span>(CREDIT_CARD) <span class="type">class</span> <span class="class">CreditCardPaymentProcessor</span> <span class="directive">implements</span> PaymentProcessor { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then only <code>ChequePaymentProcessor</code> is a candidate for injection to the following attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@PayBy</span>(CHEQUE) PaymentProcessor paymentProcessor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand, only <code>CreditCardPaymentProcessor</code> is a candidate for injection to this attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@PayBy</span>(CREDIT_CARD) PaymentProcessor paymentProcessor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The container calls the <code>equals()</code> method of the annotation member value to compare values.</p>
</div>
<div class="paragraph">
<p>An annotation member may be excluded from consideration using the <code>@Nonbinding</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Qualifier</span>
<span class="annotation">@Retention</span>(RUNTIME)
<span class="annotation">@Target</span>({METHOD, FIELD, PARAMETER, TYPE})
<span class="directive">public</span> <span class="annotation">@interface</span> PayBy {
    PaymentMethod value();
    <span class="annotation">@Nonbinding</span> <span class="predefined-type">String</span> comment() <span class="keyword">default</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Array-valued or annotation-valued members of a qualifier type should be annotated <code>@Nonbinding</code> in a portable application.
If an array-valued or annotation-valued member of a qualifier type is not annotated <code>@Nonbinding</code>, non-portable behavior results.</p>
</div>
</div>
<div class="sect3">
<h4 id="multiple_qualifiers"><a class="anchor" href="#multiple_qualifiers"></a>5.2.7. Multiple qualifiers</h4>
<div class="paragraph">
<p>A bean class or producer method or field may declare multiple qualifiers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Synchronous</span> <span class="annotation">@PayBy</span>(CHEQUE) <span class="type">class</span> <span class="class">ChequePaymentProcessor</span> <span class="directive">implements</span> PaymentProcessor { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then <code>ChequePaymentProcessor</code> would be considered a candidate for injection into any of the following attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@PayBy</span>(CHEQUE) PaymentProcessor paymentProcessor;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Synchronous</span> PaymentProcessor paymentProcessor;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Synchronous</span> <span class="annotation">@PayBy</span>(CHEQUE) PaymentProcessor paymentProcessor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A bean must declare <em>all</em> of the qualifiers that are specified at the injection point to be considered a candidate for injection.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="name_resolution"><a class="anchor" href="#name_resolution"></a>5.3. Name resolution</h3>
<div class="paragraph">
<p>The process of matching a bean to a name is called <em>name resolution</em>.
Since there is no typing information available during name resolution, the container may consider only the bean name.
Name resolution usually occurs at runtime.</p>
</div>
<div class="paragraph">
<p>A name resolves to a bean if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the bean has the given bean name, and</p>
</li>
<li>
<p>the bean is available for injection in the module where the name resolution is requested.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>Bean</code> interface defined in <a href="#bean">The <code>Bean</code> interface</a>, the container calls <code>getName()</code> to determine the bean name.</p>
</div>
<div class="sect3">
<h4 id="ambig_names"><a class="anchor" href="#ambig_names"></a>5.3.1. Ambiguous names</h4>
<div class="paragraph">
<p>An <em>ambiguous name</em> exists when a name resolves to multiple beans.
When an ambiguous name exists, the container attempts to resolve the ambiguity.
The container eliminates all eligible beans that are not alternatives selected for the bean archive or selected for the application, except for producer methods and fields of beans that are alternatives.
If:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>there is exactly one bean remaining, the container will select this bean, and the ambiguous dependency is called <em>resolvable</em>.</p>
</li>
<li>
<p>all the beans left are alternatives with a priority, then the container will determine the highest priority value, and eliminate all beans, except for producer methods and fields of beans that are alternatives with the highest priority value.
If there is exactly one bean remaining, the container will select this bean, and the ambiguous dependency is called <em>resolvable</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All unresolvable ambiguous names are detected by the container when the application is initialized.
Suppose two beans are both available for injection in a certain module, and either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the two beans have the same bean name and the name is not resolvable, or</p>
</li>
<li>
<p>the bean name of one bean is of the form <code>x.y</code>, where <code>y</code> is a valid bean name, and <code>x</code> is the bean name of the other bean,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client_proxies"><a class="anchor" href="#client_proxies"></a>5.4. Client proxies</h3>
<div class="paragraph">
<p>An injected reference, or reference obtained by programmatic lookup, is usually a <em>contextual reference</em> as defined by <a href="#contextual_reference">Contextual reference for a bean</a>.</p>
</div>
<div class="paragraph">
<p>A contextual reference to a bean with a normal scope, as defined in <a href="#normal_scope">Normal scopes and pseudo-scopes</a>, is not a direct reference to a contextual instance of the bean (the object returned by <code>Contextual.create()</code>). Instead, the contextual reference is a <em>client proxy</em> object.
A client proxy implements/extends some or all of the bean types of the bean and delegates all method calls to the current instance (as defined in <a href="#normal_scope">Normal scopes and pseudo-scopes</a>) of the bean.</p>
</div>
<div class="paragraph">
<p>There are a number of reasons for this indirection:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The container must guarantee that when any valid injected reference to a bean of normal scope is invoked, the invocation is always processed by the current instance of the injected bean.
In certain scenarios, for example if a request scoped bean is injected into a session scoped bean, or into a servlet, this rule requires an indirect reference.
(Note that the <code>@Dependent</code> pseudo-scope is not a normal scope.)</p>
</li>
<li>
<p>The container may use a client proxy when creating beans with circular dependencies.
This is only necessary when the circular dependencies are initialized via a managed bean constructor or producer method parameter.
(Beans with scope <code>@Dependent</code> never have circular dependencies.)</p>
</li>
<li>
<p>Finally, client proxies may be passivated, even when the bean itself may not be.
Therefore the container must use a client proxy whenever a bean with normal scope is injected into a bean with a passivating scope, as defined in <a href="#passivating_scope">Passivation and passivating scopes</a>.
(On the other hand, beans with scope <code>@Dependent</code> must be serialized along with their client.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Client proxies are never required for a bean whose scope is a pseudo-scope such as <code>@Dependent</code>.</p>
</div>
<div class="paragraph">
<p>Client proxies may be shared between multiple injection points.
For example, a particular container might instantiate exactly one client proxy object per bean.
(However, this strategy is not required by this specification.)</p>
</div>
<div class="sect3">
<h4 id="client_proxy_invocation"><a class="anchor" href="#client_proxy_invocation"></a>5.4.1. Client proxy invocation</h4>
<div class="paragraph">
<p>Every time a method of the bean is invoked upon a client proxy, the client proxy must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>obtain a contextual instance of the bean, as defined in <a href="#contextual_instance">Contextual instance of a bean</a>, and</p>
</li>
<li>
<p>invoke the method upon this instance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the scope is not active, as specified in <a href="#active_context">The active context object for a scope</a>, the client proxy rethrows the <code>ContextNotActiveException</code> or <code>IllegalStateException</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of all methods declared by <code>java.lang.Object</code>, except for <code>toString()</code>, is undefined for a client proxy.
Portable applications should not invoke any method declared by <code>java.lang.Object</code>, except for <code>toString()</code>, on a client proxy.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="injection"><a class="anchor" href="#injection"></a>5.5. Dependency injection</h3>
<div class="paragraph">
<p>From time to time the container instantiates beans and other class supporting injection.
The resulting instance may or may not be a <em>contextual instance</em> as defined by <a href="#contextual_instance">Contextual instance of a bean</a>.</p>
</div>
<div class="paragraph">
<p>The container is required to perform dependency injection whenever it creates the following contextual objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>contextual instances of managed beans.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container is also required to perform dependency injection whenever it instantiates the following non-contextual objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>non-contextual instances of managed beans.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container interacts with instances of beans or objects supporting injection by calling methods and getting and setting field values.</p>
</div>
<div class="paragraph">
<p>The object injected by the container may not be a direct reference to a contextual instance of the bean.
Instead, it is an injectable reference, as defined by <a href="#injectable_reference">Injectable references</a>.</p>
</div>
<div class="sect3">
<h4 id="instantiation"><a class="anchor" href="#instantiation"></a>5.5.1. Injection using the bean constructor</h4>
<div class="paragraph">
<p>When the container instantiates a managed bean with a constructor annotated <code>@Inject</code>, the container calls this constructor, passing an injectable reference to each parameter.
If there is no constructor annotated <code>@Inject</code>, the container calls the constructor with no parameters.</p>
</div>
</div>
<div class="sect3">
<h4 id="fields_initializer_methods"><a class="anchor" href="#fields_initializer_methods"></a>5.5.2. Injection of fields and initializer methods</h4>
<div class="paragraph">
<p>When the container creates a new instance of a managed bean, the container must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize the values of all injected fields.
The container sets the value of each injected field to an injectable reference.</p>
</li>
<li>
<p>Call all initializer methods, passing an injectable reference to each parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container must ensure that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initializer methods declared by a class X in the type hierarchy of the bean are called after all injected fields declared by X or by superclasses of X have been initialized.</p>
</li>
<li>
<p>Any <code>@PostConstruct</code> callback declared by a class X in the type hierarchy of the bean is called after all initializer methods declared by X or by superclasses of X have been called, after all injected fields declared by X or by superclasses of X have been initialized.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="dependent_objects_destruction"><a class="anchor" href="#dependent_objects_destruction"></a>5.5.3. Destruction of dependent objects</h4>
<div class="paragraph">
<p>When the container destroys an instance of a bean, the container destroys all dependent objects, as defined in <a href="#dependent_destruction">Destruction of objects with scope <code>@Dependent</code></a>, after the <code>@PreDestroy</code> callback completes.</p>
</div>
</div>
<div class="sect3">
<h4 id="producer_or_disposer_methods_invocation"><a class="anchor" href="#producer_or_disposer_methods_invocation"></a>5.5.4. Invocation of producer or disposer methods</h4>
<div class="paragraph">
<p>When the container calls a producer or disposer method, the behavior depends upon whether the method is static or non-static:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the method is static, the container must invoke the method.</p>
</li>
<li>
<p>Otherwise, if the method is non-static, the container must:</p>
</li>
<li>
<p>Obtain a contextual instance of the bean which declares the method, as defined by <a href="#contextual_instance">Contextual instance of a bean</a>.</p>
</li>
<li>
<p>Invoke the method upon this instance, as a business method invocation, as defined in <a href="#biz_method">Container invocations and interception</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container passes an injectable reference to each injected method parameter.
The container is also responsible for destroying dependent objects created during this invocation, as defined in <a href="#dependent_destruction">Destruction of objects with scope <code>@Dependent</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="producer_fields_access"><a class="anchor" href="#producer_fields_access"></a>5.5.5. Access to producer field values</h4>
<div class="paragraph">
<p>When the container accesses the value of a producer field, the value depends upon whether the field is static or non-static:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the producer field is static, the container must access the field value.</p>
</li>
<li>
<p>Otherwise, if the producer field is non-static, the container must:</p>
</li>
<li>
<p>Obtain an contextual instance of the bean which declares the producer field, as defined by <a href="#contextual_instance">Contextual instance of a bean</a>.</p>
</li>
<li>
<p>Access the field value of this instance.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="observers_method_invocation"><a class="anchor" href="#observers_method_invocation"></a>5.5.6. Invocation of observer methods</h4>
<div class="paragraph">
<p>When the container calls an observer method (defined in <a href="#observer_methods">Observer methods</a>), the behavior depends upon whether the method is static or non-static:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the observer method is static, the container must invoke the method.</p>
</li>
<li>
<p>Otherwise, if the observer method is non-static, the container must:</p>
</li>
<li>
<p>Obtain a contextual instance of the bean which declares the observer method according to <a href="#contextual_instance">Contextual instance of a bean</a>.
If this observer method is a conditional observer method, obtain the contextual instance that already exists, only if the scope of the bean that declares the observer method is currently active, without creating a new contextual instance.</p>
</li>
<li>
<p>Invoke the observer method on the resulting instance, if any, as a business method invocation, as defined in <a href="#biz_method">Container invocations and interception</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container must pass the event object to the event parameter and an injectable instance to each injected method parameter.
The container is also responsible for destroying dependent objects created during this invocation, as defined in <a href="#dependent_destruction">Destruction of objects with scope <code>@Dependent</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="injection_point"><a class="anchor" href="#injection_point"></a>5.5.7. Injection point metadata</h4>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.InjectionPoint</code> provides access to metadata about an injection point.
An instance of <code>InjectionPoint</code> may represent:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an injected field or a parameter of a bean constructor, initializer method, producer method, disposer method or observer method, or</p>
</li>
<li>
<p>an instance obtained dynamically using <code>Instance.get()</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">InjectionPoint</span> {
    <span class="directive">public</span> <span class="predefined-type">Type</span> getType();
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Annotation</span>&gt; getQualifiers();
    <span class="directive">public</span> Bean&lt;?&gt; getBean();
    <span class="directive">public</span> <span class="predefined-type">Member</span> getMember();
    <span class="directive">public</span> Annotated getAnnotated();
    <span class="directive">public</span> <span class="type">boolean</span> isDelegate();
    <span class="directive">public</span> <span class="type">boolean</span> isTransient();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>getBean()</code> method returns the <code>Bean</code> object representing the bean that defines the injection point.
If the injection point does not belong to a bean, <code>getBean()</code> returns a null value.
If the injection point represents a dynamically obtained instance, the <code>getBean()</code> method should return the <code>Bean</code> object representing the bean that defines the <code>Instance</code> injection point.</p>
</li>
<li>
<p>The <code>getType()</code> and <code>getQualifiers()</code> methods return the required type and required qualifiers of the injection point.
If the injection point represents a dynamically obtained instance, the <code>getType()</code> and <code>getQualifiers()</code> methods should return the required type (as defined by <code>Instance.select()</code>), and required qualifiers of the injection point including any additional required qualifiers (as defined by <code>Instance.select()</code>).</p>
</li>
<li>
<p>The <code>getMember()</code> method returns the <code>Field</code> object in the case of field injection, the <code>Method</code> object in the case of method parameter injection, or the <code>Constructor</code> object in the case of constructor parameter injection.
If the injection point represents a dynamically obtained instance, the <code>getMember()</code> method returns the <code>Field</code> object representing the field that defines the <code>Instance</code> injection point in the case of field injection, the <code>Method</code> object representing the method that defines the <code>Instance</code> injection point in the case of method parameter injection, or the <code>Constructor</code> object representing the constructor that defines the <code>Instance</code> injection point in the case of constructor parameter injection.</p>
</li>
<li>
<p>The <code>getAnnotated()</code> method returns an instance of <code>jakarta.enterprise.inject.spi.AnnotatedField</code> or <code>jakarta.enterprise.inject.spi.AnnotatedParameter</code>, depending upon whether the injection point is an injected field or a constructor/method parameter.
If the injection point represents a dynamically obtained instance, then the <code>getAnnotated()</code> method returns an instance of <code>jakarta.enterprise.inject.spi.AnnotatedField</code> or <code>jakarta.enterprise.inject.spi.AnnotatedParameter</code> representing the <code>Instance</code> injection point, depending upon whether the injection point is an injected field or a constructor/method parameter.</p>
</li>
<li>
<p>The <code>isDelegate()</code> method returns <code>true</code> if the injection point is a decorator delegate injection point, and <code>false</code> otherwise.
If the injection point represents a dynamically obtained instance then <code>isDelegate()</code> returns false.</p>
</li>
<li>
<p>The <code>isTransient()</code> method returns <code>true</code> if the injection point is a transient field, and <code>false</code> otherwise.
If the injection point represents a dynamically obtained instance then the <code>isTransient()</code> method returns <code>true</code> if the <code>Instance</code> injection point is a transient field, and <code>false</code> otherwise. If this injection point is declared as transient, after bean&#8217;s passivation, the value will not be restored. Instance&lt;&gt; injection point is the preferred approach.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Occasionally, a bean with scope <code>@Dependent</code> needs to access metadata relating to the object into which it is injected.
For example, the following producer method creates injectable <code>Logger</code> s.
The log category of a <code>Logger</code> depends upon the class of the object into which it is injected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="predefined-type">Logger</span> createLogger(InjectionPoint injectionPoint) {
    <span class="keyword">return</span> <span class="predefined-type">Logger</span>.getLogger( injectionPoint.getMember().getDeclaringClass().getName() );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The container must provide a bean with scope <code>@Dependent</code>, bean type <code>InjectionPoint</code> and qualifier <code>@Default</code>, allowing dependent objects, as defined in <a href="#dependent_objects">Dependent objects</a>, to obtain information about the injection point to which they belong.
The built-in implementation must be a passivation capable dependency, as defined in <a href="#passivation_capable_dependency">Passivation capable dependencies</a>.</p>
</div>
<div class="paragraph">
<p>If a bean that declares any scope other than <code>@Dependent</code> has an injection point of type <code>InjectionPoint</code> and qualifier <code>@Default</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a disposer method has an injection point of type <code>InjectionPoint</code> and qualifier <code>Default</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a class supporting injection that is not a bean has an injection point of type <code>InjectionPoint</code> and qualifier <code>@Default</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
<div class="sect3">
<h4 id="bean_metadata"><a class="anchor" href="#bean_metadata"></a>5.5.8. Bean metadata</h4>
<div class="paragraph">
<p>The interfaces <code>Bean</code>, <code>Interceptor</code> and <code>Decorator</code> provide metadata about a bean.</p>
</div>
<div class="paragraph">
<p>The container must provide beans allowing a bean instance to obtain a <code>Bean</code>, <code>Interceptor</code> or <code>Decorator</code> instance containing its metadata:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a bean with scope <code>@Dependent</code>, qualifier <code>@Default</code> and type <code>Bean</code>  which can be injected into any bean instance</p>
</li>
<li>
<p>a bean with scope <code>@Dependent</code>, qualifier <code>@Default</code> and type <code>Interceptor</code>  which can be injected into any interceptor instance</p>
</li>
<li>
<p>a bean with scope <code>@Dependent</code>, qualifier <code>@Default</code> and type <code>Decorator</code>  which can be injected into any decorator instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, the container must provide beans allowing interceptors and decorators to obtain information about the beans they intercept and decorate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a bean with scope <code>@Dependent</code>, qualifier <code>@Intercepted</code> and type <code>Bean</code> which can be injected into any interceptor instance, and</p>
</li>
<li>
<p>a bean with scope <code>@Dependent</code>, qualifier <code>@Decorated</code> and type <code>Bean</code> which can be injected into any decorator instance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These beans are passivation capable dependencies, as defined in <a href="#passivation_capable_dependency">Passivation capable dependencies</a>.</p>
</div>
<div class="paragraph">
<p>If an <code>Interceptor</code> instance is injected into a bean instance other than an interceptor instance, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a <code>Decorator</code> instance is injected into a bean instance other than a decorator instance, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a <code>Bean</code> instance with qualifier <code>@Intercepted</code> is injected into a bean instance other than an interceptor instance, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a <code>Bean</code> instance with qualifier <code>@Decorated</code> is injected into a bean instance other than a decorator instance, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>The injection of bean metadata is restricted.
If:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the injection point is a field, an initializer method parameter or a bean constructor, with qualifier <code>@Default</code>, then the type parameter of the injected <code>Bean</code>, <code>Interceptor</code> or <code>Decorator</code> must be the same as the type declaring the injection point, or</p>
</li>
<li>
<p>the injection point is a field, an initializer method parameter or a bean constructor of an interceptor, with qualifier <code>@Intercepted</code>, then the type parameter of the injected <code>Bean</code> must be an unbounded wildcard, or</p>
</li>
<li>
<p>the injection point is a field, an initializer method parameter or a bean constructor of a decorator, with qualifier <code>@Decorated</code>, then the type parameter of the injected <code>Bean</code> must be the same as the delegate type, or</p>
</li>
<li>
<p>the injection point is a producer method parameter then the type parameter of the injected <code>Bean</code> must be the same as the producer method return type, or</p>
</li>
<li>
<p>the injection point is a parameter of a disposer method then the container automatically detects the problem and treats it as a definition error.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Otherwise, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Order</span><span class="delimiter">&quot;</span></span>) <span class="directive">public</span> <span class="type">class</span> <span class="class">OrderProcessor</span> {

    <span class="annotation">@Inject</span> Bean&lt;OrderProcessor&gt; bean;

    <span class="directive">public</span> <span class="type">void</span> getBeanName() {
       <span class="keyword">return</span> bean.getName();
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="programmatic_lookup"><a class="anchor" href="#programmatic_lookup"></a>5.6. Programmatic lookup</h3>
<div class="paragraph">
<p>In certain situations, injection is not the most convenient way to obtain a contextual reference.
For example, it may not be used when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the bean type or qualifiers vary dynamically at runtime, or</p>
</li>
<li>
<p>depending upon the deployment, there may be no bean which satisfies the type and qualifiers, or</p>
</li>
<li>
<p>we would like to iterate over all beans of a certain type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In these situations, an instance of the <code>jakarta.enterprise.inject.Instance</code> interface may be injected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> Instance&lt;PaymentProcessor&gt; paymentProcessor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>get()</code> returns a contextual reference:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">PaymentProcessor pp = paymentProcessor.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any combination of qualifiers may be specified at the injection point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@PayBy</span>(CHEQUE) Instance&lt;PaymentProcessor&gt; chequePaymentProcessor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, the <code>@Any</code> qualifier may be used, allowing the application to specify qualifiers dynamically:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Any</span> Instance&lt;PaymentProcessor&gt; anyPaymentProcessor;
...
Annotation qualifier = synchronously ? <span class="keyword">new</span> SynchronousQualifier() : <span class="keyword">new</span> AsynchronousQualifier();
PaymentProcessor pp = anyPaymentProcessor.select(qualifier).get().process(payment);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the returned bean has qualifier <code>@Synchronous</code> or <code>@Asynchronous</code> depending upon the value of <code>synchronously</code>.</p>
</div>
<div class="paragraph">
<p>Finally, the <code>@New</code> qualifier may be used, allowing the application to obtain a <code>@New</code> qualified bean, as defined in <a href="#new"><code>@New</code> qualified beans</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@New</span>(ChequePaymentProcessor.class) Instance&lt;PaymentProcessor&gt; chequePaymentProcessor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s even possible to iterate over a set of beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Any</span> Instance&lt;PaymentProcessor&gt; anyPaymentProcessor;
...
for (PaymentProcessor pp: anyPaymentProcessor) pp.test();</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="dynamic_lookup"><a class="anchor" href="#dynamic_lookup"></a>5.6.1. The <code>Instance</code> interface</h4>
<div class="paragraph">
<p>The <code>Instance</code> interface provides a method for obtaining instances of beans with a specified combination of required type and qualifiers, and inherits the ability to iterate beans with that combination of required type and qualifiers from <code>java.lang.Iterable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Instance</span>&lt;T&gt; <span class="directive">extends</span> <span class="predefined-type">Iterable</span>&lt;T&gt;, <span class="predefined-type">Provider</span>&lt;T&gt; {

    Instance&lt;T&gt; select(<span class="predefined-type">Annotation</span>... qualifiers);
    &lt;U <span class="directive">extends</span> T&gt; Instance&lt;U&gt; select(<span class="predefined-type">Class</span>&lt;U&gt; subtype, <span class="predefined-type">Annotation</span>... qualifiers);
    &lt;U <span class="directive">extends</span> T&gt; Instance&lt;U&gt; select(TypeLiteral&lt;U&gt; subtype, <span class="predefined-type">Annotation</span>... qualifiers);

    Stream&lt;T&gt; stream();

    <span class="type">boolean</span> isUnsatisfied();
    <span class="type">boolean</span> isAmbiguous();
    <span class="type">boolean</span> isResolvable();

    <span class="type">void</span> destroy(T instance);


}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For an injected <code>Instance</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <em>required type</em> is the type parameter specified at the injection point, and</p>
</li>
<li>
<p>the <em>required qualifiers</em> are the qualifiers specified at the injection point.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, this injected <code>Instance</code> has required type <code>PaymentProcessor</code> and required qualifier <code>@Any</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Any</span> Instance&lt;PaymentProcessor&gt; anyPaymentProcessor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>select()</code> method returns a child <code>Instance</code> for a given required type and additional required qualifiers.
If no required type is given, the required type is the same as the parent.
Rules specified at <a href="#injection_point_default_qualifier">The default qualifier at injection points</a> are applied before performing typesafe resolution.</p>
</div>
<div class="paragraph">
<p>For example, this child <code>Instance</code> has required type <code>AsynchronousPaymentProcessor</code> and additional required qualifier <code>@Asynchronous</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Instance&lt;AsynchronousPaymentProcessor&gt; async = anyPaymentProcessor.select(
            AsynchronousPaymentProcessor.class, <span class="keyword">new</span> AsynchronousQualifier() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an injection point of raw type <code>Instance</code> is defined, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If two instances of the same non repeating qualifier type are passed to <code>select()</code>, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If an instance of an annotation that is not a qualifier type is passed to <code>select()</code>, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>The <code>get()</code> method must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identify a bean that has the required type and required qualifiers and is eligible for injection into the class into which the parent <code>Instance</code> was injected, according to the rules of typesafe resolution, as defined in <a href="#performing_typesafe_resolution">Performing typesafe resolution</a>, resolving ambiguities according to <a href="#unsatisfied_and_ambig_dependencies">Unsatisfied and ambiguous dependencies</a>.</p>
</li>
<li>
<p>If typesafe resolution results in an unsatisfied dependency, throw an <code>UnsatisfiedResolutionException</code>. If typesafe resolution results in an unresolvable ambiguous dependency, throw an <code>AmbiguousResolutionException</code>.</p>
</li>
<li>
<p>Otherwise, obtain a contextual reference for the bean and the required type, as defined in <a href="#contextual_reference">Contextual reference for a bean</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>iterator()</code> method must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identify the set of beans that have the required type and required qualifiers and are eligible for injection into the class into which the parent <code>Instance</code> was injected, according to the rules of typesafe resolution, as defined in <a href="#performing_typesafe_resolution">Performing typesafe resolution</a>, resolving ambiguities according to <a href="#unsatisfied_and_ambig_dependencies">Unsatisfied and ambiguous dependencies</a>.</p>
</li>
<li>
<p>Return an <code>Iterator</code>, that iterates over the set of contextual references for the resulting beans and required type, as defined in <a href="#contextual_reference">Contextual reference for a bean</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>stream()</code> method must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identify the set of beans that have the required type and required qualifiers and are eligible for injection into the class into which the parent <code>Instance</code> was injected, according to the rules of typesafe resolution, as defined in <a href="#performing_typesafe_resolution">Performing typesafe resolution</a>, resolving ambiguities according to <a href="#unsatisfied_and_ambig_dependencies">Unsatisfied and ambiguous dependencies</a>.</p>
</li>
<li>
<p>Return a <code>Stream</code>, that can stream over the set of contextual references for the resulting beans and required type, as defined in <a href="#contextual_reference">Contextual reference for a bean</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The methods <code>isUnsatisfied()</code>, <code>isAmbiguous()</code> and <code>isResolvable()</code> must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identify the set of beans that have the required type and required qualifiers and are eligible for injection into the class into which the parent <code>Instance</code> was injected, according to the rules of typesafe resolution, as defined in <a href="#performing_typesafe_resolution">Performing typesafe resolution</a>, resolving ambiguities according to <a href="#unsatisfied_and_ambig_dependencies">Unsatisfied and ambiguous dependencies</a>.</p>
</li>
<li>
<p>The method <code>isUnsatisfied()</code> returns <code>true</code> if there is no bean found, or <code>false</code> otherwise.</p>
</li>
<li>
<p>The method <code>isAmbiguous()</code> returns <code>true</code> if there is more than one bean found, or <code>false</code> otherwise.</p>
</li>
<li>
<p>The method <code>isResolvable()</code> returns <code>true</code> if there is exactly one bean found, or <code>false</code> otherwise.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The method <code>destroy()</code> instructs the container to destroy the instance.
The bean instance passed to <code>destroy()</code> should be a dependent scoped bean instance obtained from the same <code>Instance</code> object, or a client proxy for a normal scoped bean.
Applications are encouraged to always call <code>destroy()</code> when they no longer require an instance obtained from <code>Instance</code>. All built-in normal scoped contexts support destroying bean instances.
An <code>UnsupportedOperationException</code> is thrown if the active context object for the scope type of the bean does not support destroying bean instances.</p>
</div>
</div>
<div class="sect3">
<h4 id="builtin_instance"><a class="anchor" href="#builtin_instance"></a>5.6.2. The built-in <code>Instance</code></h4>
<div class="paragraph">
<p>The container must provide a built-in bean that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>is eligible for injection to any injection point with required type <code>Instance&lt;X&gt;</code> or <code>Provider&lt;X&gt;</code>, for any legal bean type <code>X</code>,</p>
</li>
<li>
<p>has any qualifiers</p>
</li>
<li>
<p>has scope <code>@Dependent</code>,</p>
</li>
<li>
<p>has no bean name, and</p>
</li>
<li>
<p>has an implementation provided automatically by the container.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The built-in implementation must be a passivation capable dependency, as defined in <a href="#passivation_capable_dependency">Passivation capable dependencies</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="annotationliteral_typeliteral"><a class="anchor" href="#annotationliteral_typeliteral"></a>5.6.3. Using <code>AnnotationLiteral</code> and <code>TypeLiteral</code></h4>
<div class="paragraph">
<p><code>jakarta.enterprise.util.AnnotationLiteral</code> makes it easier to specify qualifiers when calling <code>select()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> PaymentProcessor getSynchronousPaymentProcessor(PaymentMethod paymentMethod) {

    <span class="type">class</span> <span class="class">SynchronousQualifier</span> <span class="directive">extends</span> AnnotationLiteral&lt;Synchronous&gt;
            <span class="directive">implements</span> Synchronous {}

    <span class="type">class</span> <span class="class">PayByQualifier</span> <span class="directive">extends</span> AnnotationLiteral&lt;PayBy&gt;
            <span class="directive">implements</span> PayBy {
        <span class="directive">public</span> PaymentMethod value() { <span class="keyword">return</span> paymentMethod; }
    }

    <span class="keyword">return</span> anyPaymentProcessor.select(<span class="keyword">new</span> SynchronousQualifier(), <span class="keyword">new</span> PayByQualifier()).get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>jakarta.enterprise.util.TypeLiteral</code> makes it easier to specify a parameterized type with actual type parameters when calling <code>select()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> PaymentProcessor&lt;Cheque&gt; getChequePaymentProcessor() {
    PaymentProcessor&lt;Cheque&gt; pp = anyPaymentProcessor
        .select( <span class="keyword">new</span> TypeLiteral&lt;PaymentProcessor&lt;Cheque&gt;&gt;() {} ).get();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="built_in_annotation_literals"><a class="anchor" href="#built_in_annotation_literals"></a>5.6.4. Built-in annotation literals</h4>
<div class="paragraph">
<p>The following built-in annotations define a <code>Literal</code> static nested class to support inline instantiation of the specific annotation type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jakarta.enterprise.inject.Any</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.Default</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.New</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.Specializes</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.Vetoed</code></p>
</li>
<li>
<p><code>jakarta.enterprise.util.Nonbinding</code></p>
</li>
<li>
<p><code>jakarta.enterprise.context.Initialized</code></p>
</li>
<li>
<p><code>jakarta.enterprise.context.Destroyed</code></p>
</li>
<li>
<p><code>jakarta.enterprise.context.RequestScoped</code></p>
</li>
<li>
<p><code>jakarta.enterprise.context.SessionScoped</code></p>
</li>
<li>
<p><code>jakarta.enterprise.context.ApplicationScoped</code></p>
</li>
<li>
<p><code>jakarta.enterprise.context.Dependent</code></p>
</li>
<li>
<p><code>jakarta.enterprise.context.ConversationScoped</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.Alternative</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.Typed</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>Literal</code> class might be used to instantiate the matching <code>AnnotationLiteral</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Default defaultLiteral = <span class="keyword">new</span> Default.Literal();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Annotations without members provide the default <code>AnnotationLiteral</code> instance declared as a constant named <code>INSTANCE</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RequestScoped requestScopedLiteral = RequestScoped.Literal.INSTANCE;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Annotations having members do not provide the default <code>AnnotationLiteral</code> instance. Instead, a constructor or factory method named <code>of</code> can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Initialized initializedForApplicationScoped = <span class="keyword">new</span> Initialized.Literal(ApplicationScoped.class);

Initialized initializedForRequestScoped = Initialized.Literal.of(RequestScoped.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the annotation javadoc for more information about specific <code>Literal</code> members.</p>
</div>
<div class="paragraph">
<p>In addition, CDI also provides annotation literals for the following JSR 330 annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jakarta.inject.Inject</code> with <code>jakarta.enterprise.inject.literal.InjectLiteral</code> class</p>
</li>
<li>
<p><code>jakarta.inject.Named</code> with <code>jakarta.enterprise.inject.literal.NamedLiteral</code> class</p>
</li>
<li>
<p><code>jakarta.inject.Qualifier</code> with <code>jakarta.enterprise.inject.literal.QualifierLiteral</code> class</p>
</li>
<li>
<p><code>jakarta.inject.Singleton</code> with <code>jakarta.enterprise.inject.literal.SingletonLiteral</code> class</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>They can be used like static nested classes described above.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contexts"><a class="anchor" href="#contexts"></a>6. Scopes and contexts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Associated with every scope type is a <em>context object</em>.
The context object determines the lifecycle and visibility of instances of all beans with that scope. In particular, the context object defines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a new instance of any bean with that scope is created</p>
</li>
<li>
<p>When an existing instance of any bean with that scope is destroyed</p>
</li>
<li>
<p>Which injected references refer to any instance of a bean with that scope</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The context implementation collaborates with the container via the <code>Context</code> and <code>Contextual</code> interfaces to create and destroy contextual instances.</p>
</div>
<div class="sect2">
<h3 id="contextual"><a class="anchor" href="#contextual"></a>6.1. The <code>Contextual</code> interface</h3>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.context.spi.Contextual</code> defines operations to create and destroy contextual instances of a certain type. Any implementation of <code>Contextual</code> is called a <em>contextual type</em>.
In particular, the <code>Bean</code> interface defined in <a href="#bean">The <code>Bean</code> interface</a> extends <code>Contextual</code>, so all beans are contextual types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Contextual</span>&lt;T&gt; {
    <span class="directive">public</span> T create(CreationalContext&lt;T&gt; creationalContext);
    <span class="directive">public</span> <span class="type">void</span> destroy(T instance, CreationalContext&lt;T&gt; creationalContext);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>create()</code> is responsible for creating new contextual instances of the type.</p>
</li>
<li>
<p><code>destroy()</code> is responsible for destroying instances of the type. In particular, it is responsible for destroying all dependent objects of an instance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If an exception occurs while creating an instance, the exception is rethrown by the <code>create()</code> method.
If the exception is a checked exception, it must be wrapped and rethrown as an (unchecked) <code>CreationException</code>.</p>
</div>
<div class="paragraph">
<p>If an exception occurs while destroying an instance, the exception must be caught by the <code>destroy()</code> method.</p>
</div>
<div class="paragraph">
<p>If the application invokes a contextual instance after it has been destroyed, the behavior is undefined.</p>
</div>
<div class="paragraph">
<p>The container and portable extensions may define implementations of the <code>Contextual</code> interface that do not extend <code>Bean</code>, but it is not recommended that applications directly implement <code>Contextual</code>.</p>
</div>
<div class="sect3">
<h4 id="creational_context"><a class="anchor" href="#creational_context"></a>6.1.1. The <code>CreationalContext</code> interface</h4>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.context.spi.CreationalContext</code> provides operations that are used by the <code>Contextual</code> implementation during instance creation and destruction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">CreationalContext</span>&lt;T&gt; {
    <span class="directive">public</span> <span class="type">void</span> push(T incompleteInstance);
    <span class="directive">public</span> <span class="type">void</span> release();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>push()</code> registers an <em>incompletely initialized</em> contextual instance the with the container.
A contextual instance is considered incompletely initialized until it is returned by the <code>create()</code> method.</p>
</li>
<li>
<p><code>release()</code> destroys all dependent objects, as defined in <a href="#dependent_objects">Dependent objects</a>, of the instance which is being destroyed, by passing each dependent object to the <code>destroy()</code> method of its <code>Contextual</code> object.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The implementation of <code>Contextual</code> is not required to call <code>push()</code>. However, for certain bean scopes, invocation of <code>push()</code> between instantiation and injection helps the container minimize the use of client proxy objects (which would otherwise be required to allow circular dependencies).</p>
</div>
<div class="paragraph">
<p>If <code>Contextual.create()</code> calls <code>push()</code>, it must also return the instance passed to <code>push()</code>.</p>
</div>
<div class="paragraph">
<p><code>Contextual.create()</code> should use the given <code>CreationalContext</code> when obtaining contextual references to inject, as defined in <a href="#contextual_reference">Contextual reference for a bean</a>, in order to ensure that any dependent objects are associated with the contextual instance that is being created.</p>
</div>
<div class="paragraph">
<p><code>Contextual.destroy()</code> should call <code>release()</code> to allow the container to destroy dependent objects of the contextual instance.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context"><a class="anchor" href="#context"></a>6.2. The <code>Context</code> interface</h3>
<div class="paragraph">
<p>The <code>jakarta.enterprise.context.spi.Context</code> interface provides an operation for obtaining contextual instances with a particular scope of any contextual type. Any instance of <code>Context</code> is called a context object.</p>
</div>
<div class="paragraph">
<p>The context object is responsible for creating and destroying contextual instances by calling operations of the <code>Contextual</code> interface.</p>
</div>
<div class="paragraph">
<p>The <code>Context</code> interface is called by the container and may be called by portable extensions.
It should not be called directly by the application.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Context</span> {
    <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; getScope();
    <span class="type">boolean</span> isActive();
    <span class="directive">public</span> &lt;T&gt; T get(Contextual&lt;T&gt; bean);
    <span class="directive">public</span> &lt;T&gt; T get(Contextual&lt;T&gt; bean, CreationalContext&lt;T&gt; creationalContext);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AlterableContext</span> <span class="directive">extends</span> <span class="predefined-type">Context</span> {
    <span class="directive">public</span> <span class="type">void</span> destroy(Contextual&lt;?&gt; contextual);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>getScope()</code> returns the scope type of the context object.</p>
</div>
<div class="paragraph">
<p>A context object may be defined for any of the built-in scopes and registered with the container using the <code>AfterBeanDiscovery</code> event as described in <a href="#after_bean_discovery"><code>AfterBeanDiscovery</code> event</a>.</p>
</div>
<div class="paragraph">
<p>At a particular point in the execution of the program a context object may be <em>active</em> with respect to the current thread.
When a context object is active the <code>isActive()</code> method returns <code>true</code>. Otherwise, we say that the context object is <em>inactive</em> and the <code>isActive()</code> method returns <code>false</code>.</p>
</div>
<div class="paragraph">
<p>The <code>get()</code> method obtains contextual instances of the contextual type represented by the given instance of <code>Contextual</code>. The <code>get()</code> method may either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>return an existing instance of the given contextual type, or</p>
</li>
<li>
<p>if no <code>CreationalContext</code> is given, return a null value, or</p>
</li>
<li>
<p>if a <code>CreationalContext</code> is given, create a new instance of the given contextual type by calling <code>Contextual.create()</code>, passing the given <code>CreationalContext</code>, and return the new instance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>get()</code> method may not return a null value unless no <code>CreationalContext</code> is given, or <code>Contextual.create()</code> returns a null value.</p>
</div>
<div class="paragraph">
<p>The <code>get()</code> method may not create a new instance of the given contextual type unless a <code>CreationalContext</code> is given.</p>
</div>
<div class="paragraph">
<p>The <code>destroy()</code> method destroys an existing contextual instance, removing it from the context instance.</p>
</div>
<div class="paragraph">
<p>The <code>AlterableContext</code> interface was introduced in CDI 1.1 to allow bean instances to be destroyed by the application.
Extensions providing context implementations for normal scopes should implement <code>AlterableContext</code> instead of <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>If the context object is inactive, the <code>get()</code> and <code>destroy()</code> methods must throw a <code>ContextNotActiveException</code>.</p>
</div>
<div class="paragraph">
<p>When the container calls <code>get()</code> or <code>destroy()</code> for a context that is associated with a passivating scope it must ensure that the given instance of <code>Contextual</code>  and the instance of <code>CreationalContext</code>, if given, are serializable.</p>
</div>
<div class="paragraph">
<p>The context object is responsible for destroying any contextual instance it creates by passing the instance to the <code>destroy()</code> method of the <code>Contextual</code> object representing the contextual type. A destroyed instance must not subsequently be returned by the <code>get()</code> method.</p>
</div>
<div class="paragraph">
<p>The context object must pass the same instance of <code>CreationalContext</code> to <code>Contextual.destroy()</code> that it passed to <code>Contextual.create()</code> when it created the instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="normal_scope"><a class="anchor" href="#normal_scope"></a>6.3. Normal scopes and pseudo-scopes</h3>
<div class="paragraph">
<p>Most scopes are <em>normal scopes</em>.
The context object for a normal scope type is a mapping from each contextual type with that scope to an instance of that contextual type. There may be no more than one mapped instance per contextual type per thread.
The set of all mapped instances of contextual types with a certain scope for a certain thread is called the <em>context</em> for that scope associated with that thread.</p>
</div>
<div class="paragraph">
<p>A context may be associated with one or more threads.
A context with a certain scope is said to <em>propagate</em> from one point in the execution of the program to another when the set of mapped instances of contextual types with that scope is preserved.</p>
</div>
<div class="paragraph">
<p>The context associated with the current thread is called the <em>current context</em> for the scope. The mapped instance of a contextual type associated with a current context is called the <em>current instance</em> of the contextual type.</p>
</div>
<div class="paragraph">
<p>The <code>get()</code> operation of the context object for an active normal scope returns the current instance of the given contextual type.</p>
</div>
<div class="paragraph">
<p>At certain points in the execution of the program a context may be <em>destroyed</em>.
When a context is destroyed, all mapped instances belonging to that context are destroyed by passing them to the <code>Contextual.destroy()</code> method.</p>
</div>
<div class="paragraph">
<p>Contexts with normal scopes must obey the following rule:</p>
</div>
<div class="paragraph">
<p><em>Suppose beans A, B and Z all have normal scopes.
Suppose A has an injection point x, and B has an injection point y.
Suppose further that both x and y resolve to bean Z according to the rules of typesafe resolution.
If a is the current instance of A, and b is the current instance of B, then both a.x and b.y refer to the same instance of Z.
This instance is the current instance of Z.</em></p>
</div>
<div class="paragraph">
<p>Any scope that is not a normal scope is called a <em>pseudo-scope</em>.
The concept of a current instance is not well-defined in the case of a pseudo-scope.</p>
</div>
<div class="paragraph">
<p>All normal scopes must be explicitly declared <code>@NormalScope</code>, to indicate to the container that a client proxy is required.</p>
</div>
<div class="paragraph">
<p>All pseudo-scopes must be explicitly declared <code>@Scope</code>, to indicate to the container that no client proxy is required.</p>
</div>
<div class="paragraph">
<p>All scopes defined by this specification, except for the <code>@Dependent</code> pseudo-scope, are normal scopes.</p>
</div>
</div>
<div class="sect2">
<h3 id="dependent_context"><a class="anchor" href="#dependent_context"></a>6.4. Dependent pseudo-scope</h3>
<div class="paragraph">
<p>The <code>@Dependent</code> scope type is a pseudo-scope. Beans declared with scope type <code>@Dependent</code> behave differently to beans with other built-in scope types.</p>
</div>
<div class="paragraph">
<p>When a bean is declared to have <code>@Dependent</code> scope:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No injected instance of the bean is ever shared between multiple injection points.</p>
</li>
<li>
<p>Any instance of the bean injected into an object that is being created by the container is bound to the lifecycle of the newly created object.</p>
</li>
<li>
<p>Any instance of the bean that receives a producer method, producer field, disposer method or observer method invocation exists to service that invocation only.</p>
</li>
<li>
<p>Any instance of the bean injected into method parameters of a disposer method or observer method exists to service the method invocation only (except for observer methods of container lifecycle events).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Every invocation of the <code>get()</code> operation of the <code>Context</code> object for the <code>@Dependent</code> scope with a <code>CreationalContext</code> returns a new instance of the given bean.</p>
</div>
<div class="paragraph">
<p>Every invocation of the <code>get()</code> operation of the <code>Context</code> object for the <code>@Dependent</code> scope with no <code>CreationalContext</code> returns a null value.</p>
</div>
<div class="paragraph">
<p>The <code>@Dependent</code> scope is always active.</p>
</div>
<div class="sect3">
<h4 id="dependent_objects"><a class="anchor" href="#dependent_objects"></a>6.4.1. Dependent objects</h4>
<div class="paragraph">
<p>Many instances of beans with scope <code>@Dependent</code> belong to some other bean and are called <em>dependent objects</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Instances of decorators and interceptors are dependent objects of the bean instance they decorate.</p>
</li>
<li>
<p>An instance of a bean with scope <code>@Dependent</code> injected into a field, bean constructor or initializer method is a dependent object of the bean into which it was injected.</p>
</li>
<li>
<p>An instance of a bean with scope <code>@Dependent</code> injected into a producer method is a dependent object of the producer method bean instance that is being produced.</p>
</li>
<li>
<p>An instance of a bean with scope <code>@Dependent</code> obtained by direct invocation of an <code>Instance</code> is a dependent object of the instance of <code>Instance</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="dependent_destruction"><a class="anchor" href="#dependent_destruction"></a>6.4.2. Destruction of objects with scope <code>@Dependent</code></h4>
<div class="paragraph">
<p>Dependent objects of a contextual instance are destroyed when <code>Contextual.destroy()</code> calls <code>CreationalContext.release()</code>, as defined in <a href="#creational_context">The <code>CreationalContext</code> interface</a>.</p>
</div>
<div class="paragraph">
<p>Additionally, the container must ensure that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>all dependent objects of a non-contextual instance of a bean are destroyed when the instance is destroyed by the container,</p>
</li>
<li>
<p>all <code>@Dependent</code> scoped contextual instances injected into method parameters of a disposer method or an observer method are destroyed when the invocation completes,</p>
</li>
<li>
<p>all <code>@Dependent</code> scoped contextual instances injected into method or constructor parameters that are annotated with <code>@TransientReference</code> are destroyed when the invocation completes, and</p>
</li>
<li>
<p>any <code>@Dependent</code> scoped contextual instance created to receive a producer method, producer field, disposer method or observer method invocation is destroyed when the invocation completes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, the container is permitted to destroy any <code>@Dependent</code> scoped contextual instance at any time if the instance is no longer referenced by the application (excluding weak, soft and phantom references).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="contextual_instances_and_references"><a class="anchor" href="#contextual_instances_and_references"></a>6.5. Contextual instances and contextual references</h3>
<div class="paragraph">
<p>The <code>Context</code> object is the ultimate source of the contextual instances that underly contextual references.</p>
</div>
<div class="sect3">
<h4 id="active_context"><a class="anchor" href="#active_context"></a>6.5.1. The active context object for a scope</h4>
<div class="paragraph">
<p>From time to time, the container must obtain an <em>active context object</em> for a certain scope type. The container must search for an active instance of <code>Context</code> associated with the scope type.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If no active context object exists for the scope type, the container throws a <code>ContextNotActiveException</code>.</p>
</li>
<li>
<p>If more than one active context object exists for the given scope type, the container must throw an <code>IllegalStateException</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there is exactly one active instance of <code>Context</code> associated with the scope type, we say that the scope is <em>active</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="activating_builtin_contexts"><a class="anchor" href="#activating_builtin_contexts"></a>6.5.2. Activating Built In Contexts</h4>
<div class="paragraph">
<p>Certain built in contexts support the ability to be activated and deactivated.  This allows developers to control built-in contexts in ways that they could also manage custom built contexts.</p>
</div>
<div class="paragraph">
<p>When activating and deactivating built in contexts, it is important to realize that they can only be activated if not already active within a given thread.</p>
</div>
<div class="sect4">
<h5 id="activating_request_context"><a class="anchor" href="#activating_request_context"></a>6.5.2.1. Activating a Request Context</h5>
<div class="paragraph">
<p>Request contexts can be managed either programmatically or via interceptor.</p>
</div>
<div class="paragraph">
<p>To programmatically manage request contexts, the container provides a built in bean that is <code>@Dependent</code> scoped and of type <code>RequestContextController</code> that allows you to activate and deactivate a request context on the current thread.  The object should be considered stateful, invoking the same instance on different threads may not work properly, non-portable behavior may occur.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>public interface RequestContextController {
   boolean activate();
   void deactivate() throws ContextNotActiveException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>activate()</code> method is called, if the request context is not already active on the current thread then it will be activated and the method returns <code>true</code>.  Otherwise, the method returns <code>false</code>.</p>
</div>
<div class="paragraph">
<p>When the <code>deactivate()</code> method is called, if this controller started the request context then the request context is stopped.  The method does nothing if this controller did not activate the context and the context is active.  This method throws a <code>ContextNotActiveException</code> if there is no request context active.</p>
</div>
<div class="paragraph">
<p>If within the same thread the <code>activate()</code> and <code>deactivate()</code> methods are invoked repeatedly, the instances between the activations are not the same instances, each request context should be assumed to be new.</p>
</div>
<div class="paragraph">
<p>To automatically start a request context via interceptor binding, the container provides an interceptor <code>@ActivateRequestContext</code> which will activate a request context if not already active prior to the method&#8217;s invocation, and deactivate it upon method completion, with the same rules as in <code>RequestContextController</code>.  The interceptor is automatically registered with a priority of <code>PLATFORM_BEFORE + 100</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="contextual_instance"><a class="anchor" href="#contextual_instance"></a>6.5.3. Contextual instance of a bean</h4>
<div class="paragraph">
<p>From time to time, the container must obtain a <em>contextual instance</em> of a bean.
The container must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>obtain the active context object for the bean scope, then</p>
</li>
<li>
<p>obtain an instance of the bean by calling <code>Context.get()</code>, passing the <code>Bean</code> instance representing the bean and an instance of <code>CreationalContext</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>From time to time, the container attempts to obtain a <em>contextual instance of a bean that already exists</em>, without creating a new contextual instance. The container must determine if the scope of the bean is active and if it is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>obtain the active context object for the bean scope, then</p>
</li>
<li>
<p>attempt to obtain an existing instance of the bean by calling <code>Context.get()</code>, passing the <code>Bean</code> instance representing the bean without passing any instance of <code>CreationalContext</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the scope is not active, or if <code>Context.get()</code> returns a null value, there is no contextual instance that already exists.</p>
</div>
<div class="paragraph">
<p>A contextual instance of any of the built-in kinds of bean defined in <a href="#implementation">Programming model</a> is considered an internal container construct, and it is therefore not strictly required that a contextual instance of a built-in kind of bean directly implement the bean types of the bean.
However, in this case, the container is required to transform its internal representation to an object that does implement the bean types expected by the application before injecting or returning a contextual instance to the application.</p>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>Bean</code> interface defined in <a href="#bean">The <code>Bean</code> interface</a>, the container calls <code>getScope()</code> to determine the bean scope.</p>
</div>
</div>
<div class="sect3">
<h4 id="contextual_reference"><a class="anchor" href="#contextual_reference"></a>6.5.4. Contextual reference for a bean</h4>
<div class="paragraph">
<p>From time to time, the container must obtain a <em>contextual reference</em> for a bean and a given bean type of the bean.
A contextual reference implements the given bean type and all bean types of the bean which are Java interfaces.
A contextual reference is not, in general, required to implement all concrete bean types of the bean.</p>
</div>
<div class="paragraph">
<p>Contextual references must be obtained with a given <code>CreationalContext</code>, allowing any instance of scope <code>@Dependent</code> that is created to be later destroyed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the bean has a normal scope and the given bean type cannot be proxied by the container, as defined in <a href="#unproxyable">Unproxyable bean types</a>, the container throws an <code>UnproxyableResolutionException</code>.</p>
</li>
<li>
<p>If the bean has a normal scope, then the contextual reference for the bean is a client proxy, as defined in <a href="#client_proxies">Client proxies</a>, created by the container, that implements the given bean type and all bean types of the bean which are Java interfaces.</p>
</li>
<li>
<p>Otherwise, if the bean has a pseudo-scope, the container must obtain a contextual instance of the bean.
If the bean has scope <code>@Dependent</code>, the container must associate it with the <code>CreationalContext</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container must ensure that every injection point of type <code>InjectionPoint</code> and qualifier <code>@Default</code> of any dependent object instantiated during this process receives:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an instance of <code>InjectionPoint</code> representing the injection point into which the dependent object will be injected, or</p>
</li>
<li>
<p>a null value if it is not being injected into any injection point.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="contextual_reference_validity"><a class="anchor" href="#contextual_reference_validity"></a>6.5.5. Contextual reference validity</h4>
<div class="paragraph">
<p>A contextual reference for a bean is <em>valid</em> only for a certain period of time. The application should not invoke a method of an invalid reference.</p>
</div>
<div class="paragraph">
<p>The validity of a contextual reference for a bean depends upon whether the scope of the bean is a normal scope or a pseudo-scope.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any reference to a bean with a normal scope is valid as long as the application maintains a hard reference to it.
However, it may only be invoked when the context associated with the normal scope is active. If it is invoked when the context is inactive, a <code>ContextNotActiveException</code> is thrown by the container.</p>
</li>
<li>
<p>Any reference to a bean with a normal scope is invalid after CDI container shutdown. Maintaining such reference and attempting to use it after container shutdown results in an <code>IllegalStateException</code>.</p>
</li>
<li>
<p>Any reference to a bean with a pseudo-scope (such as <code>@Dependent</code>) is valid until the bean instance to which it refers is destroyed.
It may be invoked even if the context associated with the pseudo-scope is not active. If the application invokes a method of a reference to an instance that has already been destroyed, the behavior is undefined.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="injectable_reference"><a class="anchor" href="#injectable_reference"></a>6.5.6. Injectable references</h4>
<div class="paragraph">
<p>From time to time, the container must obtain an <em>injectable reference</em> for an injection point.
The container must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Identify a bean according to the rules defined in <a href="#typesafe_resolution">Typesafe resolution</a> and resolving ambiguities according to <a href="#unsatisfied_and_ambig_dependencies">Unsatisfied and ambiguous dependencies</a>.</p>
</li>
<li>
<p>Obtain a contextual reference for this bean and the type of the injection point according to <a href="#contextual_reference">Contextual reference for a bean</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For certain combinations of scopes, the container is permitted to optimize the above procedure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The container is permitted to directly inject a contextual instance of the bean, as defined in <a href="#contextual_instance">Contextual instance of a bean</a>.</p>
</li>
<li>
<p>If an incompletely initialized instance of the bean is registered with the current <code>CreationalContext</code>, as defined in <a href="#contextual">The <code>Contextual</code> interface</a>, the container is permitted to directly inject this instance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, in performing these optimizations, the container must respect the rules of <em>injectable reference validity</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="injectable_reference_validity"><a class="anchor" href="#injectable_reference_validity"></a>6.5.7. Injectable reference validity</h4>
<div class="paragraph">
<p>Injectable references to a bean must respect the rules of contextual reference validity, with the following exceptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A reference to a bean injected into a field, bean constructor or initializer method is only valid until the object into which it was injected is destroyed.</p>
</li>
<li>
<p>A reference to a bean injected into a producer method is only valid until the producer method bean instance that is being produced is destroyed.</p>
</li>
<li>
<p>A reference to a bean injected into a disposer method or observer method is only valid until the invocation of the method completes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The application should not invoke a method of an invalid injected reference. If the application invokes a method of an invalid injected reference, the behavior is undefined.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="passivating_scope"><a class="anchor" href="#passivating_scope"></a>6.6. Passivation and passivating scopes</h3>
<div class="paragraph">
<p>The temporary transfer of the state of an idle object held in memory to some form of secondary storage is called <em>passivation</em>.
The transfer of the passivated state back into memory is called <em>activation</em>.</p>
</div>
<div class="sect3">
<h4 id="passivation_capable"><a class="anchor" href="#passivation_capable"></a>6.6.1. Passivation capable beans</h4>
<div class="paragraph">
<p>A bean is called <em>passivation capable</em> if the container is able to temporarily transfer the state of any idle instance to secondary storage.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A managed bean is passivation capable if and only if the bean class is serializable and all interceptors and decorators of the bean are passivation capable.</p>
</li>
<li>
<p>A producer method is passivation capable if and only if it never returns a value which is not passivation capable at runtime.</p>
</li>
<li>
<p>A producer field is passivation capable if and only if it never refers to a value which is not passivation capable at runtime.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A custom implementation of <code>Bean</code> is passivation capable if it implements the interface <code>PassivationCapable</code>. An implementation of <code>Contextual</code> that is not a bean is passivation capable if it implements both <code>PassivationCapable</code> and <code>Serializable</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">PassivationCapable</span> {
    <span class="directive">public</span> <span class="predefined-type">String</span> getId();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getId()</code> method must return a value that uniquely identifies the instance of <code>Bean</code> or <code>Contextual</code>. It is recommended that the string contain the package name of the class that implements <code>Bean</code> or <code>Contextual</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="passivation_capable_injection_points"><a class="anchor" href="#passivation_capable_injection_points"></a>6.6.2. Passivation capable injection points</h4>
<div class="paragraph">
<p>We call an injection point of a bean <em>passivation capable</em> if the injection point is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a transient field, or</p>
</li>
<li>
<p>a non-transient field which resolves to a bean that is a passivation capable dependency, or</p>
</li>
<li>
<p>a bean constructor parameter which is annotated with <code>@TransientReference</code>, or</p>
</li>
<li>
<p>a bean constructor parameter which resolves to a bean that is a passivation capable dependency, or</p>
</li>
<li>
<p>a method parameter which is annotated with <code>@TransientReference</code>, or</p>
</li>
<li>
<p>a method parameter which resolves to a bean that is a passivation capable dependency.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="passivation_capable_dependency"><a class="anchor" href="#passivation_capable_dependency"></a>6.6.3. Passivation capable dependencies</h4>
<div class="paragraph">
<p>A bean is called a <em>passivation capable dependency</em> if any contextual reference for that bean is preserved when the object holding the reference is passivated and then activated.</p>
</div>
<div class="paragraph">
<p>The container must guarantee that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>all beans with normal scope are passivation capable dependencies,</p>
</li>
<li>
<p>all passivation capable beans with scope <code>@Dependent</code> are passivation capable dependencies,</p>
</li>
<li>
<p>the built-in beans of type <code>Instance</code>, <code>Event</code>, <code>InjectionPoint</code> and <code>BeanManager</code> are passivation capable dependencies.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A custom implementation of <code>Bean</code> is a passivation capable dependency if it implements <code>PassivationCapable</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="passivating_scopes"><a class="anchor" href="#passivating_scopes"></a>6.6.4. Passivating scopes</h4>
<div class="paragraph">
<p>A <em>passivating scope</em> requires that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>beans with the scope are passivation capable, and</p>
</li>
<li>
<p>implementations of <code>Contextual</code> passed to any context object for the scope are passivation capable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Passivating scopes must be explicitly declared <code>@NormalScope(passivating=true)</code>.</p>
</div>
<div class="paragraph">
<p>For example, the built-in session and conversation scopes defined in <a href="#builtin_contexts">Context management for built-in scopes</a> are passivating scopes.
No other built-in scopes are passivating scopes.</p>
</div>
</div>
<div class="sect3">
<h4 id="passivation_validation"><a class="anchor" href="#passivation_validation"></a>6.6.5. Validation of passivation capable beans and dependencies</h4>
<div class="paragraph">
<p>For every bean which declares a passivating scope, the container must validate that the bean truly is passivation capable and that, in addition, its dependencies are passivation capable.</p>
</div>
<div class="paragraph">
<p>If a managed bean which declares a passivating scope, or a built-in bean:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>is not passivation capable,</p>
</li>
<li>
<p>has an injection point that is not passivation capable,</p>
</li>
<li>
<p>has an interceptor or decorator that is not passivation capable</p>
</li>
<li>
<p>has an interceptor or decorator with an injection point that is not passivation capable</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>then the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>If a producer method declares a passivating scope and:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>has a return type that is declared final and does not implement or extend <code>Serializable</code>, or,</p>
</li>
<li>
<p>has an injection point that is not passivation capable</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>then the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>If a producer method declares a passivating scope and doesn&#8217;t only return <code>Serializable</code> types at runtime, then the container must throw an <code>IllegalProductException</code>.</p>
</div>
<div class="paragraph">
<p>If a producer field declares a passivating scope and has a type that is declared final and does not implement or extend <code>Serializable</code> then the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>If a producer field declares a passivating scope and doesn&#8217;t only contain <code>Serializable</code> values at runtime then the container must throw an <code>IllegalProductException</code>.</p>
</div>
<div class="paragraph">
<p>If a producer method or field of scope <code>@Dependent</code> returns an unserializable object for injection into an injection point that requires a passivation capable dependency, the container must throw an <code>IllegalProductException</code></p>
</div>
<div class="paragraph">
<p>For a custom implementation of <code>Bean</code>, the container calls <code>getInjectionPoints()</code> to determine the injection points, and <code>InjectionPoint.isTransient()</code> to determine whether the injection point is a transient field.</p>
</div>
<div class="paragraph">
<p>If a managed bean which declares a passivating scope type, has a decorator or interceptor which is not a passivation capable dependency, the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="builtin_contexts"><a class="anchor" href="#builtin_contexts"></a>6.7. Context management for built-in scopes</h3>
<div class="paragraph">
<p>The container must provide an implementation of the <code>Context</code> interface for each of the built-in scopes defined in <a href="#builtin_scopes">Built-in scope types</a>.
These implementations depend on the platform the container is running.</p>
</div>
<div class="paragraph">
<p>A portable extension may define a custom context object for any or all of the built-in scopes.
For example, a remoting framework might provide a request context object for the built-in request scope.</p>
</div>
<div class="paragraph">
<p>The context associated with a built-in normal scope propagates across local, synchronous Java method calls.
The context does not propagate across remote method invocations or to asynchronous processes.</p>
</div>
<div class="paragraph">
<p>Portable extensions are encouraged to synchronously fire:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an event with qualifier <code>@Initialized(X.class)</code> when a custom context is initialized, i.e. ready for use,</p>
</li>
<li>
<p>an event with qualifier <code>@BeforeDestroyed(X.class)</code> when a custom context is about to be destroyed, i.e. before the actual destruction,</p>
</li>
<li>
<p>an event with qualifier <code>@Destroyed(X.class)</code> when a custom context is destroyed, i.e. after the actual destruction,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>where <code>X</code> is the scope type associated with the context.</p>
</div>
<div class="paragraph">
<p>A suitable event payload should be chosen.</p>
</div>
<div class="sect3">
<h4 id="request_context"><a class="anchor" href="#request_context"></a>6.7.1. Request context lifecycle</h4>
<div class="paragraph">
<p>The <em>request context</em> is provided by a built-in context object for the built-in scope type <code>@RequestScoped</code>.</p>
</div>
<div class="paragraph">
<p>An event with qualifier <code>@Initialized(RequestScoped.class)</code> is synchronously fired when the request context is initialized.
An event with qualifier <code>@BeforeDestroyed(RequestScoped.class)</code> is synchronously fired when the request context is about to be destroyed, i.e. before the actual destruction.
An event with qualifier <code>@Destroyed(RequestScoped.class)</code> is synchronously fired when the request context is destroyed, i.e. after the actual destruction.</p>
</div>
<div class="paragraph">
<p>The request context is active:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>during notification of an asynchronous observer method, and</p>
</li>
<li>
<p>during <code>@PostConstruct</code> callback of any bean.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The request context is destroyed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>after the invocation of an asynchronous observer method completes, and</p>
</li>
<li>
<p>after the <code>@PostConstruct</code> callback completes, if it did not already exist when the <code>@PostConstruct</code> callback occurred.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="session_context"><a class="anchor" href="#session_context"></a>6.7.2. Session context lifecycle</h4>
<div class="paragraph">
<p>The <em>session context</em> is provided by a built-in context object for the built-in passivating scope type <code>@SessionScoped</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="application_context"><a class="anchor" href="#application_context"></a>6.7.3. Application context lifecycle</h4>
<div class="paragraph">
<p>The <em>application context</em> is provided by a built-in context object for the built-in scope type <code>@ApplicationScoped</code>.</p>
</div>
<div class="paragraph">
<p>An event with qualifier <code>@Initialized(ApplicationScoped.class)</code> is synchronously fired when the application context is initialized.
An event with qualifier <code>@BeforeDestroyed(ApplicationScoped.class)</code> is synchronously fired when the application context is about to be destroyed, i.e. before the actual destruction.
An event with qualifier <code>@Destroyed(ApplicationScoped.class)</code> is synchronously fired when the application context is destroyed, i.e. after the actual destruction.</p>
</div>
</div>
<div class="sect3">
<h4 id="conversation_context"><a class="anchor" href="#conversation_context"></a>6.7.4. Conversation context lifecycle</h4>
<div class="paragraph">
<p>The <em>conversation context</em> is provided by a built-in context object for the built-in passivating scope type <code>@ConversationScoped</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="conversation"><a class="anchor" href="#conversation"></a>6.7.5. The <code>Conversation</code> interface</h4>
<div class="paragraph">
<p>The container provides a built-in bean with bean type <code>Conversation</code>, scope <code>@RequestScoped</code>, and qualifier <code>@Default</code>, named <code>jakarta.enterprise.context.conversation</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Conversation</span> {
   <span class="directive">public</span> <span class="type">void</span> begin();
   <span class="directive">public</span> <span class="type">void</span> begin(<span class="predefined-type">String</span> id);
   <span class="directive">public</span> <span class="type">void</span> end();
   <span class="directive">public</span> <span class="predefined-type">String</span> getId();
   <span class="directive">public</span> <span class="type">long</span> getTimeout();
   <span class="directive">public</span> <span class="type">void</span> setTimeout(<span class="type">long</span> milliseconds);
   <span class="directive">public</span> <span class="type">boolean</span> isTransient();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>begin()</code> marks the current transient conversation long-running. A conversation identifier may, optionally, be specified.
If no conversation identifier is specified, an identifier is generated by the container.</p>
</li>
<li>
<p><code>end()</code> marks the current long-running conversation transient.</p>
</li>
<li>
<p><code>getId()</code> returns the identifier of the current long-running conversation, or a null value if the current conversation is transient.</p>
</li>
<li>
<p><code>getTimeout()</code> returns the timeout, in milliseconds, of the current conversation.</p>
</li>
<li>
<p><code>setTimeout()</code> sets the timeout of the current conversation.</p>
</li>
<li>
<p><code>isTransient()</code> returns <code>true</code> if the conversation is marked transient, or <code>false</code> if it is marked long-running.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If any method of <code>Conversation</code> is called when the conversation scope is not active, a <code>ContextNotActiveException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If <code>end()</code> is called, and the current conversation is marked transient, an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If <code>begin()</code> is called, and the current conversation is already marked long-running, an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If <code>begin()</code> is called with an explicit conversation identifier, and a long-running conversation with that identifier already exists, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lifecycle"><a class="anchor" href="#lifecycle"></a>7. Lifecycle of contextual instances</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The lifecycle of a contextual instance of a bean is managed by the context object for the bean&#8217;s scope, as defined in <a href="#contexts">Scopes and contexts</a>.</p>
</div>
<div class="paragraph">
<p>Every bean in the system is represented by an instance of the <code>Bean</code> interface defined in <a href="#bean">The <code>Bean</code> interface</a>.
This interface is a subtype of <code>Contextual</code>. To create and destroy contextual instances, the context object calls the <code>create()</code> and <code>destroy()</code> operations defined by the interface <code>Contextual</code>, as defined in <a href="#contextual">The <code>Contextual</code> interface</a>.</p>
</div>
<div class="sect2">
<h3 id="bean_instantiation_restriction"><a class="anchor" href="#bean_instantiation_restriction"></a>7.1. Restriction upon bean instantiation</h3>
<div class="paragraph">
<p>There are very few programming restrictions upon the bean class of a bean.
In particular, the class is a concrete class and is not required to implement any special interface or extend any special superclass.
Therefore, bean classes are easy to instantiate and unit test.</p>
</div>
<div class="paragraph">
<p>However, if the application directly instantiates a bean class, instead of letting the container perform instantiation, the resulting instance is not managed by the container and is not a contextual instance as defined by <a href="#contextual_instance">Contextual instance of a bean</a>.
Furthermore, the capabilities listed in <a href="#capabilities">Functionality provided by the container to the bean</a> will not be available to that particular instance. In a deployed application, it is the container that is responsible for instantiating beans and initializing their dependencies.</p>
</div>
<div class="paragraph">
<p>If the application requires more control over instantiation of a contextual instance, a producer method or field may be used.
Any Java object may be returned by a producer method or field.
It is not required that the returned object be a contextual reference for a bean.
However, if the object is not a contextual reference for another bean, the object will be contextual instance of the producer method bean, and therefore available for injection into other objects and use in name resolution, but the other capabilities listed in <a href="#capabilities">Functionality provided by the container to the bean</a> will not be available to the object.</p>
</div>
<div class="paragraph">
<p>In the following example, a producer method returns instances of other beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SessionScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">PaymentStrategyProducer</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span> {

   <span class="directive">private</span> PaymentStrategyType paymentStrategyType;

   <span class="directive">public</span> <span class="type">void</span> setPaymentStrategyType(PaymentStrategyType type) {
      paymentStrategyType = type;
   }

   <span class="annotation">@Produces</span> PaymentStrategy getPaymentStrategy(<span class="annotation">@CreditCard</span> PaymentStrategy creditCard,
                                                <span class="annotation">@Cheque</span> PaymentStrategy cheque,
                                                <span class="annotation">@Online</span> PaymentStrategy online) {
      <span class="keyword">switch</span> (paymentStrategyType) {
         <span class="keyword">case</span> CREDIT_CARD: <span class="keyword">return</span> creditCard;
         <span class="keyword">case</span> CHEQUE: <span class="keyword">return</span> cheque;
         <span class="keyword">case</span> ONLINE: <span class="keyword">return</span> online;
         <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
      }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, any object returned by the producer method has already had its dependencies injected, receives lifecycle callbacks and event notifications and may have interceptors.</p>
</div>
<div class="paragraph">
<p>But in this example, the returned objects are not contextual instances:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SessionScoped</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">PaymentStrategyProducer</span> <span class="directive">implements</span> <span class="predefined-type">Serializable</span> {

   <span class="directive">private</span> PaymentStrategyType paymentStrategyType;

   <span class="directive">public</span> <span class="type">void</span> setPaymentStrategyType(PaymentStrategyType type) {
      paymentStrategyType = type;
   }

   <span class="annotation">@Produces</span> PaymentStrategy getPaymentStrategy() {
      <span class="keyword">switch</span> (paymentStrategyType) {
         <span class="keyword">case</span> CREDIT_CARD: <span class="keyword">return</span> <span class="keyword">new</span> CreditCardPaymentStrategy();
         <span class="keyword">case</span> CHEQUE: <span class="keyword">return</span> <span class="keyword">new</span> ChequePaymentStrategy();
         <span class="keyword">case</span> ONLINE: <span class="keyword">return</span> <span class="keyword">new</span> OnlinePaymentStrategy();
         <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
      }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, any object returned by the producer method will not have any dependencies injected by the container, receives no lifecycle callbacks or event notifications and does not have interceptors or decorators.</p>
</div>
</div>
<div class="sect2">
<h3 id="biz_method"><a class="anchor" href="#biz_method"></a>7.2. Container invocations and interception</h3>
<div class="paragraph">
<p>When the application invokes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a method of a bean via a contextual reference to the bean, as defined in <a href="#contextual_reference">Contextual reference for a bean</a>,</p>
</li>
<li>
<p>a method of a bean via a non-contextual reference to the bean, if the instance was created by the container (e.g. using  <code>InjectionTarget.produce()</code> or <code>UnmanagedInstance.produce()</code>), or</p>
</li>
<li>
<p>a method of a bean via a non-contextual reference to the bean, if the instance was enhanced with the <code>InterceptionFactory</code> interface as defined in <a href="#interception_factory">The <code>InterceptionFactory</code> interface</a>,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>the invocation is treated as a <em>business method invocation</em>.</p>
</div>
<div class="paragraph">
<p>When the container invokes a method of a bean, the invocation may or may not be treated as a business method invocation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invocations of initializer methods by the container are not business method invocations.</p>
</li>
<li>
<p>Invocations of producer, disposer and observer methods by the container are business method invocations and are intercepted by method interceptors and decorators.</p>
</li>
<li>
<p>Invocation of lifecycle callbacks by the container are not business method invocations, but are intercepted by interceptors for lifecycle callbacks.</p>
</li>
<li>
<p>Invocations of interceptors and decorator methods during method or lifecycle callback interception are not business method invocations, and therefore no recursive interception occurs.</p>
</li>
<li>
<p>Invocations of methods declared by java.lang.Object are not business method invocations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A method invocation passes through method interceptors and decorators if, and only if, it is a business method invocation.</p>
</div>
<div class="paragraph">
<p>Otherwise, the invocation is treated as a normal Java method call and is not intercepted by the container.</p>
</div>
</div>
<div class="sect2">
<h3 id="contextual_instance_lifecycle"><a class="anchor" href="#contextual_instance_lifecycle"></a>7.3. Lifecycle of contextual instances</h3>
<div class="paragraph">
<p>The actual mechanics of bean creation and destruction varies according to what kind of bean is being created or destroyed.</p>
</div>
<div class="sect3">
<h4 id="managed_bean_lifecycle"><a class="anchor" href="#managed_bean_lifecycle"></a>7.3.1. Lifecycle of managed beans</h4>
<div class="paragraph">
<p>When the <code>create()</code> method of the <code>Bean</code> object that represents a managed bean is called, the container obtains an instance of the bean, as defined by the Managed Beans specification, calling the bean constructor as defined by <a href="#instantiation">Injection using the bean constructor</a>, and performing dependency injection as defined in <a href="#fields_initializer_methods">Injection of fields and initializer methods</a>.</p>
</div>
<div class="paragraph">
<p>When the <code>destroy()</code> method is called, the container destroys the instance, as defined by the Managed Beans specification, and any dependent objects, as defined in <a href="#dependent_objects_destruction">Destruction of dependent objects</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="producer_method_lifecycle"><a class="anchor" href="#producer_method_lifecycle"></a>7.3.2. Lifecycle of producer methods</h4>
<div class="paragraph">
<p>When the <code>create()</code> method of a <code>Bean</code> object that represents a producer method is called, the container must invoke the producer method as defined by <a href="#producer_or_disposer_methods_invocation">Invocation of producer or disposer methods</a>.
The return value of the producer method, after method interception completes, is the new contextual instance to be returned by <code>Bean.create()</code>.</p>
</div>
<div class="paragraph">
<p>If the producer method returns a null value and the producer method bean has the scope <code>@Dependent</code>, the <code>create()</code> method returns a null value.</p>
</div>
<div class="paragraph">
<p>Otherwise, if the producer method returns a null value, and the scope of the producer method is not <code>@Dependent</code>, the <code>create()</code> method throws an <code>IllegalProductException</code>.</p>
</div>
<div class="paragraph">
<p>When the <code>destroy()</code> method is called, and if there is a disposer method for this producer method, the container must invoke the disposer method as defined by <a href="#producer_or_disposer_methods_invocation">Invocation of producer or disposer methods</a>, passing the instance given to <code>destroy()</code> to the disposed parameter.
Finally, the container destroys dependent objects, as defined in <a href="#dependent_objects_destruction">Destruction of dependent objects</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="producer_field_lifecycle"><a class="anchor" href="#producer_field_lifecycle"></a>7.3.3. Lifecycle of producer fields</h4>
<div class="paragraph">
<p>When the <code>create()</code> method of a <code>Bean</code> object that represents a producer field is called, the container must access the producer field as defined by <a href="#producer_fields_access">Access to producer field values</a> to obtain the current value of the field.
The value of the producer field is the new contextual instance to be returned by <code>Bean.create()</code>.</p>
</div>
<div class="paragraph">
<p>If the producer field contains a null value and the producer field bean has the scope <code>@Dependent</code>, the <code>create()</code> method returns a null value.</p>
</div>
<div class="paragraph">
<p>Otherwise, if the producer field contains a null value, and the scope of the producer field is not <code>@Dependent</code>, the <code>create()</code> method throws an <code>IllegalProductException</code>.</p>
</div>
<div class="paragraph">
<p>When the <code>destroy()</code> method is called, and if there is a disposer method for this producer field, the container must invoke the disposer method as defined by <a href="#producer_or_disposer_methods_invocation">Invocation of producer or disposer methods</a>, passing the instance given to <code>destroy()</code> to the disposed parameter.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="decorators"><a class="anchor" href="#decorators"></a>8. Decorators</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>decorator</em> implements one or more bean types and intercepts business method invocations of beans which implement those bean types.
These bean types are called <em>decorated types</em>.</p>
</div>
<div class="paragraph">
<p>Decorators are superficially similar to interceptors, but because they directly implement operations with business semantics, they are able to implement business logic and, conversely, unable to implement the cross-cutting concerns for which interceptors are optimized.</p>
</div>
<div class="paragraph">
<p>Decorators may be associated with any managed bean that is not itself an interceptor or decorator, or with any built-in bean other than the built-in bean with type <code>BeanManager</code> and qualifier <code>@Default</code>.
Decorators are not automatically applied to the return value of a producer method or the current value of a producer field.</p>
</div>
<div class="paragraph">
<p>A decorator instance is a dependent object of the object it decorates.</p>
</div>
<div class="sect2">
<h3 id="decorator_bean"><a class="anchor" href="#decorator_bean"></a>8.1. Decorator beans</h3>
<div class="paragraph">
<p>A decorator is a managed bean.
The set of decorated types of a decorator includes all bean types of the managed bean which are Java interfaces, except for <code>java.io.Serializable</code>. The decorator bean class and its superclasses are not decorated types of the decorator.
The decorator class may be abstract.</p>
</div>
<div class="paragraph">
<p>If the set of decorated types of a decorator is empty, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a decorator declares any scope other than <code>@Dependent</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="sect3">
<h4 id="decorator_annotation"><a class="anchor" href="#decorator_annotation"></a>8.1.1. Declaring a decorator</h4>
<div class="paragraph">
<p>A decorator is declared by annotating the bean class with the <code>@jakarta.decorator.Decorator</code> stereotype.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Decorator</span> <span class="annotation">@Priority</span>(jakarta.interceptor.Interceptor.Priority.APPLICATION)
<span class="type">class</span> <span class="class">TimestampLogger</span> <span class="directive">implements</span> <span class="predefined-type">Logger</span> { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="delegate_attribute"><a class="anchor" href="#delegate_attribute"></a>8.1.2. Decorator delegate injection points</h4>
<div class="paragraph">
<p>All decorators have a <em>delegate injection point</em>.
A delegate injection point is an injection point of the bean class.
The type and qualifiers of the injection point are called the <em>delegate type</em> and <em>delegate qualifiers</em>.
The decorator applies to beans that are assignable to the delegate injection point.</p>
</div>
<div class="paragraph">
<p>The delegate injection point must be declared by annotating the injection point with the annotation <code>@jakarta.decorator.Delegate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Decorator</span> <span class="annotation">@Priority</span>(jakarta.interceptor.Interceptor.Priority.APPLICATION)
<span class="type">class</span> <span class="class">TimestampLogger</span> <span class="directive">implements</span> <span class="predefined-type">Logger</span> {
    <span class="annotation">@Inject</span> <span class="annotation">@Delegate</span> <span class="annotation">@Any</span> <span class="predefined-type">Logger</span> logger;
    ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Decorator</span> <span class="annotation">@Priority</span>(jakarta.interceptor.Interceptor.Priority.APPLICATION)
<span class="type">class</span> <span class="class">TimestampLogger</span> <span class="directive">implements</span> <span class="predefined-type">Logger</span> {
    <span class="directive">private</span> <span class="predefined-type">Logger</span> logger;

    <span class="annotation">@Inject</span>
    <span class="directive">public</span> TimestampLogger(<span class="annotation">@Delegate</span> <span class="annotation">@Debug</span> <span class="predefined-type">Logger</span> logger) {
        <span class="local-variable">this</span>.logger=logger;
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A decorator must have exactly one delegate injection point.
If a decorator has more than one delegate injection point, or does not have a delegate injection point, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>The delegate injection point must be an injected field, initializer method parameter or bean constructor method parameter.
If an injection point that is not an injected field, initializer method parameter or bean constructor method parameter is annotated <code>@Delegate</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a bean class that is not a decorator has an injection point annotated <code>@Delegate</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>The container must inject a <em>delegate</em> object to the delegate injection point.
The delegate object implements the delegate type and delegates method invocations to remaining uninvoked decorators and eventually to the bean.
When the container calls a decorator during business method interception, the decorator may invoke any method of the delegate object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Decorator</span> <span class="annotation">@Priority</span>(jakarta.interceptor.Interceptor.Priority.APPLICATION)
<span class="type">class</span> <span class="class">TimestampLogger</span> <span class="directive">implements</span> <span class="predefined-type">Logger</span> {
    <span class="annotation">@Inject</span> <span class="annotation">@Delegate</span> <span class="annotation">@Any</span> <span class="predefined-type">Logger</span> logger;

    <span class="type">void</span> log(<span class="predefined-type">String</span> message) {
        logger.log( timestamp() + <span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span> + message );
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a decorator invokes the delegate object at any other time, the invoked method throws an <code>IllegalStateException</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="decorated_types"><a class="anchor" href="#decorated_types"></a>8.1.3. Decorated types of a decorator</h4>
<div class="paragraph">
<p>The delegate type of a decorator must implement or extend every decorated type (with exactly the same type parameters). If the delegate type does not implement or extend a decorated type of the decorator (or specifies different type parameters), the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>A decorator is not required to implement the delegate type.</p>
</div>
<div class="paragraph">
<p>A decorator may be an abstract Java class, and is not required to implement every method of every decorated type.
Whenever the decorator does not implement a method of the decorated type, the container will provide an implicit implementation that calls the method on the delegate.
If a decorator has abstract methods that are not declared by a decorated type, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>The decorator intercepts every method which is declared by a decorated type of the decorator and is implemented by the bean class of the decorator.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="enabled_decorators"><a class="anchor" href="#enabled_decorators"></a>8.2. Decorator enablement and ordering</h3>
<div class="paragraph">
<p>This specification defines two methods of enabling and ordering decorators.
From Contexts and Dependency Injection 1.1 onwards the <code>@Priority</code> annotation allows a decorator to be enabled and ordered for an entire application.
Contexts and Dependency Injection 1.0 allowed only for a decorator to be enabled and ordered for a bean archive.</p>
</div>
<div class="paragraph">
<p>Decorators are called after interceptors.
Decorators enabled using <code>@Priority</code> are called before decorators enabled using <code>beans.xml</code>.</p>
</div>
<div class="paragraph">
<p>A decorator is said to be <strong>enabled</strong> if it is enabled in at least one bean archive or is listed in the final list of decorators for the application, as defined in <a href="#after_type_discovery"><code>AfterTypeDiscovery</code> event</a>.</p>
</div>
<div class="paragraph">
<p>If a decorator is enabled for the application and for the bean archive, then the enablement from the bean archive is ignored by the container.  The decorator will only be executed once based on the <code>@Priority</code> annotation&#8217;s invocation chain.</p>
</div>
<div class="sect3">
<h4 id="enabled_decorators_priority"><a class="anchor" href="#enabled_decorators_priority"></a>8.2.1. Decorator enablement and ordering for an application</h4>
<div class="paragraph">
<p>A decorator may be enabled for the entire application by applying the <code>@Priority</code> annotation, along with a priority value, on the decorator class.
Decorators with the smaller priority values are called first.
The order of more than one decorator with the same priority is undefined.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Decorator</span> <span class="annotation">@Priority</span>(jakarta.interceptor.Interceptor.Priority.APPLICATION)
<span class="type">class</span> <span class="class">TimestampLogger</span> <span class="directive">implements</span> <span class="predefined-type">Logger</span> {

   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The priority value ranges defined in the Java Interceptors specification section 5.5 should be used when defining decorator priorities.</p>
</div>
</div>
<div class="sect3">
<h4 id="enabled_decorators_bean_archive"><a class="anchor" href="#enabled_decorators_bean_archive"></a>8.2.2. Decorator enablement and ordering for a bean archive</h4>
<div class="paragraph">
<p>A decorator may be  explicitly enabled by listing its bean class under the <code>&lt;decorators&gt;</code> element of the <code>beans.xml</code> file of the bean archive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_3_0.xsd</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">version</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
   <span class="tag">&lt;decorators&gt;</span>
      <span class="tag">&lt;class&gt;</span>com.acme.myfwk.TimestampLogger<span class="tag">&lt;/class&gt;</span>
      <span class="tag">&lt;class&gt;</span>com.acme.myfwk.IdentityLogger<span class="tag">&lt;/class&gt;</span>
   <span class="tag">&lt;/decorators&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The order of the decorator declarations determines the decorator ordering.
Decorators which occur earlier in the list are called first.</p>
</div>
<div class="paragraph">
<p>Each child <code>&lt;class&gt;</code> element must specify the name of a decorator bean class.
If there is no class with the specified name, or if the class with the specified name is not a decorator bean class, the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>If the same class is listed twice under the <code>&lt;decorators&gt;</code> element, the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="decorator_resolution"><a class="anchor" href="#decorator_resolution"></a>8.3. Decorator resolution</h3>
<div class="paragraph">
<p>The process of matching decorators to a certain bean is called <em>decorator resolution</em>.
A decorator is bound to a bean if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The bean is assignable to the delegate injection point according to the rules defined in <a href="#typesafe_resolution">Typesafe resolution</a> (using <a href="#delegate_assignable_parameters">Assignability of raw and parameterized types for delegate injection points</a>).</p>
</li>
<li>
<p>The decorator is enabled in the bean archive containing the bean.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a decorator matches a managed bean, the managed bean class must be a proxyable bean type, as defined in <a href="#unproxyable">Unproxyable bean types</a>.</p>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>Decorator</code> interface defined in <a href="#decorator">The <code>Decorator</code> interface</a>, the container calls <code>getDelegateType()</code>, <code>getDelegateQualifiers()</code> and <code>getDecoratedTypes()</code> to determine the delegate type and qualifiers and decorated types of the decorator.</p>
</div>
<div class="paragraph">
<p>A custom implementation of the <code>Decorator</code> interface may implement the <a href="#prioritized"><code>Prioritized</code> interface</a> to be enabled for the entire application with a priority value.</p>
</div>
<div class="sect3">
<h4 id="delegate_assignable_parameters"><a class="anchor" href="#delegate_assignable_parameters"></a>8.3.1. Assignability of raw and parameterized types for delegate injection points</h4>
<div class="paragraph">
<p>Decorator delegate injection points have a special set of rules for determining assignability of raw and parameterized types, as an exception to <a href="#assignable_parameters">Assignability of raw and parameterized types</a>.</p>
</div>
<div class="paragraph">
<p>A raw bean type is considered assignable to a parameterized delegate type if the raw types are identical and all type parameters of the delegate type are either unbounded type variables or <code>java.lang.Object</code>.</p>
</div>
<div class="paragraph">
<p>A parameterized bean type is considered assignable to a parameterized delegate type if they have identical raw type and for each parameter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the delegate type parameter and the bean type parameter are actual types with identical raw type, and, if the type is parameterized, the bean type parameter is assignable to the delegate type parameter according to these rules, or</p>
</li>
<li>
<p>the delegate type parameter is a wildcard, the bean type parameter is an actual type and the actual type is assignable to the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or</p>
</li>
<li>
<p>the delegate type parameter is a wildcard, the bean type parameter is a type variable and the upper bound of the type variable is assignable to the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or</p>
</li>
<li>
<p>the delegate type parameter and the bean type parameter are both type variables and the upper bound of the bean type parameter is assignable to the upper bound, if any, of the delegate type parameter, or</p>
</li>
<li>
<p>the delegate type parameter is a type variable, the bean type parameter is an actual type, and the actual type is assignable to the upper bound, if any, of the type variable.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="decorator_invocation"><a class="anchor" href="#decorator_invocation"></a>8.4. Decorator invocation</h3>
<div class="paragraph">
<p>Whenever a business method is invoked on an instance of a bean with decorators, the container intercepts the business method invocation and, after processing all interceptors of the method, invokes decorators of the bean.</p>
</div>
<div class="paragraph">
<p>The container searches for the first decorator of the instance that implements the method that is being invoked as a business method.
If no such decorator exists, the container invokes the business method of the intercepted instance.
Otherwise, the container calls the method of the decorator.</p>
</div>
<div class="paragraph">
<p>When any decorator is invoked by the container, it may in turn invoke a method of the delegate.
The container intercepts the delegate invocation and searches for the first decorator of the instance such that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the decorator occurs after the decorator invoking the delegate, and</p>
</li>
<li>
<p>the decorator implements the method that is being invoked upon the delegate.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If no such decorator exists, the container invokes the business method of the intercepted instance.
Otherwise, the container calls the method of the decorator.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="interceptors"><a class="anchor" href="#interceptors"></a>9. Interceptor bindings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Managed beans support interception.
<em>Interceptors</em> are used to separate cross-cutting concerns from business logic.
The Java Interceptors specification defines the basic programming model and semantics, and how to associate interceptors with target classes.
This specification defines various extensions to the Java Interceptors specification, including how to override the interceptor order defined by the <code>@Priority</code> annotation.</p>
</div>
<div class="sect2">
<h3 id="interceptor_bindings"><a class="anchor" href="#interceptor_bindings"></a>9.1. Interceptor binding types</h3>
<div class="paragraph">
<p>This specification extends the Java Interceptors specification and allows interceptor bindings to be applied to CDI stereotypes.</p>
</div>
<div class="sect3">
<h4 id="stereotype_interceptor_bindings"><a class="anchor" href="#stereotype_interceptor_bindings"></a>9.1.1. Interceptor bindings for stereotypes</h4>
<div class="paragraph">
<p>Interceptor bindings may be applied to a stereotype by annotating the stereotype annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Transactional</span>
<span class="annotation">@Secure</span>
<span class="annotation">@RequestScoped</span>
<span class="annotation">@Stereotype</span>
<span class="annotation">@Target</span>(TYPE)
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> <span class="predefined-type">Action</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An interceptor binding declared by a stereotype is inherited by any bean that declares that stereotype.</p>
</div>
<div class="paragraph">
<p>If a stereotype declares interceptor bindings, it must be defined as <code>@Target(TYPE)</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="declaring_interceptor"><a class="anchor" href="#declaring_interceptor"></a>9.2. Declaring the interceptor bindings of an interceptor</h3>
<div class="paragraph">
<p>This specification extends the Java Interceptors specification and defines how the container must behave if a definition error is encountered.</p>
</div>
</div>
<div class="sect2">
<h3 id="binding_interceptor_to_bean"><a class="anchor" href="#binding_interceptor_to_bean"></a>9.3. Binding an interceptor to a bean</h3>
<div class="paragraph">
<p>This specification extends the Java Interceptors specification and defines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>additional restrictions about the type of bean to which an interceptor can be bound, and</p>
</li>
<li>
<p>how the container must behave if a definition error is encountered, and</p>
</li>
<li>
<p>how interceptors are bound using stereotypes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Interceptor bindings may be used to associate interceptors with any managed bean that is not a decorator.</p>
</div>
<div class="paragraph">
<p>The set of interceptor bindings for a method declared at class level includes those declared on stereotypes.
An interceptor binding declared on a bean class replaces an interceptor binding of the same type declared by a stereotype that is applied to the bean class.</p>
</div>
<div class="paragraph">
<p>The set of interceptor bindings for a producer method is not used to associate interceptors with the return value of the producer method.</p>
</div>
<div class="paragraph">
<p>Since CDI 2.0 it is possible to apply interceptors programmatically to the return value of a producer method, with the <code>InterceptionFactory</code> interface as defined in <a href="#interception_factory">The <code>InterceptionFactory</code> interface</a>.</p>
</div>
<div class="paragraph">
<p>If a managed bean has a class-level or method-level interceptor binding, the managed bean must be a proxyable bean type, as defined in <a href="#unproxyable">Unproxyable bean types</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="enabled_interceptors"><a class="anchor" href="#enabled_interceptors"></a>9.4. Interceptor enablement and ordering</h3>
<div class="paragraph">
<p>This specification extends the Java Interceptors specification and defines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>support for enabling interceptors only for a bean archive, as defined by Contexts and Dependency Injection 1.0, and</p>
</li>
<li>
<p>the ability to override the interceptor order using the portable extension SPI, defined in <a href="#after_type_discovery"><code>AfterTypeDiscovery</code> event</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An interceptor may be explicitly enabled for a bean archive by listing its class under the <code>&lt;interceptors&gt;</code> element of the <code>beans.xml</code> file of the bean archive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_3_0.xsd</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">version</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
   <span class="tag">&lt;interceptors&gt;</span>
      <span class="tag">&lt;class&gt;</span>com.acme.myfwk.TransactionInterceptor<span class="tag">&lt;/class&gt;</span>
      <span class="tag">&lt;class&gt;</span>com.acme.myfwk.LoggingInterceptor<span class="tag">&lt;/class&gt;</span>
   <span class="tag">&lt;/interceptors&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The order of the interceptor declarations determines the interceptor ordering. Interceptors which occur earlier in the list are called first.</p>
</div>
<div class="paragraph">
<p>Each child <code>&lt;class&gt;</code> element must specify the name of an interceptor class.
If there is no class with the specified name, or if the class with the specified name is not an interceptor class, the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>If the same class is listed twice under the <code>&lt;interceptors&gt;</code> element, the container automatically detects the problem and treats it as a deployment problem.</p>
</div>
<div class="paragraph">
<p>Interceptors enabled using <code>@Priority</code> are called before interceptors enabled using <code>beans.xml</code>.</p>
</div>
<div class="paragraph">
<p>An interceptor is said to be <strong>enabled</strong> if it is enabled in at least one bean archive or is listed in the final list of interceptors for the application, as defined in <a href="#after_type_discovery"><code>AfterTypeDiscovery</code> event</a>.</p>
</div>
<div class="paragraph">
<p>If an interceptor declares any scope other than <code>@Dependent</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If an interceptor is enabled for the application and for the bean archive, then the enablement from the bean archive is ignored by the container.  The interceptor will only be executed once based on the <code>@Priority</code> annotation&#8217;s invocation chain.</p>
</div>
</div>
<div class="sect2">
<h3 id="interceptor_resolution"><a class="anchor" href="#interceptor_resolution"></a>9.5. Interceptor resolution</h3>
<div class="paragraph">
<p>This specification extends the Java Interceptors specification and defines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the effect of applying <code>@Nonbinding</code> to an interceptor binding member, and</p>
</li>
<li>
<p>how the interceptor bindings of a custom implementation of the <code>Interceptor</code> interface are determined.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If any interceptor binding has a member annotated <code>@jakarta.enterprise.util.Nonbinding</code>, the member is ignored when performing interceptor resolution, and the method does not need to have the same annotation member value.</p>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>Interceptor</code> interface defined in <a href="#interceptor">The <code>Interceptor</code> interface</a>, the container calls <code>getInterceptorBindings()</code> to determine the interceptor bindings of the interceptor and <code>intercepts()</code> to determine if the interceptor intercepts a given kind of lifecycle callback or business method.</p>
</div>
<div class="paragraph">
<p>A custom implementation of the <code>Interceptor</code> interface may implement the <a href="#prioritized"><code>Prioritized</code> interface</a> to be enabled for the entire application with a priority value.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="events"><a class="anchor" href="#events"></a>10. Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Beans may produce and consume events.
This facility allows beans to interact in a completely decoupled fashion, with no compile-time dependency between the interacting beans.
Most importantly, it allows stateful beans in one architectural tier of the application to synchronize their internal state with state changes that occur in a different tier.</p>
</div>
<div class="paragraph">
<p>An event comprises:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A Java object - the <em>event object</em></p>
</li>
<li>
<p>A set of instances of qualifier types - the <em>event qualifiers</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The event object acts as a payload, to propagate state from producer to consumer.
The event qualifiers act as topic selectors, allowing the consumer to narrow the set of events it observes.</p>
</div>
<div class="paragraph">
<p>An <em>observer method</em> acts as event consumer, observing events of a specific type - the <em>observed event type</em>  - with a specific set of qualifiers - the <em>observed event qualifiers</em>.
An observer method will be notified of an event if the event object is assignable to the observed event type, and if the set of observed event qualifiers is a subset of all the event qualifiers of the event.</p>
</div>
<div class="sect2">
<h3 id="event_types_and_qualifier_types"><a class="anchor" href="#event_types_and_qualifier_types"></a>10.1. Event types and qualifier types</h3>
<div class="paragraph">
<p>An event object is an instance of a concrete Java class with no unresolvable type variables.
The <em>event types</em> of the event include all superclasses and interfaces of the runtime class of the event object.</p>
</div>
<div class="paragraph">
<p>An event type may not contain an unresolvable type variable. A wildcard type is not considered an unresolvable type variable.</p>
</div>
<div class="paragraph">
<p>An event qualifier type is just an ordinary qualifier type as specified in <a href="#defining_qualifier_types">Defining new qualifier types</a>, typically defined as <code>@Target({METHOD, FIELD, PARAMETER, TYPE})</code> or <code>@Target({FIELD, PARAMETER})</code>.</p>
</div>
<div class="paragraph">
<p>Every event has the qualifier <code>@jakarta.enterprise.inject.Any</code>, even if it does not explicitly declare this qualifier.</p>
</div>
<div class="paragraph">
<p>Any Java type may be an observed event type.</p>
</div>
</div>
<div class="sect2">
<h3 id="firing_events"><a class="anchor" href="#firing_events"></a>10.2. Firing events</h3>
<div class="paragraph">
<p>Beans fire events via an instance of the <code>jakarta.enterprise.event.Event</code> interface, which may be injected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="predefined-type">Event</span>&lt;LoggedInEvent&gt; loggedInEvent;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any combination of qualifiers may be specified at the injection point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@Admin</span> <span class="predefined-type">Event</span>&lt;LoggedInEvent&gt; adminLoggedInEvent;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or the application may specify qualifiers dynamically:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="predefined-type">Event</span>&lt;LoggedInEvent&gt; loggedInEvent;
...
LoggedInEvent event = <span class="keyword">new</span> LoggedInEvent(user);
<span class="keyword">if</span> ( user.isAdmin() ) {
    loggedInEvent.select( <span class="keyword">new</span> AdminQualifier() ).fire(event);
}
<span class="keyword">else</span> {
    loggedInEvent.fire(event);
    loggedInEvent.fireAsync(event);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the event sometimes has the qualifier <code>@Admin</code>, depending upon the value of <code>user.isAdmin()</code>.
It is first fired synchronously with <code>fire()</code> then asynchronously with <code>fireAsync()</code>.</p>
</div>
<div class="sect3">
<h4 id="firing_events_synchronously"><a class="anchor" href="#firing_events_synchronously"></a>10.2.1. Firing events synchronously</h4>
<div class="paragraph">
<p>The method <code>fire()</code> accepts an event object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> login() {
    ...
    loggedInEvent.fire( <span class="keyword">new</span> LoggedInEvent(user) );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Event fired with the <code>fire()</code> method is fired synchronously.
All the resolved synchronous observers (as defined in <a href="#observer_resolution">Observer resolution</a>) are called in the thread in which <code>fire()</code> was called.
A synchronous observer notification blocks the calling thread until it completes.</p>
</div>
</div>
<div class="sect3">
<h4 id="firing_events_asynchronously"><a class="anchor" href="#firing_events_asynchronously"></a>10.2.2. Firing events asynchronously</h4>
<div class="paragraph">
<p>Events may also be fired asynchronously using one of the methods <code>fireAsync()</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="predefined-type">Event</span>&lt;LoggedInEvent&gt; loggedInEvent;

<span class="directive">public</span> <span class="type">void</span> login() {
    ...
    loggedInEvent.fireAsync( <span class="keyword">new</span> LoggedInEvent(user) );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Event fired with the <code>fireAsync()</code> method is fired asynchronously.
All the resolved asynchronous observers (as defined in <a href="#observer_resolution">Observer resolution</a>) are called in one or more different threads.</p>
</div>
<div class="paragraph">
<p>Method <code>fireAsync()</code> returns immediately.</p>
</div>
</div>
<div class="sect3">
<h4 id="event"><a class="anchor" href="#event"></a>10.2.3. The <code>Event</code> interface</h4>
<div class="paragraph">
<p>The <code>Event</code> interface provides a method for firing events with a specified combination of type and qualifiers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Event</span>&lt;T&gt; {

    <span class="directive">public</span> <span class="type">void</span> fire(T event);
    <span class="directive">public</span> &lt;U <span class="directive">extends</span> T&gt; CompletionStage&lt;U&gt; fireAsync(U event);
    <span class="directive">public</span> &lt;U <span class="directive">extends</span> T&gt; CompletionStage&lt;U&gt; fireAsync(U event, NotificationOptions options);

    <span class="directive">public</span> <span class="predefined-type">Event</span>&lt;T&gt; select(<span class="predefined-type">Annotation</span>... qualifiers);
    <span class="directive">public</span> &lt;U <span class="directive">extends</span> T&gt; <span class="predefined-type">Event</span>&lt;U&gt; select(<span class="predefined-type">Class</span>&lt;U&gt; subtype, <span class="predefined-type">Annotation</span>... qualifiers);
    <span class="directive">public</span> &lt;U <span class="directive">extends</span> T&gt; <span class="predefined-type">Event</span>&lt;U&gt; select(TypeLiteral&lt;U&gt; subtype, <span class="predefined-type">Annotation</span>... qualifiers);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For an injected <code>Event</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <em>specified type</em> is the type parameter specified at the injection point, and</p>
</li>
<li>
<p>the <em>specified qualifiers</em> are the qualifiers specified at the injection point.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, this injected <code>Event</code> has specified type <code>LoggedInEvent</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="predefined-type">Event</span>&lt;LoggedInEvent&gt; any;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>select()</code> method returns a child <code>Event</code> for a given specified type and additional specified qualifiers.
If no specified type is given, the specified type is the same as the parent.</p>
</div>
<div class="paragraph">
<p>For example, this child <code>Event</code> has required type <code>AdminLoggedInEvent</code> and additional specified qualifier <code>@Admin</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Event</span>&lt;AdminLoggedInEvent&gt; admin = any.select(
            AdminLoggedInEvent.class,
            <span class="keyword">new</span> AdminQualifier() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the specified type contains a type variable, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If two instances of the same non repeating qualifier type are passed to <code>select()</code>, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If an instance of an annotation that is not a qualifier type is passed to <code>select()</code>, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>The methods <code>fire()</code> and <code>fireAsync()</code> fire an event with the specified qualifiers and notify observers, as defined by <a href="#observer_notification">Observer notification</a>.
If the container is unable to resolve the parameterized type of the event object, it uses the specified type to infer the parameterized type of the event types.</p>
</div>
<div class="paragraph">
<p>The method <code>fireAsync()</code> may be called with a <code>NotificationOptions</code> object to configure the observer methods notification, e.g. to specify an <code>Executor</code> object to be used for asynchronous delivery.
The container is permitted to define other non-portable notification options.</p>
</div>
<div class="paragraph">
<p>The following elements are container specific:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the default <code>Executor</code> used by the container when <code>fireAsync()</code> is called without specifying an <code>Executor</code>,</p>
</li>
<li>
<p>the <code>CompletionStage</code> returned by <code>fireAsync</code> methods, and</p>
</li>
<li>
<p>all dependent stages of this initial CompletionStage.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the runtime type of the event object contains an unresolvable type variable, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If the runtime type of the event object is assignable to the type of a container lifecycle event, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="builtin_event"><a class="anchor" href="#builtin_event"></a>10.2.4. The built-in <code>Event</code></h4>
<div class="paragraph">
<p>The container must provide a built-in bean with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Event&lt;X&gt;</code> in its set of bean types, for every Java type <code>X</code> that does not contain a type variable,</p>
</li>
<li>
<p>every event qualifier type in its set of qualifier types,</p>
</li>
<li>
<p>scope <code>@Dependent</code>,</p>
</li>
<li>
<p>no bean name, and</p>
</li>
<li>
<p>an implementation provided automatically by the container.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If an injection point of raw type <code>Event</code> is defined, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>The built-in implementation must be a passivation capable dependency, as defined in <a href="#passivation_capable_dependency">Passivation capable dependencies</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="observer_resolution"><a class="anchor" href="#observer_resolution"></a>10.3. Observer resolution</h3>
<div class="paragraph">
<p>The process of matching an event to its observer methods is called <em>observer resolution</em>.
The container considers event type and qualifiers when resolving observers.</p>
</div>
<div class="paragraph">
<p>Observer resolution usually occurs at runtime.</p>
</div>
<div class="paragraph">
<p>An event is delivered to an observer method if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The observer method belongs to an enabled bean.</p>
</li>
<li>
<p>An event type is assignable to the observed event type, taking type parameters into consideration.</p>
</li>
<li>
<p>The observer method has no event qualifiers or has a subset of the event qualifiers.
An observer method has an event qualifier if it has an observed event qualifier with (a) the same type and (b) the same annotation member value for each member which is not annotated <code>@jakarta.enterprise.util.Nonbinding</code>.</p>
</li>
<li>
<p>Either the event is not a container lifecycle event, as defined in <a href="#init_events">Container lifecycle events</a>, or the observer method belongs to an extension.</p>
</li>
<li>
<p>The event is fired synchronously and the observer is a synchronous observer as defined in <a href="#observes">Declaring an observer method</a>.</p>
</li>
<li>
<p>The event is fired asynchronously and the observer is an asynchronous observer as defined in <a href="#observes">Declaring an observer method</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the runtime type of the event object contains an unresolvable type variable, the container must throw an <code>IllegalArgumentException</code>.</p>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>ObserverMethod</code> interface defined in <a href="#observer_method">The <code>ObserverMethod</code> interface</a>, the container must call <code>getObservedType()</code> and <code>getObservedQualifiers()</code> to determine the observed event type and qualifiers, and <code>isAsync()</code> to determine whether the observer is asynchronous or synchronous.</p>
</div>
<div class="sect3">
<h4 id="observers_assignability"><a class="anchor" href="#observers_assignability"></a>10.3.1. Assignability of type variables, raw and parameterized types</h4>
<div class="paragraph">
<p>An event type is considered assignable to a type variable if the event type is assignable to the upper bound, if any.</p>
</div>
<div class="paragraph">
<p>A parameterized event type is considered assignable to a raw observed event type if the raw types are identical.</p>
</div>
<div class="paragraph">
<p>A parameterized event type is considered assignable to a parameterized observed event type if they have identical raw type and for each parameter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the observed event type parameter is an actual type with identical raw type to the event type parameter, and, if the type is parameterized, the event type parameter is assignable to the observed event type parameter according to these rules, or</p>
</li>
<li>
<p>the observed event type parameter is a wildcard and the event type parameter is assignable to the upper bound, if any, of the wildcard and assignable from the lower bound, if any, of the wildcard, or</p>
</li>
<li>
<p>the observed event type parameter is a type variable and the event type parameter is assignable to the upper bound, if any, of the type variable.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="event_qualifier_types_with_members"><a class="anchor" href="#event_qualifier_types_with_members"></a>10.3.2. Event qualifier types with members</h4>
<div class="paragraph">
<p>As usual, the qualifier type may have annotation members:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Qualifier</span>
<span class="annotation">@Target</span>(PARAMETER)
<span class="annotation">@Retention</span>(RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> <span class="predefined-type">Role</span> {
    <span class="predefined-type">String</span> value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consider the following event:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="predefined-type">Event</span>&lt;LoggedInEvent&gt; loggedInEvent;
...
public <span class="type">void</span> login() {
    <span class="directive">final</span> User user = ...;
    loggedInEvent.select(<span class="keyword">new</span> RoleQualifier() { <span class="directive">public</span> <span class="predefined-type">String</span> value() { <span class="keyword">return</span> user.getRole(); } }).fire(<span class="keyword">new</span> LoggedInEvent(user));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where <code>RoleQualifier</code> is an implementation of the qualifier type <code>Role</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">RoleQualifier</span>
        <span class="directive">extends</span> AnnotationLiteral&lt;<span class="predefined-type">Role</span>&gt;
        <span class="directive">implements</span> <span class="predefined-type">Role</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the following observer method will always be notified of the event:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterLogin(<span class="annotation">@Observes</span> LoggedInEvent event) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whereas this observer method may or may not be notified, depending upon the value of <code>user.getRole()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterAdminLogin(<span class="annotation">@Observes</span> <span class="annotation">@Role</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">admin</span><span class="delimiter">&quot;</span></span>) LoggedInEvent event) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As usual, the container uses <code>equals()</code> to compare event qualifier type member values.</p>
</div>
</div>
<div class="sect3">
<h4 id="multiple_event_qualifiers"><a class="anchor" href="#multiple_event_qualifiers"></a>10.3.3. Multiple event qualifiers</h4>
<div class="paragraph">
<p>An event parameter may have multiple qualifiers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterDocumentUpdatedByAdmin(<span class="annotation">@Observes</span> <span class="annotation">@Updated</span> <span class="annotation">@ByAdmin</span> <span class="predefined-type">Document</span> doc) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then this observer method will be notified if the set of observer qualifiers is a subset of the fired event&#8217;s qualifiers or an empty set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="predefined-type">Event</span>&lt;<span class="predefined-type">Document</span>&gt; documentEvent;
...
documentEvent.select(<span class="keyword">new</span> UpdatedQualifier(), <span class="keyword">new</span> ByAdminQualifier(), <span class="keyword">new</span> ClarificationQualifier()).fire(document);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example the event is fired with <code>@ByAdmin</code>, <code>@Updated</code>, and <code>@Clarification</code> qualifiers. The observer qualifiers are <code>@Updated</code> and <code>@ByAdmin</code>.
Observer qualifiers therefore form a subset of event qualifiers and the observer will be notified.</p>
</div>
<div class="paragraph">
<p>Other, less specific, observers will also be notified of this event:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterDocumentUpdated(<span class="annotation">@Observes</span> <span class="annotation">@Updated</span> <span class="predefined-type">Document</span> doc) { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterDocumentEvent(<span class="annotation">@Observes</span> <span class="predefined-type">Document</span> doc) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand, following observer will not be notified as slightly different behaviour applies to observers with <code>@Default</code> qualifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterDocumentDefaultEvent(<span class="annotation">@Observes</span> <span class="annotation">@Default</span> <span class="predefined-type">Document</span> doc) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such observer will only be notified for events having either no qualifiers or only <code>@Default</code> qualifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="predefined-type">Event</span>&lt;<span class="predefined-type">Document</span>&gt; documentEvent;
<span class="annotation">@Inject</span> <span class="annotation">@Default</span> <span class="predefined-type">Event</span>&lt;<span class="predefined-type">Document</span>&gt; documentDefaultEvent;
...
documentEvent.fire(document);
documentDefaultEvent.fire(document);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="observer_methods"><a class="anchor" href="#observer_methods"></a>10.4. Observer methods</h3>
<div class="paragraph">
<p>An observer method allows the application to receive and respond to event notifications.</p>
</div>
<div class="paragraph">
<p>An observer method is a non-abstract method of a managed bean class or of an extension, as defined in <a href="#init_events">Container lifecycle events</a>.
An observer method may be either static or non-static.</p>
</div>
<div class="paragraph">
<p>There may be arbitrarily many observer methods with the same event parameter type and qualifiers.</p>
</div>
<div class="paragraph">
<p>A bean (or extension) may declare multiple observer methods.</p>
</div>
<div class="sect3">
<h4 id="observer_method_event_parameter"><a class="anchor" href="#observer_method_event_parameter"></a>10.4.1. Event parameter of an observer method</h4>
<div class="paragraph">
<p>Each observer method must have exactly one <em>event parameter</em>, of the same type as the event type it observes.
When searching for observer methods for an event, the container considers the type and qualifiers of the event parameter.</p>
</div>
<div class="paragraph">
<p>If the event parameter does not explicitly declare any qualifier, the observer method observes events with no qualifier.</p>
</div>
<div class="paragraph">
<p>The event parameter type may contain a type variable or wildcard.</p>
</div>
<div class="paragraph">
<p>The event parameter may be an array type whose component type contains a type variable or a wildcard.</p>
</div>
<div class="paragraph">
<p>Modifications made to the event parameter in an observer method are propagated to following observers.
The container is not required to guarantee a consistent state for an event parameter modified by asynchronous observers.</p>
</div>
</div>
<div class="sect3">
<h4 id="observes"><a class="anchor" href="#observes"></a>10.4.2. Declaring an observer method</h4>
<div class="paragraph">
<p>An observer method may be declared by annotating a parameter <code>@jakarta.enterprise.event.Observes</code> or <code>@jakarta.enterprise.event.ObservesAsync</code> of a default-access, public, protected or private method.
That parameter is the event parameter.
The declared type of the parameter is the observed event type.</p>
</div>
<div class="paragraph">
<p>If <code>@Observes</code> is used the observer method is a synchronous observer method.</p>
</div>
<div class="paragraph">
<p>If <code>@ObservesAsync</code> is used the observer method is an asynchronous observer method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterLogin(<span class="annotation">@Observes</span> LoggedInEvent event) { ... }

<span class="directive">public</span> <span class="type">void</span> asyncAfterLogin(<span class="annotation">@ObservesAsync</span> LoggedInEvent event) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a method has more than one parameter annotated <code>@Observes</code> or <code>@ObservesAsync</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If a method has a parameter annotated <code>@Observes</code> and <code>@ObservesAsync</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>Observed event qualifiers may be declared by annotating the event parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterLogin(<span class="annotation">@Observes</span> <span class="annotation">@Admin</span> LoggedInEvent event) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an observer method is annotated <code>@Produces</code> or <code>@Inject</code> or has a parameter annotated <code>@Disposes</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>Interceptors and decorators may not declare observer methods.
If an interceptor or decorator has a method with a parameter annotated <code>@Observes</code> or <code>@ObservesAsync</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>In addition to the event parameter, observer methods may declare additional parameters, which may declare qualifiers.
These additional parameters are injection points.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterLogin(<span class="annotation">@Observes</span> LoggedInEvent event, <span class="annotation">@Manager</span> User user, <span class="predefined-type">Logger</span> log) { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="event_metadata"><a class="anchor" href="#event_metadata"></a>10.4.3. The <code>EventMetadata</code> interface</h4>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.EventMetadata</code> provides access to metadata about an observed event.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">EventMetadata</span> {
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Annotation</span>&gt; getQualifiers();
    <span class="directive">public</span> InjectionPoint getInjectionPoint();
    <span class="directive">public</span> <span class="predefined-type">Type</span> getType();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getQualifiers()</code> returns the set of qualifiers with which the event was fired.</p>
</li>
<li>
<p><code>getInjectionPoint()</code> returns the <code>InjectionPoint</code> from which this event payload was fired, or <code>null</code> if it was fired from <code>BeanManager.fireEvent(&#8230;&#8203;)</code>.</p>
</li>
<li>
<p><code>getType()</code> returns the type representing runtime class of the event object with type variables resolved.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container must provide a bean with scope <code>@Dependent</code>, bean type <code>EventMetadata</code> and qualifier <code>@Default</code>, allowing observer methods to obtain information about the events they observe.</p>
</div>
<div class="paragraph">
<p>If an injection point of type <code>EventMetadata</code> and qualifier <code>@Default</code> which is not a parameter of an observer method exists, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> afterLogin(<span class="annotation">@Observes</span> LoggedInEvent event, EventMetadata metadata) { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="conditional_observer_methods"><a class="anchor" href="#conditional_observer_methods"></a>10.4.4. Conditional observer methods</h4>
<div class="paragraph">
<p>A <em>conditional observer method</em> is an observer method which is notified of an event only if an instance of the bean that defines the observer method already exists in the current context.</p>
</div>
<div class="paragraph">
<p>A conditional observer method may be declared by specifying <code>notifyObserver=IF_EXISTS</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> refreshOnDocumentUpdate(<span class="annotation">@Observes</span>(notifyObserver=IF_EXISTS) <span class="annotation">@Updated</span> <span class="predefined-type">Document</span> doc) { ... }

<span class="directive">public</span> <span class="type">void</span> asyncRefreshOnDocumentUpdate(<span class="annotation">@ObservesAsync</span>(notifyObserver=IF_EXISTS) <span class="annotation">@Updated</span> <span class="predefined-type">Document</span> doc) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Beans with scope <code>@Dependent</code> may not have conditional observer methods.
If a bean with scope <code>@Dependent</code> has an observer method declared <code>notifyObserver=IF_EXISTS</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>The enumeration <code>jakarta.enterprise.event.Reception</code> identifies the possible values of <code>notifyObserver</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">enum</span> Reception { IF_EXISTS, ALWAYS }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transactional_observer_methods"><a class="anchor" href="#transactional_observer_methods"></a>10.4.5. Transactional observer methods</h4>
<div class="paragraph">
<p><em>Transactional observer methods</em> are observer methods which receive event notifications during the before or after completion phase of the transaction in which the event was fired.
If no transaction is in progress when the event is fired, they are notified at the same time as other observers.</p>
</div>
<div class="paragraph">
<p>If the transaction is in progress, but <code>jakarta.transaction.Synchronization</code> callback cannot be registered due to the transaction being already marked for rollback or in state where <code>jakarta.transaction.Synchronization</code> callbacks cannot be registered, the <em>before completion</em>, <em>after completion</em> and <em>after failure</em> observer methods are notified at the same time as other observers, but <em>after_success</em> observer methods get skipped.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>before completion</em> observer method is called during the before completion phase of the transaction.</p>
</li>
<li>
<p>An <em>after completion</em> observer method is called during the after completion phase of the transaction.</p>
</li>
<li>
<p>An <em>after success</em> observer method is called during the after completion phase of the transaction, only when the transaction completes successfully.</p>
</li>
<li>
<p>An <em>after failure</em> observer method is called during the after completion phase of the transaction, only when the transaction fails.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The enumeration <code>jakarta.enterprise.event.TransactionPhase</code> identifies the kind of transactional observer method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">enum</span> TransactionPhase {
    IN_PROGRESS,
    BEFORE_COMPLETION,
    AFTER_COMPLETION,
    AFTER_FAILURE,
    AFTER_SUCCESS
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A transactional observer method may be declared by specifying any value other than <code>IN_PROGRESS</code> for <code>during</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> onDocumentUpdate(<span class="annotation">@Observes</span>(during=AFTER_SUCCESS) <span class="annotation">@Updated</span> <span class="predefined-type">Document</span> doc) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Asynchronous observer cannot be declared transactional.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="observer_notification"><a class="anchor" href="#observer_notification"></a>10.5. Observer notification</h3>
<div class="paragraph">
<p>When an event is fired by the application, the container must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>determine the observer methods for that event according to the rules of observer resolution defined by <a href="#observer_resolution">Observer resolution</a>, then,</p>
</li>
<li>
<p>for each observer method, either invoke the observer method immediately, or register the observer method for later invocation during the transaction completion phase, using a JTA <code>Synchronization</code>.</p>
</li>
<li>
<p>honor the priority of observer methods as defined in <a href="#observer_ordering">Observer ordering</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container calls observer methods as defined in <a href="#observers_method_invocation">Invocation of observer methods</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the observer method is a transactional observer method and there is currently a JTA transaction in progress, the container calls the observer method during the appropriate transaction completion phase.</p>
</li>
<li>
<p>If there is no context active for the scope to which the bean declaring the observer method belongs, then the observer method should not be called.</p>
</li>
<li>
<p>Otherwise, the container calls the observer immediately.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any observer method called before completion of a transaction may call <code>setRollbackOnly()</code> to force a transaction rollback.
An observer method may not directly initiate, commit or rollback JTA transactions.</p>
</div>
<div class="paragraph">
<p>Observer methods may throw exceptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the observer method is a transactional observer method, any exception is caught and logged by the container.</p>
</li>
<li>
<p>If the observer method is asynchronous, the exception aborts processing of the observer but not of the event.
Exception management during an asynchronous event is defined in <a href="#async_exception">Handling multiple exceptions thrown during an asynchronous event</a>.</p>
</li>
<li>
<p>Otherwise, the exception aborts processing of the event.
No other observer methods of that event will be called.
The <code>BeanManager.fireEvent()</code> or <code>Event.fire()</code> method rethrows the exception.
If the exception is a checked exception, it is wrapped and rethrown as an (unchecked) <code>ObserverException</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a custom implementation of the <code>ObserverMethod</code> interface defined in <a href="#observer_method">The <code>ObserverMethod</code> interface</a>, the container must call <code>getTransactionPhase()</code> to determine if the observer method is transactional observer method, and <code>notify()</code> which accepts <code>jakarta.enterprise.inject.spi.EventContext</code> to invoke the method.</p>
</div>
<div class="sect3">
<h4 id="async_exception"><a class="anchor" href="#async_exception"></a>10.5.1. Handling multiple exceptions thrown during an asynchronous event</h4>
<div class="paragraph">
<p>If an event is asynchronous, and an exception is thrown by any of its notified observers, the <code>CompletionStage</code> returned by <code>fireAsync</code> will complete exceptionally with <code>java.util.concurrent.CompletionException</code> exception.
<code>CompletionException</code> contains all exceptions thrown by observers as suppressed exceptions.
They can be accessed as an array of <code>throwable</code> with the <code>getSuppressed</code> method.</p>
</div>
<div class="paragraph">
<p>It can be handled with one of the <code>CompletionStage</code> methods related to exceptions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">myEvent.fireAsync(anEventObject)
       .handle((ok, ex) -&gt; {
           <span class="keyword">if</span> (ok != <span class="predefined-constant">null</span>) {
               <span class="keyword">return</span> ok;
           } <span class="keyword">else</span> {
             <span class="keyword">for</span> (<span class="predefined-type">Throwable</span> t : ex.getSuppressed()) {
                      ...
             }
              ...
           } });</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no exception is thrown by observers then the resulting CompletionStage is completed normally with the event object.</p>
</div>
</div>
<div class="sect3">
<h4 id="observer_ordering"><a class="anchor" href="#observer_ordering"></a>10.5.2. Observer ordering</h4>
<div class="paragraph">
<p>Before the actual observer notification, the container determines an order in which the observer methods for a certain event are invoked.
The priority of an observer method may be declared by annotating the event parameter with <code>@Priority</code> annotation.
If a <code>@Priority</code> annotation is declared on an event parameter of an asynchronous observer method, non-portable behavior results.
If no <code>@Priority</code> annotation is specified, the default priority <code>jakarta.interceptor.Interceptor.Priority.APPLICATION + 500</code> is assumed.
Observers with smaller priority values are called first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> afterLogin(<span class="annotation">@Observes</span> <span class="annotation">@Priority</span>(jakarta.interceptor.Interceptor.Priority.APPLICATION) LoggedInEvent event) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The order of more than one observer with the same priority is undefined and the observer methods are notified therefore in a non predictable order.</p>
</div>
</div>
<div class="sect3">
<h4 id="observer_method_invocation_context"><a class="anchor" href="#observer_method_invocation_context"></a>10.5.3. Observer method invocation context</h4>
<div class="paragraph">
<p>The transaction context and lifecycle contexts active when an observer method is invoked depend upon what kind of observer method it is.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the observer method is asynchronous, it is called in a new lifecycle contexts and a new transaction context.
As specified in <a href="#builtin_contexts">Context management for built-in scopes</a>, contexts associated with built-in normal scope don&#8217;t propagate across asynchronous observers.</p>
</li>
<li>
<p>If the observer method is a before completion transactional observer method, it is called within the context of the transaction that is about to complete and with the same lifecycle contexts.</p>
</li>
<li>
<p>Otherwise, if the observer method is any other kind of transactional observer method, it is called in an unspecified transaction context, but with the same lifecycle contexts as the transaction that just completed.</p>
</li>
<li>
<p>Otherwise, the observer method is called in the same transaction context and lifecycle contexts as the invocation of <code>Event.fire()</code> or <code>BeanManager.fireEvent()</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spi"><a class="anchor" href="#spi"></a>11. Portable extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A portable extension may integrate with the container by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Providing its own beans, interceptors and decorators to the container</p>
</li>
<li>
<p>Injecting dependencies into its own objects using the dependency injection service</p>
</li>
<li>
<p>Providing a context implementation for a custom scope</p>
</li>
<li>
<p>Augmenting or overriding the annotation-based metadata with metadata from some other source</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="bean"><a class="anchor" href="#bean"></a>11.1. The <code>Bean</code> interface</h3>
<div class="paragraph">
<p>The <code>BeanAttributes</code> interface exposes the basic attributes of a bean.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">BeanAttributes</span>&lt;T&gt; {
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Type</span>&gt; getTypes();
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Annotation</span>&gt; getQualifiers();
    <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; getScope();
    <span class="directive">public</span> <span class="predefined-type">String</span> getName();
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt;&gt; getStereotypes();
    <span class="directive">public</span> <span class="type">boolean</span> isAlternative();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getTypes()</code>, <code>getQualifiers()</code>, <code>getScope()</code>, <code>getName()</code> and <code>getStereotypes()</code> must return the bean types, qualifiers, scope type, bean name and stereotypes of the bean, as defined in <a href="#concepts">Concepts</a>.</p>
</li>
<li>
<p><code>isAlternative()</code> must return <code>true</code> if the bean is an alternative, and <code>false</code> otherwise.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.Bean</code> defines everything the container needs to manage instances of a certain bean.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Bean</span>&lt;T&gt; <span class="directive">extends</span> Contextual&lt;T&gt;, BeanAttributes&lt;T&gt; {
    <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;?&gt; getBeanClass();
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;InjectionPoint&gt; getInjectionPoints();
    <span class="directive">public</span> <span class="type">boolean</span> isNullable();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getBeanClass()</code> returns the bean class of the managed bean or of the bean that declares the producer method or field.</p>
</li>
<li>
<p><code>getInjectionPoints()</code> returns a set of <code>InjectionPoint</code> objects, defined in <a href="#injection_point">Injection point metadata</a>, representing injection points of the bean, that will be validated by the container at initialization time.</p>
</li>
<li>
<p><code>isNullable()</code> is deprecated in CDI 1.1 and should be ignored by the container.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that implementations of <code>Bean</code> must also implement the inherited operations defined by the <code>Contextual</code> interface defined in <a href="#contextual">The <code>Contextual</code> interface</a>.</p>
</div>
<div class="paragraph">
<p>An instance of <code>Bean</code> must exist for every enabled bean.</p>
</div>
<div class="paragraph">
<p>A portable extension may add support for new kinds of beans beyond those defined by the this specification by implementing <code>Bean</code> and registering beans with the container, using the mechanism defined in <a href="#after_bean_discovery"><code>AfterBeanDiscovery</code> event</a>.</p>
</div>
<div class="paragraph">
<p>Custom implementations of <code>Bean</code> are encouraged to implement <code>PassivationCapable</code> and may be required to in later revisions of this specification.</p>
</div>
<div class="sect3">
<h4 id="decorator"><a class="anchor" href="#decorator"></a>11.1.1. The <code>Decorator</code> interface</h4>
<div class="paragraph">
<p>The <code>Bean</code> object for a decorator must implement the interface <code>jakarta.enterprise.inject.spi.Decorator</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Decorator</span>&lt;T&gt; <span class="directive">extends</span> Bean&lt;T&gt; {
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Type</span>&gt; getDecoratedTypes();
    <span class="directive">public</span> <span class="predefined-type">Type</span> getDelegateType();
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Annotation</span>&gt; getDelegateQualifiers();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getDecoratedTypes()</code> returns the decorated types of the decorator.</p>
</li>
<li>
<p><code>getDelegateType()</code> and <code>getDelegateQualifiers()</code> return the delegate type and qualifiers of the decorator.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An instance of <code>Decorator</code> exists for every enabled decorator.</p>
</div>
</div>
<div class="sect3">
<h4 id="interceptor"><a class="anchor" href="#interceptor"></a>11.1.2. The <code>Interceptor</code> interface</h4>
<div class="paragraph">
<p>The <code>Bean</code> object for an interceptor must implement <code>jakarta.enterprise.inject.spi.Interceptor</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Interceptor</span>&lt;T&gt; <span class="directive">extends</span> Bean&lt;T&gt; {
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Annotation</span>&gt; getInterceptorBindings();
    <span class="directive">public</span> <span class="type">boolean</span> intercepts(InterceptionType type);
    <span class="directive">public</span> <span class="predefined-type">Object</span> intercept(InterceptionType type, T instance, InvocationContext ctx) <span class="directive">throws</span> <span class="exception">Exception</span>;
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInterceptorBindings()</code> returns the interceptor bindings of the interceptor.</p>
</li>
<li>
<p><code>intercepts()</code> returns <code>true</code> if the interceptor intercepts the specified kind of lifecycle callback or method invocation, and <code>false</code> otherwise.</p>
</li>
<li>
<p><code>intercept()</code> invokes the specified kind of lifecycle callback or method invocation interception upon the given instance of the interceptor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An <code>InterceptionType</code> identifies the kind of lifecycle callback or business method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">enum</span> InterceptionType {
    AROUND_INVOKE, AROUND_CONSTRUCT, POST_CONSTRUCT, PRE_DESTROY, PRE_PASSIVATE, POST_ACTIVATE, AROUND_TIMEOUT
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An instance of <code>Interceptor</code> exists for every enabled interceptor.</p>
</div>
</div>
<div class="sect3">
<h4 id="observer_method"><a class="anchor" href="#observer_method"></a>11.1.3. The <code>ObserverMethod</code> interface</h4>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.ObserverMethod</code> defines everything the container needs to know about an observer method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ObserverMethod</span>&lt;T&gt; <span class="directive">extends</span> Prioritized {
    <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;?&gt; getBeanClass();
    <span class="directive">public</span> <span class="predefined-type">Type</span> getObservedType();
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Annotation</span>&gt; getObservedQualifiers();
    <span class="directive">public</span> Reception getReception();
    <span class="directive">public</span> TransactionPhase getTransactionPhase();
    <span class="directive">public</span> <span class="type">int</span> getPriority();
    <span class="directive">public</span> <span class="type">void</span> notify(T event);
    <span class="directive">public</span> <span class="type">void</span> notify(<span class="predefined-type">EventContext</span>&lt;T&gt; eventContext);
    <span class="directive">public</span> <span class="type">boolean</span> isAsync();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getBeanClass()</code> returns the class of the type that declares the observer method.</p>
</li>
<li>
<p><code>getObservedType()</code> and <code>getObservedQualifiers()</code> return the observed event type and qualifiers.</p>
</li>
<li>
<p><code>getReception()</code> returns <code>IF_EXISTS</code> for a conditional observer and <code>ALWAYS</code> otherwise.</p>
</li>
<li>
<p><code>getTransactionPhase()</code> returns the appropriate transaction phase for a transactional observer method or <code>IN_PROGRESS</code> otherwise.</p>
</li>
<li>
<p><code>getPriority()</code> this method inherited from <a href="#prioritized"><code>Prioritized</code> interface</a> returns the priority that will be used by the container to determine the notification order as defined in <a href="#observer_ordering">Observer ordering</a>.
If this method is not implemented the default priority <code>APPLICATION + 500</code> is assumed.</p>
</li>
<li>
<p><code>notify()</code> calls the observer method, as defined in <a href="#observer_notification">Observer notification</a>.</p>
</li>
<li>
<p><code>isAsync()</code> returns <code>true</code> if the method is an asynchronous observer method otherwise returns <code>false</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An instance of <code>ObserverMethod</code> must exist for every observer method of every enabled bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="prioritized"><a class="anchor" href="#prioritized"></a>11.1.4. The <code>Prioritized</code> interface</h4>
<div class="paragraph">
<p>CDI 2.0 introduced the prioritized interface to add programmatic priority to custom SPI implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Prioritized</span> {
    <span class="type">int</span> getPriority();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="injectiontarget"><a class="anchor" href="#injectiontarget"></a>11.2. The <code>Producer</code> and <code>InjectionTarget</code> interfaces</h3>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.Producer</code> provides a generic operation for producing an instance of a type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Producer</span>&lt;T&gt; {
    <span class="directive">public</span> T produce(CreationalContext&lt;T&gt; ctx);
    <span class="directive">public</span> <span class="type">void</span> dispose(T instance);
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;InjectionPoint&gt; getInjectionPoints();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a <code>Producer</code> that represents a class:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>produce()</code> calls the constructor annotated <code>@Inject</code> if it exists, or the constructor with no parameters otherwise, as defined in <a href="#instantiation">Injection using the bean constructor</a>, and returns the resulting instance. If the class has interceptors, <code>produce()</code> is responsible for building the interceptors and decorators of the instance.
The instance returned by <code>produce()</code> may be a proxy.</p>
</li>
<li>
<p><code>dispose()</code> does nothing.</p>
</li>
<li>
<p><code>getInjectionPoints()</code> returns the set of <code>InjectionPoint</code> objects representing all injected fields, bean constructor parameters and initializer method parameters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a <code>Producer</code> that represents a producer method or field:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>produce()</code> calls the producer method on, or accesses the producer field of, a contextual instance of the bean that declares the producer method, as defined in <a href="#producer_or_disposer_methods_invocation">Invocation of producer or disposer methods</a>.</p>
</li>
<li>
<p><code>dispose()</code> calls the disposer method, if any, on a contextual instance of the bean that declares the disposer method, as defined in <a href="#producer_or_disposer_methods_invocation">Invocation of producer or disposer methods</a>, or performs any additional required cleanup, if any, to destroy state associated with a resource.</p>
</li>
<li>
<p><code>getInjectionPoints()</code> returns the set of <code>InjectionPoint</code> objects representing all parameters of the producer method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The subinterface <code>jakarta.enterprise.inject.spi.InjectionTarget</code> provides operations for performing dependency injection and lifecycle callbacks on an instance of a type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">InjectionTarget</span>&lt;T&gt;
        <span class="directive">extends</span> Producer&lt;T&gt; {
    <span class="directive">public</span> <span class="type">void</span> inject(T instance, CreationalContext&lt;T&gt; ctx);
    <span class="directive">public</span> <span class="type">void</span> postConstruct(T instance);
    <span class="directive">public</span> <span class="type">void</span> preDestroy(T instance);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>inject()</code> performs dependency injection upon the given object.
The container sets the value of all injected fields, and calls all initializer methods, as defined in <a href="#fields_initializer_methods">Injection of fields and initializer methods</a>.</p>
</li>
<li>
<p><code>postConstruct()</code> calls the <code>@PostConstruct</code> callback, if it exists.</p>
</li>
<li>
<p><code>preDestroy()</code> calls the <code>@PreDestroy</code> callback, if it exists.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Implementations of <code>Producer</code> and <code>InjectionTarget</code> must ensure that the set of injection points returned by <code>getInjectionPoints()</code> are injected by <code>produce()</code> or <code>inject()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="beanmanager"><a class="anchor" href="#beanmanager"></a>11.3. The <code>BeanManager</code> object</h3>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.BeanManager</code> provides operations for obtaining contextual references for beans, along with many other operations of use to portable extensions.</p>
</div>
<div class="paragraph">
<p>The container provides a built-in bean with bean type <code>BeanManager</code>, scope <code>@Dependent</code> and qualifier <code>@Default</code>. The built-in implementation must be a passivation capable dependency, as defined in <a href="#passivation_capable_dependency">Passivation capable dependencies</a>.
Thus, any bean may obtain an instance of <code>BeanManager</code> by injecting it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> BeanManager manager;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, an exception is thrown if the following operations are called before the <code>AfterBeanDiscovery</code> event is fired:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getBeans(String)</code>,</p>
</li>
<li>
<p><code>getBeans(Type, Annotation&#8230;&#8203;)</code>,</p>
</li>
<li>
<p><code>getPassivationCapableBean(String)</code></p>
</li>
<li>
<p><code>resolve(Set)</code>,</p>
</li>
<li>
<p><code>resolveDecorators(Set, Annotation&#8230;&#8203;)</code>,</p>
</li>
<li>
<p><code>resolveInterceptors(InterceptionType, Annotation&#8230;&#8203;)</code>,</p>
</li>
<li>
<p><code>resolveObserverMethods(Object, Annotation&#8230;&#8203;)</code>,</p>
</li>
<li>
<p><code>validate(InjectionPoint)</code>,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and if the following operations are called before the <code>AfterDeploymentValidation</code> event is fired:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>createInstance()</code>,</p>
</li>
<li>
<p><code>getReference(Bean, Type, CreationalContext)</code>,</p>
</li>
<li>
<p><code>getInjectableReference(InjectionPoint, CreationalContext)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All other operations of BeanManager may be called at any time during the execution of the application.</p>
</div>
<div class="sect3">
<h4 id="provider"><a class="anchor" href="#provider"></a>11.3.1. Obtaining a reference to the CDI container</h4>
<div class="paragraph">
<p>Portable extensions and other objects sometimes interact directly with the container via programmatic API call.
The abstract <code>jakarta.enterprise.inject.spi.CDI</code> provides access to the <code>BeanManager</code> as well providing lookup of bean instances.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CDI</span>&lt;T&gt; <span class="directive">implements</span> Instance&lt;T&gt; {
   <span class="directive">public</span> <span class="directive">static</span> CDI&lt;<span class="predefined-type">Object</span>&gt; current() { ... }
   <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> setCDIProvider(CDIProvider provider);
   <span class="directive">public</span> <span class="directive">abstract</span> BeanManager getBeanManager();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A portable extension or other object may obtain a reference to the current container by calling <code>CDI.current()</code>.
<code>CDI.getBeanManager()</code> may be called at any time after the container fires the <code>BeforeBeanDiscovery</code> container lifecycle event until the container fires the <code>BeforeShutdown</code> container lifecycle event.
Other methods on <code>CDI</code> may be called after the application initialization is completed until the application shutdown starts.
If methods on <code>CDI</code> are called at any other time, non-portable behavior results.</p>
</div>
<div class="paragraph">
<p>CDI implements <code>jakarta.enterprise.inject.Instance</code> and therefore might be used to perform programmatic lookup as defined in <a href="#dynamic_lookup">The <code>Instance</code> interface</a>.
If no qualifier is passed to <code>CDI.select()</code> method, the <code>@Default</code> qualifier is assumed.</p>
</div>
<div class="paragraph">
<p>When <code>CDI.current()</code> is called, <code>getCDI()</code> method is called on <code>jakarta.enterprise.inject.spi.CDIProvider</code>.</p>
</div>
<div class="paragraph">
<p>The <code>CDIProvider</code> to use may be set by the application or container using the <code>setCDIProvider()</code> method.
If the <code>setCDIProvider()</code> has not been called, the service provider with highest priority of the service <code>jakarta.enterprise.inject.spi.CDIProvider</code> declared in META-INF/services is used.
The order of more than one <code>CDIProvider</code> with the same priority is undefined.
If no provider is available an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">CDIProvider</span> <span class="directive">extends</span> Prioritized {
   CDI&lt;<span class="predefined-type">Object</span>&gt; getCDI();
   <span class="keyword">default</span> <span class="type">int</span> getPriority();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getPriority()</code> method is inherited from <a href="#prioritized"><code>Prioritized</code> interface</a> and returns the priority for the <code>CDIProvider</code>.
If this method is not implemented the default priority <code>0</code> is assumed.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_contextual_reference"><a class="anchor" href="#bm_obtain_contextual_reference"></a>11.3.2. Obtaining a contextual reference for a bean</h4>
<div class="paragraph">
<p>The method <code>BeanManager.getReference()</code> returns a contextual reference for a given bean and bean type, as defined in <a href="#contextual_reference">Contextual reference for a bean</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Object</span> getReference(Bean&lt;?&gt; bean, <span class="predefined-type">Type</span> beanType, CreationalContext&lt;?&gt; ctx);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first parameter is the <code>Bean</code> object representing the bean.
The second parameter represents a bean type that must be implemented by any client proxy that is returned.
The third parameter is an instance of <code>CreationalContext</code> that may be used to destroy any object with scope <code>@Dependent</code> that is created.</p>
</div>
<div class="paragraph">
<p>If the given type is not a bean type of the given bean, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_injectable_reference"><a class="anchor" href="#bm_obtain_injectable_reference"></a>11.3.3. Obtaining an injectable reference</h4>
<div class="paragraph">
<p>The method <code>BeanManager.getInjectableReference()</code> returns an injectable reference for a given injection point, as defined in <a href="#injectable_reference">Injectable references</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Object</span> getInjectableReference(InjectionPoint ij, CreationalContext&lt;?&gt; ctx);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first parameter represents the target injection point.
The second parameter is an instance of <code>CreationalContext</code> that may be used to destroy any object with scope <code>@Dependent</code> that is created.</p>
</div>
<div class="paragraph">
<p>If the <code>InjectionPoint</code> represents a decorator delegate injection point, <code>getInjectableReference()</code> returns a delegate, as defined in <a href="#delegate_attribute">Decorator delegate injection points</a>.</p>
</div>
<div class="paragraph">
<p>If typesafe resolution results in an unsatisfied dependency, the container must throw an <code>UnsatisfiedResolutionException</code>. If typesafe resolution results in an unresolvable ambiguous dependency, the container must throw an <code>AmbiguousResolutionException</code>.</p>
</div>
<div class="paragraph">
<p>Implementations of <code>Bean</code> usually maintain a reference to an instance of <code>BeanManager</code>. When the <code>Bean</code> implementation performs dependency injection, it must obtain the contextual instances to inject by calling <code>BeanManager.getInjectableReference()</code>, passing an instance of <code>InjectionPoint</code> that represents the injection point and the instance of <code>CreationalContext</code> that was passed to <code>Bean.create()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_unmanaged_instance"><a class="anchor" href="#bm_obtain_unmanaged_instance"></a>11.3.4. Obtaining non-contextual instance</h4>
<div class="paragraph">
<p>A non-contextual instance can be obtained and injected from an <code>InjectionTarget</code>, however the <code>InjectionTarget</code> interface is designed to work on contextual instances.
A helper class, <code>Unmanaged</code> provides a set of methods optimized for working with non-contextual instances.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Unmanaged&lt;Foo&gt; unmanagedFoo = <span class="keyword">new</span> Unmanaged&lt;Foo&gt;(Foo.class);
UnmanagedInstance&lt;Foo&gt; fooInstance = unmanagedFoo.newInstance();
Foo foo = fooInstance.produce().inject().postConstruct().get();
... <span class="comment">// Use the foo instance</span>
fooInstance.preDestroy().dispose();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_creationalcontext"><a class="anchor" href="#bm_obtain_creationalcontext"></a>11.3.5. Obtaining a <code>CreationalContext</code></h4>
<div class="paragraph">
<p>An instance of <code>CreationalContext</code> for a certain instance of <code>Contextual</code> may be obtained by calling <code>BeanManager.createCreationalContext()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;T&gt; CreationalContext&lt;T&gt; createCreationalContext(Contextual&lt;T&gt; contextual);</code></pre>
</div>
</div>
<div class="paragraph">
<p>An instance of <code>CreationalContext</code> for a non-contextual object may be obtained by passing a null value to <code>createCreationalContext()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_bean_by_type"><a class="anchor" href="#bm_obtain_bean_by_type"></a>11.3.6. Obtaining a <code>Bean</code> by type</h4>
<div class="paragraph">
<p>The method <code>BeanManager.getBeans()</code> returns the set of beans which have the given required type and qualifiers and are available for injection in the module or library containing the class into which the <code>BeanManager</code> was injected or the class from whose JNDI environment namespace the <code>BeanManager</code> was obtained, according to the rules for candidates of typesafe resolution defined in <a href="#performing_typesafe_resolution">Performing typesafe resolution</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Set</span>&lt;Bean&lt;?&gt;&gt; getBeans(<span class="predefined-type">Type</span> beanType, <span class="predefined-type">Annotation</span>... qualifiers);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first parameter is a required bean type. The remaining parameters are required qualifiers.</p>
</div>
<div class="paragraph">
<p>If no qualifiers are passed to <code>getBeans()</code>, the default qualifier <code>@Default</code> is assumed.</p>
</div>
<div class="paragraph">
<p>If the given type represents a type variable, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If two instances of the same non repeating qualifier type are given, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If an instance of an annotation that is not a qualifier type is given, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_bean_by_name"><a class="anchor" href="#bm_obtain_bean_by_name"></a>11.3.7. Obtaining a <code>Bean</code> by name</h4>
<div class="paragraph">
<p>The method <code>BeanManager.getBeans()</code> which accepts a string returns the set of beans which have the given bean name and are available for injection in the module or library containing the class into which the <code>BeanManager</code> was injected or the class from whose JNDI environment namespace the <code>BeanManager</code> was obtained, according to the rules of name resolution defined in <a href="#name_resolution">Name resolution</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Set</span>&lt;Bean&lt;?&gt;&gt; getBeans(<span class="predefined-type">String</span> name);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameter is a bean name.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_passivation_capable_bean"><a class="anchor" href="#bm_obtain_passivation_capable_bean"></a>11.3.8. Obtaining a passivation capable bean by identifier</h4>
<div class="paragraph">
<p>The method <code>BeanManager.getPassivationCapableBean()</code> returns the <code>PassivationCapable</code> bean with the given identifier (see <a href="#passivation_capable">Passivation capable beans</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> Bean&lt;?&gt; getPassivationCapableBean(<span class="predefined-type">String</span> id);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_resolve_ambiguous_dep"><a class="anchor" href="#bm_resolve_ambiguous_dep"></a>11.3.9. Resolving an ambiguous dependency</h4>
<div class="paragraph">
<p>The method <code>BeanManager.resolve()</code> applies the ambiguous dependency resolution rules defined in <a href="#unsatisfied_and_ambig_dependencies">Unsatisfied and ambiguous dependencies</a> to a set of <code>Bean</code> s.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;X&gt; Bean&lt;? <span class="directive">extends</span> X&gt; resolve(<span class="predefined-type">Set</span>&lt;Bean&lt;? <span class="directive">extends</span> X&gt;&gt; beans);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the ambiguous dependency resolution rules fail (as defined in <a href="#unsatisfied_and_ambig_dependencies">Unsatisfied and ambiguous dependencies</a>, the container must throw an <code>AmbiguousResolutionException</code>.</p>
</div>
<div class="paragraph">
<p><code>BeanManager.resolve()</code> must return null if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>null is passed to <code>resolve()</code>, or</p>
</li>
<li>
<p>no beans are passed to <code>resolve()</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="bm_validate_ip"><a class="anchor" href="#bm_validate_ip"></a>11.3.10. Validating an injection point</h4>
<div class="paragraph">
<p>The <code>BeanManager.validate()</code> operation validates an injection point and throws an <code>InjectionException</code> if there is a deployment problem (for example, an unsatisfied or unresolvable ambiguous dependency) associated with the injection point.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> validate(InjectionPoint injectionPoint);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_fire_event"><a class="anchor" href="#bm_fire_event"></a>11.3.11. Firing an event</h4>
<div class="paragraph">
<p>The method <code>BeanManager.getEvent()</code> returns an instance of <code>Event</code> with specified type <code>java.lang.Object</code> and specified qualifier <code>@Default</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Event</span>&lt;<span class="predefined-type">Object</span>&gt; getEvent();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned instance can be used like a standard <code>Event</code> as described in <a href="#events">Events</a>.</p>
</div>
<div class="paragraph">
<p>The method <code>BeanManager.fireEvent()</code> is deprecated since version 2.0 of Contexts and Dependency Injection.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_observer_method_resolution"><a class="anchor" href="#bm_observer_method_resolution"></a>11.3.12. Observer method resolution</h4>
<div class="paragraph">
<p>The method <code>BeanManager.resolveObserverMethods()</code> resolves observer methods for an event according to the rules of observer resolution defined in <a href="#observer_resolution">Observer resolution</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;T&gt; <span class="predefined-type">Set</span>&lt;ObserverMethod&lt;? <span class="local-variable">super</span> T&gt;&gt; resolveObserverMethods(T event, <span class="predefined-type">Annotation</span>... qualifiers);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first parameter of <code>resolveObserverMethods()</code> is the event object.
The remaining parameters are event qualifiers.</p>
</div>
<div class="paragraph">
<p>If the runtime type of the event object contains a type variable, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If two instances of the same non repeating qualifier type are given, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If an instance of an annotation that is not a qualifier type is given, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_decorator_resolution"><a class="anchor" href="#bm_decorator_resolution"></a>11.3.13. Decorator resolution</h4>
<div class="paragraph">
<p>The method <code>BeanManager.resolveDecorators()</code> returns the ordered list of decorators for a set of bean types and a set of qualifiers and which are enabled in the module or library containing the class into which the <code>BeanManager</code> was injected or the class from whose JNDI environment namespace the <code>BeanManager</code> was obtained, as defined in <a href="#decorator_resolution">Decorator resolution</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;Decorator&lt;?&gt;&gt; resolveDecorators(<span class="predefined-type">Set</span>&lt;<span class="predefined-type">Type</span>&gt; types, <span class="predefined-type">Annotation</span>... qualifiers);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first argument is the set of bean types of the decorated bean.
The annotations are qualifiers declared by the decorated bean.</p>
</div>
<div class="paragraph">
<p>If two instances of the same non repeating qualifier type are given, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If an instance of an annotation that is not a qualifier type is given, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If the set of bean types is empty, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_interceptor_resolution"><a class="anchor" href="#bm_interceptor_resolution"></a>11.3.14. Interceptor resolution</h4>
<div class="paragraph">
<p>The method <code>BeanManager.resolveInterceptors()</code> returns the ordered list of interceptors for a set of interceptor bindings and a type of interception and which are enabled in the module or library containing the class into which the <code>BeanManager</code> was injected or the class from whose JNDI environment namespace the <code>BeanManager</code> was obtained, as defined in <a href="#interceptor_resolution">Interceptor resolution</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;Interceptor&lt;?&gt;&gt; resolveInterceptors(InterceptionType type,
                                         <span class="predefined-type">Annotation</span>... interceptorBindings);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If two instances of the same non repeating interceptor binding type are given, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If no interceptor binding type instance is given, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If an instance of an annotation that is not an interceptor binding type is given, an <code>IllegalArgumentException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_determining_annotation"><a class="anchor" href="#bm_determining_annotation"></a>11.3.15. Determining if an annotation is a qualifier type, scope type, stereotype or interceptor binding type</h4>
<div class="paragraph">
<p>A portable extension may test an annotation to determine if it is a qualifier type, scope type, stereotype or interceptor binding type, obtain the set of meta-annotations declared by a stereotype or interceptor binding type, or determine if a scope type is a normal or passivating scope.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">boolean</span> isScope(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; annotationType);
<span class="directive">public</span> <span class="type">boolean</span> isQualifier(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; annotationType);
<span class="directive">public</span> <span class="type">boolean</span> isInterceptorBinding(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; annotationType);
<span class="directive">public</span> <span class="type">boolean</span> isStereotype(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; annotationType);

<span class="directive">public</span> <span class="type">boolean</span> isNormalScope(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; scopeType);
<span class="directive">public</span> <span class="type">boolean</span> isPassivatingScope(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; scopeType);
<span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Annotation</span>&gt; getInterceptorBindingDefinition(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; qualifierType);
<span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Annotation</span>&gt; getStereotypeDefinition(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; stereotype);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_determining_hash"><a class="anchor" href="#bm_determining_hash"></a>11.3.16. Determining the hash code and equivalence of qualifiers and interceptor bindings</h4>
<div class="paragraph">
<p>A portable extension may determine if two qualifiers or two interceptor bindings are considered equivalent for the purposes of typesafe resolution, as defined in <a href="#performing_typesafe_resolution">Performing typesafe resolution</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">boolean</span> areQualifiersEquivalent(<span class="predefined-type">Annotation</span> qualifier1, <span class="predefined-type">Annotation</span> qualifier2);
<span class="directive">public</span> <span class="type">boolean</span> areInterceptorBindingsEquivalent(<span class="predefined-type">Annotation</span> interceptorBinding1, <span class="predefined-type">Annotation</span> interceptorBinding2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A portable extension may determine the hash code of a qualifier or interceptor binding, ignoring any members annotated with <code>@Nonbinding</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">int</span> getQualifierHashCode(<span class="predefined-type">Annotation</span> qualifier);
<span class="directive">public</span> <span class="type">int</span> getInterceptorBindingHashCode(<span class="predefined-type">Annotation</span> interceptorBinding);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_active_context"><a class="anchor" href="#bm_obtain_active_context"></a>11.3.17. Obtaining the active <code>Context</code> for a scope</h4>
<div class="paragraph">
<p>The method <code>BeanManager.getContext()</code> retrieves an active context object associated with the given scope, as defined in <a href="#active_context">The active context object for a scope</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Context</span> getContext(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; scopeType);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_elresolver"><a class="anchor" href="#bm_obtain_elresolver"></a>11.3.18. Obtaining the <code>ELResolver</code></h4>
<div class="paragraph">
<p>The method <code>BeanManager.getELResolver()</code> returns the <code>jakarta.el.ELResolver</code> specified in <a href="#el">Integration with Unified EL</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> ELResolver getELResolver();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_annotatedtype"><a class="anchor" href="#bm_obtain_annotatedtype"></a>11.3.19. Obtaining an <code>AnnotatedType</code> for a class</h4>
<div class="paragraph">
<p>The method <code>BeanManager.createAnnotatedType()</code> returns an <code>AnnotatedType</code> that may be used to read the annotations of the given Java class or interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;T&gt; AnnotatedType&lt;T&gt; createAnnotatedType(<span class="predefined-type">Class</span>&lt;T&gt; type);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_injectiontarget"><a class="anchor" href="#bm_obtain_injectiontarget"></a>11.3.20. Obtaining an <code>InjectionTarget</code> for a class</h4>
<div class="paragraph">
<p>The method <code>BeanManager.getInjectionTargetFactory()</code> returns a factory capable of creating container provided implementations of <code>InjectionTarget</code> for a given <code>AnnotatedType</code> or throws an <code>IllegalArgumentException</code> if there is a definition error associated with any injection point of the type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;T&gt; InjectionTargetFactory&lt;T&gt; getInjectionTargetFactory(AnnotatedType&lt;T&gt; type);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">InjectionTargetFactory</span>&lt;T&gt; {

    <span class="directive">public</span> InjectionTarget&lt;T&gt; createInjectionTarget(Bean&lt;T&gt; bean);
    <span class="directive">public</span> AnnotatedTypeConfigurator&lt;T&gt; configure();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Null should be passed to <code>InjectionTargetFactory.createInjectionTarget()</code> to create a non-contextual injection target.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>configure()</code> method returns an <code>AnnotatedTypeConfigurator</code> as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a> to configure the <code>AnnotatedType</code> used to create the <code>InjectionTargetFactory</code>.
Subsequent invocations of the <code>configure()</code> method within one <code>InjectionTargetFactory</code> instance will always return the same <code>AnnotatedTypeConfigurator</code> instance.
Once <code>createInjectionTarget()</code> method has been invoked, any invocations of <code>configure()</code> throws an <code>IllegalStateException</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The method <code>BeanManager.createInjectionTarget()</code> is deprecated since version 1.1 of Contexts and Dependency Injection.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_producer"><a class="anchor" href="#bm_obtain_producer"></a>11.3.21. Obtaining a <code>Producer</code> for a field or method</h4>
<div class="paragraph">
<p>The method <code>BeanManager.getProducerFactory()</code> returns a factory capable of creating container provided implementations of <code>Producer</code> for a given <code>AnnotatedMethod</code> or <code>AnnotatedField</code>, and declaring bean, or throws an <code>IllegalArgumentException</code> if there is a definition error associated with the producer method or field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;X&gt; ProducerFactory&lt;X&gt; getProducerFactory(AnnotatedField&lt;? <span class="local-variable">super</span> X&gt; field, Bean&lt;X&gt; declaringBean);
<span class="directive">public</span> &lt;X&gt; ProducerFactory&lt;X&gt; getProducerFactory(AnnotatedMethod&lt;? <span class="local-variable">super</span> X&gt; method, Bean&lt;X&gt; declaringBean);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProducerFactory</span>&lt;X&gt; {

    <span class="directive">public</span> &lt;T&gt; Producer&lt;T&gt; createProducer(Bean&lt;T&gt; bean);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Null should be passed to <code>ProducerFactory.createProducer()</code> to create a producer of non-contextual objects.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_injectionpoint"><a class="anchor" href="#bm_obtain_injectionpoint"></a>11.3.22. Obtaining an <code>InjectionPoint</code></h4>
<div class="paragraph">
<p>The method <code>BeanManager.createInjectionPoint()</code> returns a container provided implementation of <code>InjectionPoint</code> for a given <code>AnnotatedField</code> or <code>AnnotatedParameter</code> or throws an <code>IllegalArgumentException</code> if there is a definition error associated with the injection point.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> InjectionPoint createInjectionPoint(AnnotatedField&lt;?&gt; field);
<span class="directive">public</span> InjectionPoint createInjectionPoint(AnnotatedParameter&lt;?&gt; parameter);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_beanattributes"><a class="anchor" href="#bm_obtain_beanattributes"></a>11.3.23. Obtaining a <code>BeanAttributes</code></h4>
<div class="paragraph">
<p>The method <code>BeanManager.createBeanAttributes()</code> returns a container provided implementation of <code>BeanAttributes</code> by reading the annotations of a given <code>AnnotatedType</code> or <code>AnnotatedMember</code>, according to the rules defined in <a href="#concepts">Concepts</a>, or throws an <code>IllegalArgumentException</code> if there is a definition error associated with the declared bean attributes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;T&gt; BeanAttributes&lt;T&gt; createBeanAttributes(AnnotatedType&lt;T&gt; type);
<span class="directive">public</span> BeanAttributes&lt;?&gt; createBeanAttributes(AnnotatedMember&lt;?&gt; member);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_bean"><a class="anchor" href="#bm_obtain_bean"></a>11.3.24. Obtaining a <code>Bean</code></h4>
<div class="paragraph">
<p>The method <code>BeanManager.createBean()</code> returns a container provided implementation of <code>Bean</code>. The methods accept:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <code>BeanAttributes</code>, which determines the bean types, qualifiers, scope, name and stereotypes of the returned <code>Bean</code>, and the return values of <code>isAlternative()</code>, and</p>
</li>
<li>
<p>a class, which determines the return value of <code>Bean.getClass()</code>.</p>
</li>
<li>
<p>an <code>InjectionTargetFactory</code>, which is used to obtain an <code>InjectionTarget</code>. The <code>InjectionTarget</code> is used to create and destroy instances of the bean, to perform dependency injection and lifecycle callbacks, and which determines the return value of <code>Bean.getInjectionPoints()</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;T&gt; Bean&lt;T&gt; createBean(BeanAttributes&lt;T&gt; attributes, <span class="predefined-type">Class</span>&lt;T&gt; beanClass,
                          InjectionTargetFactory&lt;T&gt; injectionTargetFactory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A second version of the method is provided to create a <code>Bean</code> from a producer.
The method accepts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <code>BeanAttributes</code>, which determines the bean types, qualifiers, scope, name and stereotypes of the returned <code>Bean</code>, and the return values of <code>isAlternative()</code>, and</p>
</li>
<li>
<p>a class, which determines the return value of <code>Bean.getClass()</code>.</p>
</li>
<li>
<p>a <code>ProducerFactory</code>, which is used to obtain a <code>Producer</code>. The <code>Producer</code> is used to create and destroy instances of the bean, and which determines the return value of <code>Bean.getInjectionPoints()</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;T, X&gt; Bean&lt;T&gt; createBean(BeanAttributes&lt;T&gt; attributes, <span class="predefined-type">Class</span>&lt;X&gt; beanClass,
                          ProducerFactory&lt;X&gt; producer);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_extension"><a class="anchor" href="#bm_obtain_extension"></a>11.3.25. Obtaining the instance of an <code>Extension</code></h4>
<div class="paragraph">
<p>The method <code>BeanManager.getExtension()</code> returns the container&#8217;s instance of an <code>Extension</code> class declared in <code>META-INF/services</code>, or throws an <code>IllegalArgumentException</code> if the container has no instance of the given class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> &lt;T <span class="directive">extends</span> Extension&gt; T getExtension(<span class="predefined-type">Class</span>&lt;T&gt; extensionClass);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_interception_factory"><a class="anchor" href="#bm_obtain_interception_factory"></a>11.3.26. Obtain an <code>InterceptionFactory</code></h4>
<div class="paragraph">
<p>The method <code>BeanManager.getInterceptionFactory()</code> returns an <code>InterceptionFactory</code> for the provided type as defined in <a href="#interception_factory">The <code>InterceptionFactory</code> interface</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&lt;T&gt; InterceptionFactory&lt;T&gt; createInterceptionFactory(CreationalContext&lt;T&gt; ctx, <span class="predefined-type">Class</span>&lt;T&gt; clazz);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the actual type parameter of the method is not a Java class, non-portable behavior results.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_obtain_instance"><a class="anchor" href="#bm_obtain_instance"></a>11.3.27. Obtain an <code>Instance</code></h4>
<div class="paragraph">
<p>The method <code>BeanManager.createInstance()</code> returns an <code>Instance&lt;Object&gt;</code> to request bean instances programmatically as described in <a href="#dynamic_lookup">The <code>Instance</code> interface</a>.</p>
</div>
<div class="paragraph">
<p>The returned <code>Instance</code> object can only access instances of  beans that are available for injection in the module or library containing the class into which the <code>BeanManager</code> was injected or the Jakarta EE component from whose JNDI environment namespace the <code>BeanManager</code> was obtained, according to the rules defined in <a href="#typesafe_resolution">Typesafe resolution</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Instance&lt;<span class="predefined-type">Object</span>&gt; createInstance();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instances of dependent scoped beans obtained with this <code>Instance</code> object must be explicitly released by calling <code>Instance.destroy()</code> method.</p>
</div>
<div class="paragraph">
<p>If no qualifier is passed to <code>Instance.select()</code> method, the <code>@Default</code> qualifier is assumed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="alternative_metadata_sources"><a class="anchor" href="#alternative_metadata_sources"></a>11.4. Alternative metadata sources</h3>
<div class="paragraph">
<p>A portable extension may provide an alternative metadata source, such as configuration by XML.</p>
</div>
<div class="paragraph">
<p>The interfaces <code>AnnotatedType</code>, <code>AnnotatedField</code>, <code>AnnotatedMethod</code>, <code>AnnotatedConstructor</code> and <code>AnnotatedParameter</code> in the package <code>jakarta.enterprise.inject.spi</code> allow a portable extension to specify metadata that overrides the annotations that exist on a bean class.
The portable extension is responsible for implementing the interfaces, thereby exposing the metadata to the container.</p>
</div>
<div class="paragraph">
<p>In general, the behavior is as defined by the Java Language Specification, and only deviations from the Java Language Specification are noted.</p>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.AnnotatedType</code> exposes the <code>Class</code> object and members.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedType</span>&lt;X&gt;
        <span class="directive">extends</span> Annotated {
    <span class="directive">public</span> <span class="predefined-type">Class</span>&lt;X&gt; getJavaClass();
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;AnnotatedConstructor&lt;X&gt;&gt; getConstructors();
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;AnnotatedMethod&lt;? <span class="local-variable">super</span> X&gt;&gt; getMethods();
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;AnnotatedField&lt;? <span class="local-variable">super</span> X&gt;&gt; getFields();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getConstructors()</code> returns all default-access, public, protected or private constructors declared for the type.</p>
</li>
<li>
<p><code>getMethods()</code> returns all default-access, public, protected or private methods declared on the type and those declared on any supertypes.
The container should call <code>AnnotatedMethod.getJavaMember().getDeclaringClass()</code> to determine the type in the type hierarchy that declared the method.</p>
</li>
<li>
<p><code>getFields()</code> returns all default-access, public, protected or private fields declared on the type and those declared on any supertypes.
The container should call <code>AnnotatedField.getJavaMember().getDeclaringClass()</code> to determine the type in the type hierarchy that declared the field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When determining annotations on a type, the container must only consider the special inheritance rules defined for scope types in <a href="#type_level_inheritance">Inheritance of type-level metadata</a>.</p>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.AnnotatedField</code> exposes the <code>Field</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedField</span>&lt;X&gt;
        <span class="directive">extends</span> AnnotatedMember&lt;X&gt; {
    <span class="directive">public</span> <span class="predefined-type">Field</span> getJavaMember();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.AnnotatedMethod</code> exposes the <code>Method</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedMethod</span>&lt;X&gt;
        <span class="directive">extends</span> AnnotatedCallable&lt;X&gt; {
    <span class="directive">public</span> <span class="predefined-type">Method</span> getJavaMember();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.AnnotatedConstructor</code> exposes the <code>Constructor</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedConstructor</span>&lt;X&gt;
        <span class="directive">extends</span> AnnotatedCallable&lt;X&gt; {
    <span class="directive">public</span> <span class="predefined-type">Constructor</span>&lt;X&gt; getJavaMember();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.AnnotatedParameter</code> exposes the <code>position</code> of the parameter object and the declaring program element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedParameter</span>&lt;X&gt;
        <span class="directive">extends</span> Annotated {
    <span class="directive">public</span> <span class="type">int</span> getPosition();
    <span class="directive">public</span> AnnotatedCallable&lt;X&gt; getDeclaringCallable();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.AnnotatedMember</code> exposes the <code>Member</code> object and the <code>AnnotatedType</code> that defines the member.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedMember</span>&lt;X&gt;
        <span class="directive">extends</span> Annotated {
    <span class="directive">public</span> <span class="predefined-type">Member</span> getJavaMember();
    <span class="directive">public</span> <span class="type">boolean</span> isStatic();
    <span class="directive">public</span> AnnotatedType&lt;X&gt; getDeclaringType();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.AnnotatedCallable</code> exposes the parameters of an invokable object.</p>
</div>
<div class="paragraph">
<p>CDI 1.1 deprecated the method <code>AnnotatedMember.isStatic()</code>. The container should instead call <code>AnnotatedMember.getJavaMember().getModifiers()</code> to determine if the member is static.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedCallable</span>&lt;X&gt;
        <span class="directive">extends</span> AnnotatedMember&lt;X&gt; {
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;AnnotatedParameter&lt;X&gt;&gt; getParameters();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.Annotated</code> exposes the overriding annotations and type declarations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Annotated</span> {
    <span class="predefined-type">Type</span> getBaseType();
    <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Type</span>&gt; getTypeClosure();
    &lt;T <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; T getAnnotation(<span class="predefined-type">Class</span>&lt;T&gt; annotationType);
    &lt;T <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; <span class="predefined-type">Set</span>&lt;T&gt; getAnnotations(<span class="predefined-type">Class</span>&lt;T&gt; annotationType);
    <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Annotation</span>&gt; getAnnotations();
    <span class="type">boolean</span> isAnnotationPresent(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; annotationType);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getBaseType()</code> returns the type of the program element.</p>
</li>
<li>
<p><code>getTypeClosure()</code> returns all types to which the base type should be considered assignable.</p>
</li>
<li>
<p><code>getAnnotation(Class&lt;T&gt;)</code> returns the program element annotation of the given annotation type, or a null value.</p>
</li>
<li>
<p><code>getAnnotations(Class&lt;T&gt;)</code> returns the program element annotations of the given annotation type, or an empty set.</p>
</li>
<li>
<p><code>getAnnotations()</code> returns all annotations of the program element.</p>
</li>
<li>
<p><code>isAnnotationPresent(Class&lt;T&gt;)</code> returns <code>true</code> if the program element has an annotation of the given annotation type, or <code>false</code> otherwise.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container must use the operations of <code>Annotated</code> and its subinterfaces to discover program element types and annotations.
The container must not directly call the Java Reflection API. In particular, the container must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>call <code>Annotated.getBaseType()</code> to determine the type of an injection point, event parameter or disposed parameter,</p>
</li>
<li>
<p>call <code>Annotated.getTypeClosure()</code> to determine the bean types of any kind of bean,</p>
</li>
<li>
<p>call <code>Annotated.getAnnotations()</code> to determine the scope, qualifiers, stereotypes and interceptor bindings of a bean,</p>
</li>
<li>
<p>call <code>Annotated.isAnnotationPresent()</code> and <code>Annotated.getAnnotation()</code> to read any bean annotations defined by this specification, and</p>
</li>
<li>
<p>call <code>AnnotatedType.getConstructors()</code>, <code>AnnotatedType.getMethods()</code> and <code>AnnotatedType.getFields()</code> to determine the members of a bean class.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="annotated_type_configurator"><a class="anchor" href="#annotated_type_configurator"></a>11.4.1. <code>AnnotatedTypeConfigurator</code> SPI</h4>
<div class="paragraph">
<p>CDI 2.0 introduced a new SPI to help defining and creating instance for type metadata.</p>
</div>
<div class="paragraph">
<p>This SPI is composed of the following interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator</code> to configure an <code>AnnotatedType</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator</code> (defined in <a href="#annotated_field_configurator"><code>AnnotatedFieldConfigurator</code></a>) to configure an <code>AnnotatedField</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator</code> (defined in <a href="#annotated_constructor_configurator"><code>AnnotatedConstructorConfigurator</code></a>) to configure an <code>AnnotatedConstructor</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator</code> (defined in <a href="#annotated_method_configurator"><code>AnnotatedMethodConfigurator</code></a>) to configure an <code>AnnotatedMethod</code></p>
</li>
<li>
<p><code>jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator</code> (defined in <a href="#annotated_parameter_configurator"><code>AnnotatedParameterConfigurator</code></a>) to configure an <code>AnnotatedParameter</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container must provide an implementation for each of these interfaces.</p>
</div>
<div class="paragraph">
<p><code>AnnotatedTypeConfigurator</code> is the entry point for this SPI.
Implementation of <code>AnnotatedTypeConfigurator</code> is returned by methods in the following lifecycle event:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BeforeBeanDiscovery</code> as defined in <a href="#before_bean_discovery"><code>BeforeBeanDiscovery</code> event</a></p>
</li>
<li>
<p><code>ProcessAnnotatedType</code> as defined in <a href="#process_annotated_type"><code>ProcessAnnotatedType</code> event</a></p>
</li>
<li>
<p><code>AfterTypeDiscovery</code> as defined in <a href="#after_type_discovery"><code>AfterTypeDiscovery</code> event</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedTypeConfigurator</span>&lt;T&gt; {

    AnnotatedType&lt;T&gt; getAnnotated();
    AnnotatedTypeConfigurator&lt;T&gt; add(<span class="predefined-type">Annotation</span> annotation);
    AnnotatedTypeConfigurator&lt;T&gt; remove(<span class="predefined-type">Predicate</span>&lt;<span class="predefined-type">Annotation</span>&gt; predicate);
    AnnotatedTypeConfigurator&lt;T&gt; removeAll();
    <span class="predefined-type">Set</span>&lt;AnnotatedMethodConfigurator&lt;T&gt;&gt; methods();
    Stream&lt;AnnotatedMethodConfigurator&lt;T&gt;&gt; filterMethods(<span class="predefined-type">Predicate</span>&lt;AnnotatedMethod&lt;T&gt;&gt; predicate);
    <span class="predefined-type">Set</span>&lt;AnnotatedFieldConfigurator&lt;T&gt;&gt; fields();
    Stream&lt;AnnotatedFieldConfigurator&lt;T&gt;&gt; filterFields(<span class="predefined-type">Predicate</span>&lt;AnnotatedField&lt;T&gt;&gt; predicate);
    <span class="predefined-type">Set</span>&lt;AnnotatedConstructorConfigurator&lt;T&gt;&gt; constructors();
    Stream&lt;AnnotatedConstructorConfigurator&lt;T&gt;&gt; filterConstructors(<span class="predefined-type">Predicate</span>&lt;AnnotatedConstructor&lt;T&gt;&gt; predicate);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotated()</code> returns the original <code>AnnotatedType</code> with which this configurator was initialized</p>
</li>
<li>
<p><code>add()</code> adds an annotation to the configured element</p>
</li>
<li>
<p><code>remove()</code> removes annotations that match the specified predicate from the configured element</p>
</li>
<li>
<p><code>removeAll()</code> removes all annotations from the configured element</p>
</li>
<li>
<p><code>methods()</code> returns a set of <code>AnnotatedMethodConfigurator</code> to configure annotations on methods</p>
</li>
<li>
<p><code>filterMethods()</code> returns a <code>Stream&lt;AnnotatedMethodsConfigurator&gt;</code> filtered by applying the provided Predicate on <code>methods()</code></p>
</li>
<li>
<p><code>fields()</code> returns a set of <code>AnnotatedFieldConfigurator</code> to configure annotations on fields</p>
</li>
<li>
<p><code>filterFields()</code> returns a <code>Stream&lt;AnnotatedFieldConfigurator&gt;</code> filtered by applying the provided Predicate on <code>fields()</code></p>
</li>
<li>
<p><code>constructors()</code> returns a set of <code>AnnotatedConstructorConfigurator</code> to configure annotations on constructors</p>
</li>
<li>
<p><code>filterConstructors()</code> returns a <code>Stream&lt;AnnotatedConstructorConfigurator&gt;</code> filtered by applying the provided Predicate on <code>Constructors()</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="annotated_method_configurator"><a class="anchor" href="#annotated_method_configurator"></a>11.4.1.1. <code>AnnotatedMethodConfigurator</code></h5>
<div class="paragraph">
<p><code>AnnotatedMethodConfigurator</code> is obtained through <code>AnnotatedTypeConfigurator</code> as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedMethodConfigurator</span>&lt;T&gt; {
    AnnotatedMethod&lt;T&gt; getAnnotated();
    AnnotatedMethodConfigurator&lt;T&gt; add(<span class="predefined-type">Annotation</span> annotation);
    AnnotatedMethodConfigurator&lt;T&gt; remove(<span class="predefined-type">Predicate</span>&lt;<span class="predefined-type">Annotation</span>&gt; predicate);
    AnnotatedMethodConfigurator&lt;T&gt; removeAll();
    <span class="predefined-type">List</span>&lt;AnnotatedParameterConfigurator&lt;T&gt;&gt; params();
    Stream&lt;AnnotatedParameterConfigurator&lt;T&gt;&gt; filterParams(<span class="predefined-type">Predicate</span>&lt;AnnotatedParameter&lt;T&gt;&gt; predicate);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotated()</code> returns the original <code>AnnotatedMethod</code> with which this configurator was initialized</p>
</li>
<li>
<p><code>add()</code> adds an annotation to the configured element</p>
</li>
<li>
<p><code>remove()</code> removes annotations that match the specified predicate from the configured element</p>
</li>
<li>
<p><code>removeAll()</code> removes all annotations from the configured element</p>
</li>
<li>
<p><code>params()</code> returns a list of <code>AnnotatedParameterConfigurator</code> to configure annotations on parameters.</p>
</li>
<li>
<p><code>filterParams(Predicate&lt;AnnotatedParameter&lt;T&gt;&gt; predicate)</code> returns a <code>Stream&lt;AnnotatedParameterConfigurator&gt;</code> filtered by applying the provided Predicate on <code>params()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="annotated_constructor_configurator"><a class="anchor" href="#annotated_constructor_configurator"></a>11.4.1.2. <code>AnnotatedConstructorConfigurator</code></h5>
<div class="paragraph">
<p><code>AnnotatedConstructorConfigurator</code> is obtained through <code>AnnotatedTypeConfigurator</code> as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedConstructorConfigurator</span>&lt;T&gt; {
    AnnotatedConstructor&lt;T&gt; getAnnotated();
    AnnotatedConstructorConfigurator&lt;T&gt; add(<span class="predefined-type">Annotation</span> annotation);
    AnnotatedConstructorConfigurator&lt;T&gt; remove(<span class="predefined-type">Predicate</span>&lt;<span class="predefined-type">Annotation</span>&gt; predicate);
    AnnotatedConstructorConfigurator&lt;T&gt; removeAll();
    <span class="predefined-type">List</span>&lt;AnnotatedParameterConfigurator&lt;T&gt;&gt; params();
    Stream&lt;AnnotatedParameterConfigurator&lt;T&gt;&gt; filterParams(<span class="predefined-type">Predicate</span>&lt;AnnotatedParameter&lt;T&gt;&gt; predicate);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotated()</code> returns the original <code>AnnotatedConstructor</code> with which this configurator was initialized</p>
</li>
<li>
<p><code>add()</code> adds an annotation to the configured element</p>
</li>
<li>
<p><code>remove()</code> removes annotations that match the specified predicate from the configured element</p>
</li>
<li>
<p><code>removeAll()</code> removes all annotations from the configured element</p>
</li>
<li>
<p><code>params()</code> returns a list of <code>AnnotatedParameterConfigurator</code> to configure annotations on parameters.</p>
</li>
<li>
<p><code>filterParams(Predicate&lt;AnnotatedParameter&lt;T&gt;&gt; predicate)</code> returns a <code>Stream&lt;AnnotatedParameterConfigurator&gt;</code> filtered by applying the provided Predicate on <code>params()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="annotated_parameter_configurator"><a class="anchor" href="#annotated_parameter_configurator"></a>11.4.1.3. <code>AnnotatedParameterConfigurator</code></h5>
<div class="paragraph">
<p><code>AnnotatedParameterConfigurator</code> is obtained through <code>AnnotatedMethodConfigurator</code> (as defined in <a href="#annotated_method_configurator"><code>AnnotatedMethodConfigurator</code></a>) and <code>AnnotatedConstructorConfigurator</code> as defined in <a href="#annotated_constructor_configurator"><code>AnnotatedConstructorConfigurator</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedParameterConfigurator</span>&lt;T&gt; {
    AnnotatedParameter&lt;T&gt; getAnnotated();
    AnnotatedParameterConfigurator&lt;T&gt; add(<span class="predefined-type">Annotation</span> annotation);
    AnnotatedParameterConfigurator&lt;T&gt; remove(<span class="predefined-type">Predicate</span>&lt;<span class="predefined-type">Annotation</span>&gt; predicate);
    AnnotatedParameterConfigurator&lt;T&gt; removeAll();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotated()</code> returns the original <code>AnnotatedParameter</code> with which this configurator was initialized</p>
</li>
<li>
<p><code>add()</code> adds an annotation to the configured element</p>
</li>
<li>
<p><code>remove()</code> removes annotations that match the specified predicate from the configured element</p>
</li>
<li>
<p><code>removeAll()</code> removes all annotations from the configured element</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="annotated_field_configurator"><a class="anchor" href="#annotated_field_configurator"></a>11.4.1.4. <code>AnnotatedFieldConfigurator</code></h5>
<div class="paragraph">
<p><code>AnnotatedFieldConfigurator</code> is obtained through <code>AnnotatedTypeConfigurator</code> as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotatedFieldConfigurator</span>&lt;T&gt; {

    AnnotatedField&lt;T&gt; getAnnotated();
    AnnotatedFieldConfigurator&lt;T&gt; add(<span class="predefined-type">Annotation</span> annotation);
    AnnotatedFieldConfigurator&lt;T&gt; remove(<span class="predefined-type">Predicate</span>&lt;<span class="predefined-type">Annotation</span>&gt; predicate);
    AnnotatedFieldConfigurator&lt;T&gt; removeAll();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotated()</code> returns the original <code>AnnotatedField</code> with which this configurator was initialized</p>
</li>
<li>
<p><code>add()</code> adds an annotation to the configured element</p>
</li>
<li>
<p><code>remove()</code> removes annotations that match the specified predicate from the configured element</p>
</li>
<li>
<p><code>removeAll()</code> removes all annotations from the configured element</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="init_events"><a class="anchor" href="#init_events"></a>11.5. Container lifecycle events</h3>
<div class="paragraph">
<p>During the application initialization process, the container fires a series of events, allowing portable extensions to integrate with the container initialization process defined in <a href="#initialization">Application initialization lifecycle</a>.
These events are fired synchronously.</p>
</div>
<div class="paragraph">
<p>Observer methods of these events must belong to <em>extensions</em>.
An extension is a service provider of the service <code>jakarta.enterprise.inject.spi.Extension</code> declared in <code>META-INF/services</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Extension</span> {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any method on the event object is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>Service providers may have observer methods, which may observe any event, including any container lifecycle event, and obtain an injected <code>BeanManager</code> reference. Any decorators associated with <code>BeanManager</code> will not be applied.
If other beans are injected into an extension&#8217;s observer methods, non-portable behavior results.
An extension may use <code>BeanManager.fireEvent()</code> to deliver events to observer methods defined on extensions.
The container is not required to deliver events fired during application initialization to observer methods defined on beans.</p>
</div>
<div class="paragraph">
<p>The container instantiates a single instance of each extension at the beginning of the application initialization process and maintains a reference to it until the application shuts down.
The container delivers event notifications to this instance by calling its observer methods.</p>
</div>
<div class="paragraph">
<p>If an extension declares a static observer method whose event parameter type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>is a container lifecycle event, or</p>
</li>
<li>
<p>is <code>java.lang.Object</code> and the event parameter has either no qualifiers or a single qualifier <code>@Any</code>,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>non-portable behavior results.</p>
</div>
<div class="paragraph">
<p>The notification order for observer methods within extensions follows the same ordering rule as defined in <a href="#observer_ordering">Observer ordering</a> for non-extension observers.
The priority of an observer method may be declared using the <code>@Priority</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> beforeBeanDiscovery(<span class="annotation">@Observes</span> <span class="annotation">@Priority</span>(jakarta.interceptor.Interceptor.Priority.LIBRARY_BEFORE) BeforeBeanDiscovery event) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>For each service provider, the container must provide a bean of scope <code>@ApplicationScoped</code> and qualifier <code>@Default</code>, supporting injection of a reference to the service provider instance. The bean types of this bean include the class of the service provider and all superclasses and interfaces.</p>
</div>
<div class="paragraph">
<p>Lifecycle events described below can be grouped in to two categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Application lifecycle events, that are fired once:</p>
<div class="ulist">
<ul>
<li>
<p>BeforeBeanDiscovery</p>
</li>
<li>
<p>AfterTypeDiscovery</p>
</li>
<li>
<p>AfterBeanDiscovery</p>
</li>
<li>
<p>AfterDeploymentValidation</p>
</li>
<li>
<p>BeforeShutdown</p>
</li>
</ul>
</div>
</li>
<li>
<p>Bean discovery events, that are fired multiple times:</p>
<div class="ulist">
<ul>
<li>
<p>ProcessAnnotatedType</p>
</li>
<li>
<p>ProcessInjectionPoint</p>
</li>
<li>
<p>ProcessInjectionTarget</p>
</li>
<li>
<p>ProcessBeanAttributes</p>
</li>
<li>
<p>ProcessBean</p>
</li>
<li>
<p>ProcessProducer</p>
</li>
<li>
<p>ProcessObserverMethod</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that the chronological order of these events is specified in <a href="#initialization">Application initialization lifecycle</a>.</p>
</div>
<div class="sect3">
<h4 id="before_bean_discovery"><a class="anchor" href="#before_bean_discovery"></a>11.5.1. <code>BeforeBeanDiscovery</code> event</h4>
<div class="paragraph">
<p>The container must fire an event before it begins the type discovery process.
The event object must be of type <code>jakarta.enterprise.inject.spi.BeforeBeanDiscovery</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">BeforeBeanDiscovery</span> {
    <span class="directive">public</span> <span class="type">void</span> addQualifier(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; qualifier);
    <span class="directive">public</span> <span class="type">void</span> addQualifier(AnnotatedType&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; qualifier);
    <span class="directive">public</span> <span class="type">void</span> addScope(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; scopeType, <span class="type">boolean</span> normal, <span class="type">boolean</span> passivating);
    <span class="directive">public</span> <span class="type">void</span> addStereotype(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; stereotype, <span class="predefined-type">Annotation</span>... stereotypeDef);
    <span class="directive">public</span> <span class="type">void</span> addInterceptorBinding(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; bindingType, <span class="predefined-type">Annotation</span>... bindingTypeDef);
    <span class="directive">public</span> <span class="type">void</span> addInterceptorBinding(AnnotatedType&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; bindingType);
    <span class="directive">public</span> <span class="type">void</span> addAnnotatedType(AnnotatedType&lt;?&gt; type);
    <span class="directive">public</span> <span class="type">void</span> addAnnotatedType(AnnotatedType&lt;?&gt; type, <span class="predefined-type">String</span> id);
    <span class="directive">public</span> AnnotatedTypeConfigurator&lt;?&gt; addAnnotatedType(<span class="predefined-type">Class</span>&lt;T&gt; type,<span class="predefined-type">String</span> id);
    &lt;T <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; AnnotatedTypeConfigurator&lt;T&gt; configureQualifier(<span class="predefined-type">Class</span>&lt;T&gt; qualifier);
    &lt;T <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; AnnotatedTypeConfigurator&lt;T&gt; configureInterceptorBinding(<span class="predefined-type">Class</span>&lt;T&gt; bindingType);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>addQualifier()</code> declares an annotation type as a qualifier type.</p>
</li>
<li>
<p><code>addScope()</code> declares an annotation type as a scope type.</p>
</li>
<li>
<p><code>addStereotype()</code> declares an annotation type as a stereotype, and specifies its meta-annotations.</p>
</li>
<li>
<p><code>addInterceptorBinding()</code> declares an annotation type as an interceptor binding type, and specifies its meta-annotations.</p>
</li>
<li>
<p><code>addAnnotatedType()</code> adds a given <code>AnnotatedType</code> to the set of types which will be scanned during bean discovery, with an optional identifier.
The first version of the method is deprecated since version 1.1 of Contexts and Dependency Injection.</p>
<div class="paragraph">
<p>The third version of the method, returns a new <code>AnnotatedTypeConfigurator</code> as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a> to easily configure the <code>AnnotatedType</code> which will be added at the end of the observer invocation.
The returned <code>AnnotatedTypeConfigurator</code> is initialized with type and annotations of the provided class.</p>
</div>
</li>
<li>
<p><code>configureQualifier()</code> returns a new <code>AnnotatedTypeConfigurator</code> as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a> to configure a new <code>AnnotatedType</code> and declares it as a qualifier type.</p>
</li>
<li>
<p><code>configureInterceptorBinding()</code> returns a new <code>AnnotatedTypeConfigurator</code> as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a> to configure a new <code>AnnotatedType</code> and declares it as an interceptor binding.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> beforeBeanDiscovery(<span class="annotation">@Observes</span> BeforeBeanDiscovery event) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any observer method of the <code>BeforeBeanDiscovery</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>BeforeBeanDiscovery</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="after_type_discovery"><a class="anchor" href="#after_type_discovery"></a>11.5.2. <code>AfterTypeDiscovery</code> event</h4>
<div class="paragraph">
<p>The container must fire an event when it has fully completed the type discovery process and before it begins the bean discovery process.
The event object must be of type <code>jakarta.enterprise.inject.spi.AfterTypeDiscovery</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AfterTypeDiscovery</span> {
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getAlternatives();
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getInterceptors();
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getDecorators();
    <span class="directive">public</span> <span class="type">void</span> addAnnotatedType(AnnotatedType&lt;?&gt; type, <span class="predefined-type">String</span> id);
    <span class="directive">public</span> AnnotatedTypeConfigurator&lt;?&gt; addAnnotatedType(<span class="predefined-type">Class</span>&lt;T&gt; type,<span class="predefined-type">String</span> id);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAlternatives()</code> returns the ordered list of enabled alternatives for the application, sorted by priority in ascending order.
Alternatives enabled for a bean archive are not included in the list.</p>
</li>
<li>
<p><code>getInterceptors()</code> returns the ordered list of enabled interceptors for the application, sorted by priority in ascending order.
Interceptors enabled for a bean archive are not included in the list.</p>
</li>
<li>
<p><code>getDecorators()</code> returns the ordered list of enabled decorators for the application, sorted by priority in ascending order.
Decorators enabled for a bean archive are not included in the list.</p>
</li>
<li>
<p><code>addAnnotatedType()</code> adds a given <code>AnnotatedType</code> to the set of types which will be scanned during bean discovery, with an identifier.</p>
<div class="paragraph">
<p>The second version of the method, returns a new <code>AnnotatedTypeConfigurator</code> as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a> to easily configure the <code>AnnotatedType</code> which will be added at the end of observer invocation.
The returned <code>AnnotatedTypeConfigurator</code> is initialized with type and annotations of the provided class.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If an alternative, interceptor or decorator is added using <code>AfterTypeDiscovery.addAnnotatedType()</code>, non-portable behavior results.</p>
</div>
<div class="paragraph">
<p>Any observer of this event is permitted to add classes to, or remove classes from, the list of alternatives, list of interceptors or list of decorators.
The container must use the final values of these collections, after all observers of <code>AfterTypeDiscovery</code> have been called, to determine the order of the enabled alternatives, interceptors, and decorators for application.
The initial values of these collections are defined by the <code>@Priority</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> afterTypeDiscovery(<span class="annotation">@Observes</span> AfterTypeDiscovery event) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any observer method of a <code>AfterTypeDiscovery</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>AfterTypeDiscovery</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="after_bean_discovery"><a class="anchor" href="#after_bean_discovery"></a>11.5.3. <code>AfterBeanDiscovery</code> event</h4>
<div class="paragraph">
<p>The container must fire an event when it has fully completed the bean discovery process, validated that there are no definition errors relating to the discovered beans, and registered <code>Bean</code> and <code>ObserverMethod</code> objects for the discovered beans.</p>
</div>
<div class="paragraph">
<p>The event object must be of type <code>jakarta.enterprise.inject.spi.AfterBeanDiscovery</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AfterBeanDiscovery</span> {
    <span class="directive">public</span> <span class="type">void</span> addDefinitionError(<span class="predefined-type">Throwable</span> t);
    <span class="directive">public</span> <span class="type">void</span> addBean(Bean&lt;?&gt; bean);
    <span class="directive">public</span> BeanConfigurator&lt;?&gt; addBean();
    <span class="directive">public</span> <span class="type">void</span> addObserverMethod(ObserverMethod&lt;?&gt; observerMethod);
    <span class="directive">public</span> ObserverMethodConfigurator&lt;?&gt; addObserverMethod();
    <span class="directive">public</span> <span class="type">void</span> addContext(<span class="predefined-type">Context</span> context);
    <span class="directive">public</span> &lt;T&gt; AnnotatedType&lt;T&gt; getAnnotatedType(<span class="predefined-type">Class</span>&lt;T&gt; type, <span class="predefined-type">String</span> id);
    <span class="directive">public</span> &lt;T&gt; <span class="predefined-type">Iterable</span>&lt;AnnotatedType&lt;T&gt;&gt; getAnnotatedTypes(<span class="predefined-type">Class</span>&lt;T&gt; type);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>addDefinitionError()</code> registers a definition error with the container, causing the container to abort deployment after all observers have been notified.</p>
</li>
<li>
<p><code>addBean()</code> fires an event of type <code>ProcessSyntheticBean</code> containing the given <code>Bean</code> and then registers the <code>Bean</code> with the container, thereby making it available for injection into other beans.
The given <code>Bean</code> may implement <code>Interceptor</code> or <code>Decorator</code>.</p>
<div class="paragraph">
<p>The second version of the method, returns a new <code>BeanConfigurator</code> as defined in <a href="#bean_configurator"><code>BeanConfigurator</code> interface</a> to easily configure the <code>Bean</code> which will be added at the end of observer invocation.
If the container is unable to process the configurator it automatically detects the problem and treats it as a deployment problem.</p>
</div>
</li>
<li>
<p><code>addObserverMethod()</code> fires an event of type <code>ProcessSyntheticObserverMethod</code> containing the given <code>ObserverMethod</code> and then registers the <code>ObserverMethod</code> with the container, thereby making it available for event notifications.</p>
<div class="paragraph">
<p>If the given <code>ObserverMethod</code> does not override either <code>ObserverMethod.notify(T)</code> or <code>ObserverMethod.notify(EventContext&lt;T&gt;)</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>The second version of the method, returns a new <code>ObserverMethodConfigurator</code> as defined in <a href="#observer_method_configurator"><code>ObserverMethodConfigurator</code> interface</a> to easily configure the <code>ObserverMethod</code> which will be added at the end of observer invocation.
If the container is unable to process the configurator it automatically detects the problem and treats it as a deployment problem.</p>
</div>
</li>
<li>
<p><code>addContext()</code> registers a custom <code>Context</code> object with the container.</p>
</li>
<li>
<p><code>getAnnotatedType()</code> and <code>getAnnotatedTypes()</code> returns the <code>AnnotatedType</code> s discovered or added during container initialization.
The id of an <code>AnnotatedType</code> added by the container is not defined.
If the <code>id</code> passed is null, the container should substitute the container generated id.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A portable extension may take advantage of this event to register beans, interceptors, decorators, observer methods and custom context objects with the container.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> afterBeanDiscovery(<span class="annotation">@Observes</span> AfterBeanDiscovery event, BeanManager manager) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any observer method of the <code>AfterBeanDiscovery</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>AfterBeanDiscovery</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="sect4">
<h5 id="bean_configurator"><a class="anchor" href="#bean_configurator"></a>11.5.3.1. <code>BeanConfigurator</code> interface</h5>
<div class="paragraph">
<p>CDI 2.0 introduced the <code>jakarta.enterprise.inject.spi.configurator.BeanConfigurator</code> interface to help configuring a new <code>Bean</code> instance.</p>
</div>
<div class="paragraph">
<p>With <code>BeanConfigurator</code> you can perform all the operations defined in <a href="#bean_attributes_configurator"><code>BeanAttributesConfigurator</code> interface</a> plus the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize the bean metadata with one of its <code>read()</code> methods.
It can be done from an existing <code>BeanAttributes</code>  or by reading metadata on a given <code>AnnotatedType</code>, according to the rules defined in <a href="#concepts">Concepts</a>.</p>
</li>
<li>
<p>Set the class of the bean with <code>beanClass</code> method.</p>
</li>
<li>
<p>Add an injection point for the bean with <code>addInjectionPoint</code> method.</p>
</li>
<li>
<p>Add multiple injection points for the bean with <code>addInjectionPoints</code> methods.</p>
</li>
<li>
<p>Replace all injection points for the bean with <code>injectionPoints</code> methods.</p>
</li>
<li>
<p>Make the bean implements <code>PassivationCapable</code> and set its id with <code>id</code> method.</p>
</li>
<li>
<p>Set a callback to create a bean instance with <code>createWith()</code> or <code>produceWith()</code> method.</p>
</li>
<li>
<p>Set a callback to destroy a bean instance with <code>destroyWith()</code> or <code>disposeWith()</code> method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a <code>BeanConfigurator</code> has no scope specified, the default scope rules, defined in <a href="#default_scope">Default scope</a>, apply.</p>
</div>
</div>
<div class="sect4">
<h5 id="observer_method_configurator"><a class="anchor" href="#observer_method_configurator"></a>11.5.3.2. <code>ObserverMethodConfigurator</code> interface</h5>
<div class="paragraph">
<p>CDI 2.0 introduced the <code>jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator</code> interface to help configuring an <code>ObserverMethod</code> instance.</p>
</div>
<div class="paragraph">
<p>With <code>ObserverMethodConfigurator</code> you can perform the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read the observer metadata from a <code>java.lang.reflect.Method</code>, <code>AnnotatedMethod</code> or an existing <code>ObserverMethod</code> with one of its <code>read()</code> methods.</p>
</li>
<li>
<p>Set the <code>ObserverMethod</code> bean class with <code>beanClass</code> method.</p>
</li>
<li>
<p>Set the type of the observed event with <code>observedType</code> method.</p>
</li>
<li>
<p>Add a qualifier with <code>addQualifier</code> method.</p>
</li>
<li>
<p>Set or add multiple qualifiers with <code>addQualifiers</code> and <code>qualifiers</code> methods.</p>
</li>
<li>
<p>Set the <code>Reception</code> type with reception method.</p>
</li>
<li>
<p>Set the <code>TransactionPhase</code> type with <code>transactionPhase</code> method.</p>
</li>
<li>
<p>Set the priority with <code>priority</code> method.</p>
</li>
<li>
<p>Define the <code>EventConsumer</code> to call on notification with <code>notifyWith</code> method.</p>
</li>
<li>
<p>Make the observer asynchronous with <code>async</code> method.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="after_deployment_validation"><a class="anchor" href="#after_deployment_validation"></a>11.5.4. <code>AfterDeploymentValidation</code> event</h4>
<div class="paragraph">
<p>The container must fire an event after it has validated that there are no deployment problems and before creating contexts or processing requests.</p>
</div>
<div class="paragraph">
<p>The event object must be of type <code>jakarta.enterprise.inject.spi.AfterDeploymentValidation</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AfterDeploymentValidation</span> {
    <span class="directive">public</span> <span class="type">void</span> addDeploymentProblem(<span class="predefined-type">Throwable</span> t);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>addDeploymentProblem()</code> registers a deployment problem with the container, causing the container to abort deployment after all observers have been notified.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> afterDeploymentValidation(<span class="annotation">@Observes</span> AfterDeploymentValidation event, BeanManager manager) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any observer method of the <code>AfterDeploymentValidation</code> event throws an exception, the exception is treated as a deployment problem by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>AfterDeploymentValidation</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>The container must not allow any request to be processed by the deployment until all observers of this event return.</p>
</div>
</div>
<div class="sect3">
<h4 id="before_shutdown"><a class="anchor" href="#before_shutdown"></a>11.5.5. <code>BeforeShutdown</code> event</h4>
<div class="paragraph">
<p>The container must fire a final event after it has finished processing requests and destroyed all contexts.</p>
</div>
<div class="paragraph">
<p>The event object must be of type <code>jakarta.enterprise.inject.spi.BeforeShutdown</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">BeforeShutdown</span> {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> beforeShutdown(<span class="annotation">@Observes</span> BeforeShutdown event, BeanManager manager) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any observer method of the <code>BeforeShutdown</code> event throws an exception, the exception is ignored by the container.</p>
</div>
</div>
<div class="sect3">
<h4 id="process_annotated_type"><a class="anchor" href="#process_annotated_type"></a>11.5.6. <code>ProcessAnnotatedType</code> event</h4>
<div class="paragraph">
<p>The container must fire an event, before it processes a type, for every Java class, interface (excluding <em>annotation type</em>, a special kind of interface type) or enum discovered as defined in <a href="#type_discovery_steps">Type discovery</a>.</p>
</div>
<div class="paragraph">
<p>An event is not fired for any type annotated with <code>@Vetoed</code>, or in a package annotated with <code>@Vetoed</code>.</p>
</div>
<div class="paragraph">
<p>The event object must be of type <code>jakarta.enterprise.inject.spi.ProcessAnnotatedType&lt;X&gt;</code>, where <code>X</code> is the class, for types discovered in a bean archive, or of type <code>jakarta.enterprise.inject.spi.ProcessSyntheticAnnotatedType&lt;X&gt;</code> for types added by <code>BeforeBeanDiscovery.addAnnotatedType()</code> or <code>AfterTypeDiscovery.addAnnotatedType()</code>.</p>
</div>
<div class="paragraph">
<p>The annotation <code>@WithAnnotations</code> may be applied to the event parameter.
If the annotation is applied, the container must only deliver <code>ProcessAnnotatedType</code> events for types which contain at least one of the annotations specified.
The annotation can appear on the annotated type, or on any member, or any parameter of any member of the annotated type, as defined in <a href="#alternative_metadata_sources">Alternative metadata sources</a>.
The annotation may be applied as a meta-annotation on any annotation considered.</p>
</div>
<div class="paragraph">
<p>If the <code>@WithAnnotations</code> annotation is applied to any other event parameter, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessAnnotatedType</span>&lt;X&gt; {
    <span class="directive">public</span> AnnotatedType&lt;X&gt; getAnnotatedType();
    <span class="directive">public</span> <span class="type">void</span> setAnnotatedType(AnnotatedType&lt;X&gt; type);
    <span class="directive">public</span> AnnotatedTypeConfigurator&lt;X&gt; configureAnnotatedType();
    <span class="directive">public</span> <span class="type">void</span> veto();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">ProcessSyntheticAnnotatedType</span>&lt;X&gt; <span class="directive">extends</span> ProcessAnnotatedType&lt;X&gt; {
    <span class="directive">public</span> Extension getSource();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotatedType()</code> returns the <code>AnnotatedType</code> object that will be used by the container to read the declared annotations.</p>
</li>
<li>
<p><code>setAnnotatedType()</code> replaces the <code>AnnotatedType</code>.</p>
</li>
<li>
<p><code>configureAnnotatedType()</code> returns an <code>AnnotatedTypeConfigurator</code> (as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a>) initialized with the <code>AnnotatedType</code> processed by the event to easily configure the <code>AnnotatedType</code> which will be used to replace the original one at the end of observer invocation.
The method always returns the same <code>AnnotatedTypeConfigurator</code></p>
</li>
<li>
<p><code>veto()</code> forces the container to ignore the type.</p>
</li>
<li>
<p><code>getSource()</code> returns the <code>Extension</code> instance that added the annotated type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any observer of this event is permitted to wrap and/or replace the <code>AnnotatedType</code> by calling either <code>setAnnotatedType()</code> or <code>configureAnnotatedType()</code>.
If both methods are called within an observer notification an <code>IllegalStateException</code> is thrown.
The container must use the final value of this property, after all observers have been called, as the only source of types and annotations for the program elements.</p>
</div>
<div class="paragraph">
<p>For example, the following observer decorates the <code>AnnotatedType</code> for every class that is discovered by the container.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&lt;T&gt; <span class="type">void</span> decorateAnnotatedType(<span class="annotation">@Observes</span> ProcessAnnotatedType&lt;T&gt; pat) {
    pat.setAnnotatedType( decorate( pat.getAnnotatedType() ) );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any observer method of a <code>ProcessAnnotatedType</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>ProcessAnnotatedType</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="process_injection_point"><a class="anchor" href="#process_injection_point"></a>11.5.7. <code>ProcessInjectionPoint</code> event</h4>
<div class="paragraph">
<p>The container must fire an event for every injection point of every bean, interceptor or decorator.</p>
</div>
<div class="paragraph">
<p>The event object must be of type <code>jakarta.enterprise.inject.spi.ProcessInjectionPoint&lt;T, X&gt;</code> where <code>T</code> is the bean class, and <code>X</code> is the declared type of the injection point.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessInjectionPoint</span>&lt;T, X&gt; {
    <span class="directive">public</span> InjectionPoint getInjectionPoint();
    <span class="directive">public</span> <span class="type">void</span> setInjectionPoint(InjectionPoint injectionPoint);
    <span class="directive">public</span> InjectionPointConfigurator configureInjectionPoint();
    <span class="directive">public</span> <span class="type">void</span> addDefinitionError(<span class="predefined-type">Throwable</span> t);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInjectionPoint()</code> returns the <code>InjectionPoint</code> object that will be used by the container to perform injection.</p>
</li>
<li>
<p><code>setInjectionPoint()</code> replaces the <code>InjectionPoint</code>.</p>
</li>
<li>
<p><code>configureInjectionPoint()</code> returns an <code>InjectionPointConfigurator</code> (as defined in <a href="#injection_point_configurator"><code>InjectionPointConfigurator</code> interface</a>) initialized with the <code>InjectionPoint</code> processed by the event to easily configure the  <code>InjectionPoint</code> which will be used to replace the original one at the end of observer invocation.
The method always returns the same <code>InjectionPointConfigurator</code>.</p>
</li>
<li>
<p><code>addDefinitionError()</code> registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any observer of this event is permitted to wrap and/or replace the <code>InjectionPoint</code> by calling either <code>setInjectionPoint()</code> or <code>configureInjectionPoint()</code>.
If both methods are called within an observer notification an <code>IllegalStateException</code> is thrown.
The container must use the final value of this property, after all observers have been called, whenever it performs injection upon the injection point.</p>
</div>
<div class="paragraph">
<p>If any observer method of a <code>ProcessInjectionPoint</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>ProcessInjectionPoint</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="sect4">
<h5 id="injection_point_configurator"><a class="anchor" href="#injection_point_configurator"></a>11.5.7.1. <code>InjectionPointConfigurator</code> interface</h5>
<div class="paragraph">
<p>CDI 2.0 introduced the <code>jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator</code> interface to help configure an existing <code>InjectionPoint</code> instance.</p>
</div>
<div class="paragraph">
<p>With <code>InjectionPointConfigurator</code> you can perform the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set the type of <code>InjectionPoint</code> with <code>type</code> method.</p>
</li>
<li>
<p>Add a qualifier with <code>addQualifier</code> method.</p>
</li>
<li>
<p>Set or add multiple qualifiers with <code>addQualifiers</code> and <code>qualifiers</code> methods.</p>
</li>
<li>
<p>Make the injection point delegate with <code>delegate</code> method.</p>
</li>
<li>
<p>Make the injection point a transient field with <code>transientField</code> method.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="process_injection_target"><a class="anchor" href="#process_injection_target"></a>11.5.8. <code>ProcessInjectionTarget</code> event</h4>
<div class="paragraph">
<p>The container must fire an event for every bean, interceptor or decorator.</p>
</div>
<div class="paragraph">
<p>The event object must be of type <code>jakarta.enterprise.inject.spi.ProcessInjectionTarget&lt;X&gt;</code>, where <code>X</code> is the bean class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessInjectionTarget</span>&lt;X&gt; {
    <span class="directive">public</span> AnnotatedType&lt;X&gt; getAnnotatedType();
    <span class="directive">public</span> InjectionTarget&lt;X&gt; getInjectionTarget();
    <span class="directive">public</span> <span class="type">void</span> setInjectionTarget(InjectionTarget&lt;X&gt; injectionTarget);
    <span class="directive">public</span> <span class="type">void</span> addDefinitionError(<span class="predefined-type">Throwable</span> t);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotatedType()</code> returns the <code>AnnotatedType</code> representing the bean class.</p>
</li>
<li>
<p><code>getInjectionTarget()</code> returns the <code>InjectionTarget</code> object that will be used by the container to perform injection.</p>
</li>
<li>
<p><code>setInjectionTarget()</code> replaces the <code>InjectionTarget</code>.</p>
</li>
<li>
<p><code>addDefinitionError()</code> registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any observer of this event is permitted to wrap and/or replace the <code>InjectionTarget</code>. The container must use the final value of this property, after all observers have been called, whenever it performs injection upon the managed bean.</p>
</div>
<div class="paragraph">
<p>If any observer method of a <code>ProcessInjectionTarget</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>ProcessInjectionTarget</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="process_bean_attributes"><a class="anchor" href="#process_bean_attributes"></a>11.5.9. <code>ProcessBeanAttributes</code> event</h4>
<div class="paragraph">
<p>The container must fire an event for each managed bean, producer, interceptor or decorator deployed in a bean archive, before registering the <code>Bean</code> object.
No event is fired for any:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@New</code> qualified bean, defined in <a href="#new"><code>@New</code> qualified beans</a>, or,</p>
</li>
<li>
<p>beans added programmatically using <code>AfterBeanDiscovery.addBean()</code>, or,</p>
</li>
<li>
<p>for any built-in beans.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The event object must be of type <code>jakarta.enterprise.inject.spi.ProcessBeanAttributes&lt;T&gt;</code> where <code>T</code> is the bean class of the bean, the return type of the producer method, or the type of the producer field.</p>
</div>
<div class="paragraph">
<p>Resources are considered to be producer fields.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessBeanAttributes</span>&lt;T&gt; {
    <span class="directive">public</span> Annotated getAnnotated();
    <span class="directive">public</span> BeanAttributes&lt;T&gt; getBeanAttributes();
    <span class="directive">public</span> <span class="type">void</span> setBeanAttributes(BeanAttributes&lt;T&gt; beanAttributes);
    <span class="directive">public</span> BeanAttributesConfigurator&lt;T&gt; configureBeanAttributes();
    <span class="directive">public</span> <span class="type">void</span> addDefinitionError(<span class="predefined-type">Throwable</span> t);
    <span class="directive">public</span> <span class="type">void</span> veto();
    <span class="directive">public</span> <span class="type">void</span> ignoreFinalMethods();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotated()</code> returns the <code>AnnotatedType</code> representing the bean class, the <code>AnnotatedMethod</code> representing the producer field, or the <code>AnnotatedField</code> representing the producer field.</p>
</li>
<li>
<p><code>getBeanAttributes()</code> returns the <code>BeanAttributes</code> object that will be used by the container to manage instances of the bean.</p>
</li>
<li>
<p><code>setBeanAttributes()</code> replaces the <code>BeanAttributes</code>.</p>
</li>
<li>
<p><code>configureBeanAttributes()</code> returns a <code>BeanAttributesConfigurator</code> (as defined in <a href="#bean_attributes_configurator"><code>BeanAttributesConfigurator</code> interface</a>) initialized with the <code>BeanAttributes</code> processed by the event to easily configure the  <code>BeanAttributes</code> which will be used to replace the original one at the end of observer invocation.
The method always returns the same <code>BeanAttributesConfigurator</code>.</p>
</li>
<li>
<p><code>addDefinitionError()</code> registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</p>
</li>
<li>
<p><code>veto()</code> forces the container to ignore the bean.</p>
</li>
<li>
<p><code>ignoreFinalMethods()</code> Instructs the container to ignore all non-static, final methods with public, protected or default visibility declared on any bean type of the specific bean during validation of injection points that require proxyable bean type.
These method should never be invoked upon bean instances.
Otherwise, unpredictable behavior results.
It will bypass standard rules defined in <a href="#unproxyable">Unproxyable bean types</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any observer of this event is permitted to wrap and/or replace the <code>BeanAttributes</code> by calling either <code>setBeanAttributes()</code> or <code>configureBeanAttributes()</code>.
If both methods are called within an observer notification an <code>IllegalStateException</code> is thrown.
The container must use the final value of this property, after all observers have been called, to manage instances of the bean.
Changes to <code>BeanAttributes</code> are <em>not</em> propagated to the annotated type from which the bean definition was created.</p>
</div>
<div class="paragraph">
<p>Any bean which has its bean attributes altered must have it&#8217;s definition validated during deployment validation.</p>
</div>
<div class="paragraph">
<p>If any observer method of a <code>ProcessBeanAttributes</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>ProcessBeanAttributes</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="sect4">
<h5 id="bean_attributes_configurator"><a class="anchor" href="#bean_attributes_configurator"></a>11.5.9.1. <code>BeanAttributesConfigurator</code> interface</h5>
<div class="paragraph">
<p>CDI 2.0 introduced the <code>jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator</code> interface to help configuring a new <code>BeanAttributes</code> instance.</p>
</div>
<div class="paragraph">
<p><code>BeanAttributesConfigurator</code> is obtainable during <code>ProcessBeanAttributes</code> event and is therefore automatically initialized from existing <code>BeanAttributes</code>.</p>
</div>
<div class="paragraph">
<p>With <code>BeanAttributesConfigurator</code> you can perform the following operations :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add type with <code>addType</code> or <code>addTransitiveTypeClosure</code> methods.</p>
</li>
<li>
<p>Set multiple types with <code>types</code> methods.</p>
</li>
<li>
<p>Set scope with <code>scope</code> method.</p>
</li>
<li>
<p>Add a qualifier with <code>addQualifier</code> method.</p>
</li>
<li>
<p>Set or add multiple qualifiers with <code>addQualifiers</code> and <code>qualifiers</code> methods.</p>
</li>
<li>
<p>Add a stereotype with <code>addStereotype</code> method.</p>
</li>
<li>
<p>Set or add multiple stereotypes with <code>addStereotypes</code> and <code>stereotypes</code> methods.</p>
</li>
<li>
<p>Set the bean name <code>name</code> method.</p>
</li>
<li>
<p>Make the bean an alternative with <code>alternative</code> methods.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="process_bean"><a class="anchor" href="#process_bean"></a>11.5.10. <code>ProcessBean</code> event</h4>
<div class="paragraph">
<p>The container must fire an event for each bean, interceptor or decorator deployed in a bean archive, after firing the <code>ProcessBeanAttributes</code> for the bean and before registering the <code>Bean</code> object.
No event is fired for any <code>@New</code> qualified bean, defined in <a href="#new"><code>@New</code> qualified beans</a>.</p>
</div>
<div class="paragraph">
<p>The event object type in the package <code>jakarta.enterprise.inject.spi</code> depends upon what kind of bean was discovered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For a managed bean with bean class <code>X</code>, the container must raise an event of type <code>ProcessManagedBean&lt;X&gt;</code>.</p>
</li>
<li>
<p>For a producer method with method return type <code>T</code> of a bean with bean class <code>X</code>, the container must raise an event of type <code>ProcessProducerMethod&lt;T, X&gt;</code>.</p>
</li>
<li>
<p>For a producer field with field type <code>T</code> of a bean with bean class <code>X</code>, the container must raise an event of type <code>ProcessProducerField&lt;T, X&gt;</code>.</p>
</li>
<li>
<p>For a custom implementation of <code>Bean</code>, the container must raise an event of type <code>ProcessSyntheticBean&lt;X&gt;</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The interface <code>jakarta.enterprise.inject.spi.ProcessBean</code> is a supertype of all these event types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessBean</span>&lt;X&gt; {
    <span class="directive">public</span> Annotated getAnnotated();
    <span class="directive">public</span> Bean&lt;X&gt; getBean();
    <span class="directive">public</span> <span class="type">void</span> addDefinitionError(<span class="predefined-type">Throwable</span> t);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotated()</code> returns the <code>AnnotatedType</code> representing the bean class, the <code>AnnotatedMethod</code> representing the producer method, or the <code>AnnotatedField</code> representing the producer field. If invoked upon a <code>ProcessSyntheticBean</code> event, non-portable behavior results and the returned value should be ignored.</p>
</li>
<li>
<p><code>getBean()</code> returns the <code>Bean</code> object that is about to be registered.
The <code>Bean</code> may implement <code>Interceptor</code> or <code>Decorator</code>.</p>
</li>
<li>
<p><code>addDefinitionError()</code> registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessManagedBean</span>&lt;X&gt;
        <span class="directive">extends</span> ProcessBean&lt;X&gt; {
    <span class="directive">public</span> AnnotatedType&lt;X&gt; getAnnotatedBeanClass();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessProducerMethod</span>&lt;T, X&gt;
        <span class="directive">extends</span> ProcessBean&lt;X&gt; {
    <span class="directive">public</span> AnnotatedMethod&lt;T&gt; getAnnotatedProducerMethod();
    <span class="directive">public</span> AnnotatedParameter&lt;T&gt; getAnnotatedDisposedParameter();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessProducerField</span>&lt;T, X&gt;
        <span class="directive">extends</span> ProcessBean&lt;X&gt; {
    <span class="directive">public</span> AnnotatedField&lt;T&gt; getAnnotatedProducerField();
    <span class="directive">public</span> AnnotatedParameter&lt;T&gt; getAnnotatedDisposedParameter();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessSyntheticBean</span>&lt;X&gt;
        <span class="directive">extends</span> ProcessBean&lt;X&gt; {
    <span class="directive">public</span> Extension getSource();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any observer method of a <code>ProcessBean</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>ProcessBean</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="process_producer"><a class="anchor" href="#process_producer"></a>11.5.11. <code>ProcessProducer</code> event</h4>
<div class="paragraph">
<p>The container must fire an event for each producer method or field of each bean, including resources.</p>
</div>
<div class="paragraph">
<p>The event object must be of type <code>jakarta.enterprise.inject.spi.ProcessProducer&lt;T, X&gt;</code>, where <code>T</code> is the bean class of the bean that declares the producer method or field and <code>X</code> is the return type of the producer method or the type of the producer field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessProducer</span>&lt;T, X&gt; {
    <span class="directive">public</span> AnnotatedMember&lt;T&gt; getAnnotatedMember();
    <span class="directive">public</span> Producer&lt;X&gt; getProducer();
    <span class="directive">public</span> <span class="type">void</span> setProducer(Producer&lt;X&gt; producer);
    <span class="directive">public</span> ProducerConfigurator&lt;X&gt; configureProducer();
    <span class="directive">public</span> <span class="type">void</span> addDefinitionError(<span class="predefined-type">Throwable</span> t);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotatedMember()</code> returns the <code>AnnotatedField</code> representing the producer field or the <code>AnnotatedMethod</code> representing the producer method.</p>
</li>
<li>
<p><code>getProducer()</code> returns the <code>Producer</code> object that will be used by the container to call the producer method or read the producer field.</p>
</li>
<li>
<p><code>setProducer()</code> replaces the <code>Producer</code>.</p>
</li>
<li>
<p><code>configureProducer()</code> returns a <code>ProducerConfigurator</code> (as defined in <a href="#producer_configurator"><code>ProducerConfigurator</code> interface</a>) initialized with the <code>Producer</code> processed by this event to configure the <code>Producer</code> that will replace the original one at the end of the observer invocation. Each call returns the same configurator instance within an observer notification.</p>
</li>
<li>
<p><code>addDefinitionError()</code> registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any observer of this event is permitted to wrap and/or replace the <code>Producer</code> by calling either <code>setProducer()</code> or <code>configureProducer()</code>.
If both methods are called within an observer notification an <code>IllegalStateException</code> is thrown.
The container must use the final value of this property, after all observers have been called, whenever it calls the producer or disposer.</p>
</div>
<div class="paragraph">
<p>For example, this observer decorates the <code>Producer</code> for all producer methods and fields of type <code>EntityManager</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> decorateEntityManager(<span class="annotation">@Observes</span> ProcessProducer&lt;?, EntityManager&gt; pp) {
    pit.setProducer( decorate( pp.getProducer() ) );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If any observer method of a <code>ProcessProducer</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>ProcessProducer</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="sect4">
<h5 id="producer_configurator"><a class="anchor" href="#producer_configurator"></a>11.5.11.1. <code>ProducerConfigurator</code> interface</h5>
<div class="paragraph">
<p>CDI 2.0 introduced the <code>jakarta.enterprise.inject.spi.configurator.ProducerConfigurator</code> interface to help configuring a <code>Producer</code> instance.</p>
</div>
<div class="paragraph">
<p>With <code>ProducerConfigurator</code> you can perform the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Set a callback to produce a new instance with <code>produceWith()</code> method.</p>
</li>
<li>
<p>Set a callback to destroy the produced instance with <code>disposeWith()</code> method.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="process_observer_method"><a class="anchor" href="#process_observer_method"></a>11.5.12. <code>ProcessObserverMethod</code> event</h4>
<div class="paragraph">
<p>The container must fire an event for each observer method of each enabled bean, before registering the <code>ObserverMethod</code> object.</p>
</div>
<div class="paragraph">
<p>The event object must be of type <code>jakarta.enterprise.inject.spi.ProcessObserverMethod&lt;T, X&gt;</code>, where <code>T</code> is the observed event type of the observer method and <code>X</code> is the bean class of the bean that declares the observer method.</p>
</div>
<div class="paragraph">
<p>For a custom implementation of <code>jakarta.enterprise.inject.spi.ObserverMethod</code>, the container must raise an event of type <code>jakarta.enterprise.inject.spi.ProcessSyntheticObserverMethod&lt;T, X&gt;</code>, where <code>T</code> is the observed event type of the observer method and <code>X</code> is the return value of <code>ObserverMethod.getBeanClass()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessObserverMethod</span>&lt;T, X&gt; {
    <span class="directive">public</span> AnnotatedMethod&lt;X&gt; getAnnotatedMethod();
    <span class="directive">public</span> ObserverMethod&lt;T&gt; getObserverMethod();
    <span class="directive">public</span> <span class="type">void</span> addDefinitionError(<span class="predefined-type">Throwable</span> t);
    <span class="directive">public</span> <span class="type">void</span> setObserverMethod(ObserverMethod&lt;T&gt; observerMethod);
    <span class="directive">public</span> ObserverMethodConfigurator&lt;T&gt; setObserverMethod();
    <span class="directive">public</span> <span class="type">void</span> veto();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessSyntheticObserverMethod</span>&lt;T, X&gt; <span class="directive">extends</span> ProcessObserverMethod&lt;T, X&gt; {
    <span class="directive">public</span> Extension getSource();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getAnnotatedMethod()</code> returns the <code>AnnotatedMethod</code> representing the observer method. If invoked upon a <code>ProcessSyntheticObserverMethod</code> event, non-portable behavior results and the returned value should be ignored.</p>
</li>
<li>
<p><code>getObserverMethod()</code> returns the <code>ObserverMethod</code> object that will be used by the container to call the observer method.</p>
</li>
<li>
<p><code>addDefinitionError()</code> registers a definition error with the container, causing the container to abort deployment after bean discovery is complete.</p>
</li>
<li>
<p><code>setObserverMethod()</code> replaces the <code>ObserverMethod</code>.</p>
</li>
<li>
<p><code>configureObserverMethod()</code> returns an <code>ObserverMethodConfigurator</code> (as defined in <a href="#observer_method_configurator"><code>ObserverMethodConfigurator</code> interface</a>) initialized with the <code>ObserverMethod</code> processed by the event to easily configure the  <code>ObserverMethod</code> which will be used to replace the original one at the end of observer invocation.
The method always returns the same <code>ObserverMethodConfigurator</code>.</p>
</li>
<li>
<p><code>veto()</code> forces the container to ignore the <code>ObserverMethod</code>.</p>
</li>
<li>
<p><code>getSource()</code> returns the <code>Extension</code> instance that added the observer method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any observer of this event is permitted to wrap and/or replace the <code>ObserverMethod</code> by calling either <code>setObserverMethod()</code> or <code>configureObserverMethod()</code>.
If both methods are called within an observer notification an <code>IllegalStateException</code> is thrown.
The container must use the final value of this property, after all observers have been called, whenever it performs observer resolution.</p>
</div>
<div class="paragraph">
<p>If any observer method of a <code>ProcessObserverMethod</code> event throws an exception, the exception is treated as a definition error by the container.</p>
</div>
<div class="paragraph">
<p>If any <code>ProcessObserverMethod</code> method is called outside of the observer method invocation, an <code>IllegalStateException</code> is thrown.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configurators"><a class="anchor" href="#configurators"></a>11.6. Configurators interfaces</h3>
<div class="paragraph">
<p>CDI 2.0 introduced the following Configurators interface:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a> for <code>AnnotatedType</code> configuration</p>
</li>
<li>
<p><a href="#injection_point_configurator"><code>InjectionPointConfigurator</code> interface</a> for <code>InjectionPoint</code> configuration</p>
</li>
<li>
<p><a href="#bean_attributes_configurator"><code>BeanAttributesConfigurator</code> interface</a> for <code>BeanAttributes</code> configuration</p>
</li>
<li>
<p><a href="#bean_configurator"><code>BeanConfigurator</code> interface</a> for <code>Bean</code> configuration</p>
</li>
<li>
<p><a href="#observer_method_configurator"><code>ObserverMethodConfigurator</code> interface</a> for <code>ObserverMethod</code> configuration</p>
</li>
<li>
<p><a href="#producer_configurator"><code>ProducerConfigurator</code> interface</a> for <code>Producer</code> configuration</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container must provide implementation for all these configurators and make them available in matching container lifecycle events as defined in <a href="#init_events">Container lifecycle events</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="interception_factory"><a class="anchor" href="#interception_factory"></a>11.7. The <code>InterceptionFactory</code> interface</h3>
<div class="paragraph">
<p>CDI 2.0 introduces the <code>jakarta.enterprise.inject.spi.InterceptionFactory&lt;T&gt;</code> interface, which allows to create a wrapper instance whose method invocations are intercepted by method interceptors and forwarded to a provided instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">InterceptionFactory</span>&lt;T&gt; {
    InterceptionFactory&lt;T&gt; ignoreFinalMethods();
    AnnotatedTypeConfigurator&lt;T&gt; configure();
    T createInterceptedInstance(T instance);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ignoreFinalMethods()</code> instructs the container to ignore all non-static, final methods with public, protected or default visibility declared by any class in the type hierarchy of the intercepted instance during invocation of <code>createInterceptedInstance()</code> method.
Ignored methods should never be invoked upon the wrapper instance.
Otherwise, unpredictable behavior results.</p>
</li>
<li>
<p><code>configure()</code> returns an <code>AnnotatedTypeConfigurator</code> (as defined in <a href="#annotated_type_configurator"><code>AnnotatedTypeConfigurator</code> SPI</a>)
initialized with the <code>AnnotatedType</code> created either for the class passed to <code>BeanManager.createInterceptionFactory(CreationalContext, Class)</code> or derived from the <code>InterceptionFactory</code> parameter injection point.
The method always return the same <code>AnnotatedTypeConfigurator</code></p>
</li>
<li>
<p><code>createInterceptedInstance()</code> returns a wrapper instance whose method invocations are intercepted by method interceptors and forwarded to a provided instance.
The method can be only called once, subsequent calls will throw an <code>IllegalStateException</code>.
If the type of the instance is not proxyable as defined in <a href="#unproxyable">Unproxyable bean types</a> an <code>UnproxyableResolutionException</code> exception is thrown.
This rule can be loosen by calling <code>ignoreFinalMethods()</code> before this method.
If the provided instance is an internal container construct (such as client proxy), non-portable behavior results.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An <code>InterceptionFactory</code> can be obtained be calling <code>BeanManager.createInterceptionFactory()</code> as defined in <a href="#bm_obtain_interception_factory">Obtain an <code>InterceptionFactory</code></a>.</p>
</div>
<div class="paragraph">
<p>The container must provide a built-in bean with scope <code>@Dependent</code>, bean type <code>InterceptionFactory</code> and qualifier <code>@Default</code>.</p>
</div>
<div class="paragraph">
<p>If an injection point of type <code>InterceptionFactory</code> and qualifier <code>@Default</code> exists and is not a parameter of a producer method, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If an injection point of type <code>InterceptionFactory</code> has a type parameter that is not a Java class, non-portable behavior results.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates a producer method definition using <code>InterceptionFactory</code>. The produced bean instance will be a wrapper of <code>Product</code> with single interceptor associated by <code>ActionBinding</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span>
<span class="annotation">@RequestScoped</span>
<span class="directive">public</span> Product createInterceptedProduct(InterceptionFactory&lt;Product&gt; interceptionFactory) {
  interceptionFactory.configure().add(ActionBinding.Literal.INSTANCE);
  <span class="keyword">return</span> interceptionFactory.createInterceptedInstance(<span class="keyword">new</span> Product());
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="packaging_deployment"><a class="anchor" href="#packaging_deployment"></a>12. Packaging and deployment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When an application is started, the container must perform <em>bean discovery</em>, detect definition errors and deployment problems and raise events that allow portable extensions to integrate with the deployment lifecycle.</p>
</div>
<div class="paragraph">
<p>Bean discovery is the process of determining:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The bean archives that exist in the application, and the beans they contain</p>
</li>
<li>
<p>Which alternatives, interceptors and decorators are <em>enabled</em> for each bean archive</p>
</li>
<li>
<p>The <em>ordering</em> of enabled interceptors and decorators</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additional beans may be registered programmatically with the container by the application or a portable extension after the automatic bean discovery completes.
Portable extensions may even integrate with the process of building the <code>Bean</code> object for a bean, to enhance the container&#8217;s built-in functionality.</p>
</div>
<div class="sect2">
<h3 id="bean_archive"><a class="anchor" href="#bean_archive"></a>12.1. Bean archives</h3>
<div class="paragraph">
<p>Bean classes of enabled beans must be deployed in <em>bean archives</em>.</p>
</div>
<div class="paragraph">
<p>A bean archive has a <em>bean discovery mode</em> of <code>all</code>, <code>annotated</code> or <code>none</code>. A bean archive which contains a <code>beans.xml</code> file with no version has a default bean discovery mode of <code>all</code>. A bean archive which contains a <code>beans.xml</code> file with version 1.1 (or later) must specify the <code>bean-discovery-mode</code> attribute. The default value for the attribute is <code>annotated</code>.</p>
</div>
<div class="paragraph">
<p>An archive which:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>contains a <code>beans.xml</code> file with the <code>bean-discovery-mode</code> of <code>none</code>, or,</p>
</li>
<li>
<p>contains an extension and no <code>beans.xml</code> file</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>is not a bean archive.</p>
</div>
<div class="paragraph">
<p>An <em>explicit bean archive</em> is an archive which contains a <code>beans.xml</code> file:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>with a version number of <code>1.1</code> (or later), with the <code>bean-discovery-mode</code> of <code>all</code>, or,</p>
</li>
<li>
<p>with no version number, or,</p>
</li>
<li>
<p>that is an empty file.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An <em>implicit bean archive</em> is any other archive which contains one or more bean classes with a bean defining annotation as defined in <a href="#bean_defining_annotations">Bean defining annotations</a>.</p>
</div>
<div class="paragraph">
<p>When determining which archives are bean archives, the container must consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Library jars</p>
</li>
<li>
<p>Directories in the JVM classpath</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Non Jakarta EE containers may or may not provide support for war, EJB jar or rar bean archives.</p>
</div>
<div class="paragraph">
<p>The <code>beans.xml</code> file must be named:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>META-INF/beans.xml</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For compatibility with Contexts and Dependency 1.0, products must contain an option to cause an archive to be ignored by the container when no <code>beans.xml</code> is present.</p>
</div>
<div class="paragraph">
<p>The container searches for beans in all bean archives in the application classpath.</p>
</div>
<div class="paragraph">
<p>If a bean class is deployed in two different bean archives, non-portable behavior results.
Portable applications must deploy each bean class in no more than one bean archive.</p>
</div>
<div class="paragraph">
<p>Explicit bean archives may contain classes which are not deployed as beans.
For example a bean archive might contain an abstract class not annotated with <code>@Decorator</code>.</p>
</div>
<div class="paragraph">
<p>Implicit bean archives are likely to contain classes which are not deployed as beans.</p>
</div>
<div class="paragraph">
<p>An extension may be deployed in any archive, including those that are not bean archives.</p>
</div>
</div>
<div class="sect2">
<h3 id="initialization"><a class="anchor" href="#initialization"></a>12.2. Application initialization lifecycle</h3>
<div class="paragraph">
<p>When an application is started, the container performs the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, the container must search for service providers for the service <code>jakarta.enterprise.inject.spi.Extension</code> defined in <a href="#init_events">Container lifecycle events</a>, instantiate a single instance of each service provider, and search the service provider class for observer methods of initialization events.</p>
</li>
<li>
<p>Next, the container must fire an event of type <code>BeforeBeanDiscovery</code>, as defined in <a href="#before_bean_discovery"><code>BeforeBeanDiscovery</code> event</a>.</p>
</li>
<li>
<p>Next, the container must perform type discovery, as defined in <a href="#type_discovery_steps">Type discovery</a>.</p>
</li>
<li>
<p>Next, the container must fire an event of type <code>AfterTypeDiscovery</code>, as defined in <a href="#after_type_discovery"><code>AfterTypeDiscovery</code> event</a>.</p>
</li>
<li>
<p>Next, the container must perform bean discovery, as defined in <a href="#bean_discovery_steps">Bean discovery</a>.</p>
</li>
<li>
<p>Next, the container must fire an event of type <code>AfterBeanDiscovery</code>, as defined in <a href="#after_bean_discovery"><code>AfterBeanDiscovery</code> event</a>, and abort initialization of the application if any observer registers a definition error.</p>
</li>
<li>
<p>Next, the container must detect deployment problems by validating bean dependencies and specialization and abort initialization of the application if any deployment problems exist, as defined in <a href="#exceptions">Problems detected automatically by the container</a>.</p>
</li>
<li>
<p>Next, the container must fire an event of type <code>AfterDeploymentValidation</code>, as defined in <a href="#after_deployment_validation"><code>AfterDeploymentValidation</code> event</a>, and abort initialization of the application if any observer registers a deployment problem.</p>
</li>
<li>
<p>Finally, the container begins directing requests to the application.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="shutdown"><a class="anchor" href="#shutdown"></a>12.3. Application shutdown lifecycle</h3>
<div class="paragraph">
<p>When an application is stopped, the container performs the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, the container must destroy all contexts.</p>
</li>
<li>
<p>Finally, the container must fire an event of type <code>BeforeShutdown</code>, as defined in <a href="#before_shutdown"><code>BeforeShutdown</code> event</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="type_bean_discovery"><a class="anchor" href="#type_bean_discovery"></a>12.4. Type and Bean discovery</h3>
<div class="paragraph">
<p>The container automatically discovers managed beans (according to the rules of <a href="#what_classes_are_beans">Which Java classes are managed beans?</a>) in bean archives and searches the bean classes for producer methods, producer fields, disposer methods and observer methods.</p>
</div>
<div class="sect3">
<h4 id="type_discovery_steps"><a class="anchor" href="#type_discovery_steps"></a>12.4.1. Type discovery</h4>
<div class="paragraph">
<p>First the container must discover types.
The container discovers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>each Java class, interface (excluding the special kind of interface declaration <em>annotation type</em>) or enum deployed in an explicit bean archive, and</p>
</li>
<li>
<p>each Java class with a bean defining annotation in an implicit bean archive.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>that is not excluded from discovery by an <em>exclude filter</em> as defined in <a href="#exclude_filters">Exclude filters</a>.</p>
</div>
<div class="paragraph">
<p>Then, for every type discovered the container must create an <code>AnnotatedType</code> representing the type and fire an event of type <code>ProcessAnnotatedType</code>, as defined in <a href="#process_annotated_type"><code>ProcessAnnotatedType</code> event</a>.</p>
</div>
<div class="paragraph">
<p>If an extension calls <code>BeforeBeanDiscovery.addAnnotatedType()</code> or <code>AfterTypeDiscovery.addAnnotatedType()</code>, the type passed must be added to the set of discovered types and the container must fire an event of type <code>ProcessSyntheticAnnotatedType</code> for every type added, as defined in <a href="#process_annotated_type"><code>ProcessAnnotatedType</code> event</a>+</p>
</div>
</div>
<div class="sect3">
<h4 id="exclude_filters"><a class="anchor" href="#exclude_filters"></a>12.4.2. Exclude filters</h4>
<div class="paragraph">
<p>Exclude filters are defined by <code>&lt;exclude&gt;</code> elements in the <code>beans.xml</code> for the bean archive as children of the <code>&lt;scan&gt;</code> element.
By default an exclude filter is active. If the exclude filter definition contains:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a child element named <code>&lt;if-class-available&gt;</code> with a <code>name</code> attribute, and the classloader for the bean archive can not load a class for that name, or</p>
</li>
<li>
<p>a child element named <code>&lt;if-class-not-available&gt;</code> with a <code>name</code> attribute, and the classloader for the bean archive can load a class for that name, or</p>
</li>
<li>
<p>a child element named <code>&lt;if-system-property&gt;</code> with a <code>name</code> attribute, and there is no system property defined for that name, or</p>
</li>
<li>
<p>a child element named <code>&lt;if-system-property&gt;</code> with a <code>name</code> attribute and a <code>value</code> attribute, and there is no system property defined for that name with that value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>then the filter is inactive.</p>
</div>
<div class="paragraph">
<p>If the filter is active, and:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the fully qualified name of the type being discovered matches the value of the name attribute of the exclude filter, or</p>
</li>
<li>
<p>the package name of the type being discovered matches the value of the name attribute with a suffix ".*" of the exclude filter, or</p>
</li>
<li>
<p>the package name of the type being discovered starts with the value of the name attribute with a suffix ".**" of the exclude filter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>then we say that the type is excluded from discovery.</p>
</div>
<div class="paragraph">
<p>For example, consider the follow <code>beans.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee</span><span class="delimiter">&quot;</span></span>
       <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
       <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">xsi:schemaLocation=</span><span class="delimiter">&quot;</span></span><span class="attribute-name">https:</span><span class="error">/</span><span class="error">/</span><span class="attribute-name">jakarta.ee</span><span class="error">/</span><span class="attribute-name">xml</span><span class="error">/</span><span class="attribute-name">ns</span><span class="error">/</span><span class="attribute-name">jakartaee</span> <span class="attribute-name">https:</span><span class="error">/</span><span class="error">/</span><span class="attribute-name">jakarta.ee</span><span class="error">/</span><span class="attribute-name">xml</span><span class="error">/</span><span class="attribute-name">ns</span><span class="error">/</span><span class="attribute-name">jakartaee</span><span class="error">/</span><span class="attribute-name">beans_3_0.xsd</span><span class="error">&quot;</span>
       <span class="attribute-name">bean-discovery-mode</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">all</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">version</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

    <span class="tag">&lt;scan&gt;</span>
        <span class="tag">&lt;exclude</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.rest.*</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

        <span class="tag">&lt;exclude</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.faces.**</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
            <span class="tag">&lt;if-class-not-available</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jakarta.faces.context.FacesContext</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/exclude&gt;</span>

        <span class="tag">&lt;exclude</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.verbose.*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
            <span class="tag">&lt;if-system-property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">verbosity</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">low</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/exclude&gt;</span>

        <span class="tag">&lt;exclude</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.ejb.**</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
            <span class="tag">&lt;if-class-available</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jakarta.enterprise.inject.Model</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
            <span class="tag">&lt;if-system-property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exclude-ejbs</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/exclude&gt;</span>
    <span class="tag">&lt;/scan&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first exclude filter will exclude all classes in <code>com.acme.rest</code> package. The second exclude filter will exclude all classes in the <code>com.acme.faces</code> package, and any subpackages, but only if JSF is not available. The third exclude filter will exclude all classes in the <code>com.acme.verbose</code> package if the system property <code>verbosity</code> has the value <code>low</code>. The fourth exclude filter will exclude all classes in the <code>com.acme.ejb</code> package, and any subpackages if the system property <code>exclude-ejbs</code> is set (with any value) and at the same time, the <code>jakarta.enterprise.inject.Model</code> class is available to the classloader.</p>
</div>
</div>
<div class="sect3">
<h4 id="trimmed_bean_archive"><a class="anchor" href="#trimmed_bean_archive"></a>12.4.3. Trimmed bean archive</h4>
<div class="paragraph">
<p>An explicit bean archive may be marked as 'trimmed' by adding the <code>&lt;trim /&gt;</code> element to its <code>beans.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/beans_3_0.xsd</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">version</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

    <span class="tag">&lt;trim</span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If an explicit bean archive contains the <code>&lt;trim/&gt;</code> element in its <code>beans.xml</code> file, types that don&#8217;t have either a bean defining annotation (as defined in <a href="#bean_defining_annotations">Bean defining annotations</a>) or any scope annotation, are removed from the set of discovered types.</p>
</div>
</div>
<div class="sect3">
<h4 id="bean_discovery_steps"><a class="anchor" href="#bean_discovery_steps"></a>12.4.4. Bean discovery</h4>
<div class="paragraph">
<p>For every type in the set of discovered types (as defined in <a href="#type_discovery_steps">Type discovery</a>), the container must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>inspect the type metadata to determine if it is a bean, and then</p>
</li>
<li>
<p>detect definition errors by validating the class and its metadata, and then</p>
</li>
<li>
<p>if the class is a managed bean, fire an event of type <code>ProcessInjectionPoint</code> for each injection point in the class, as defined in <a href="#process_injection_point"><code>ProcessInjectionPoint</code> event</a>, and then</p>
</li>
<li>
<p>if the class is a managed bean, fire an event of type <code>ProcessInjectionTarget</code>, as defined in <a href="#process_injection_target"><code>ProcessInjectionTarget</code> event</a>, and then</p>
</li>
<li>
<p>determine which alternatives, interceptors and decorators are enabled, according to the rules defined in <a href="#enablement">Enabled and disabled beans</a>, <a href="#enabled_interceptors">Interceptor enablement and ordering</a> and <a href="#enabled_decorators">Decorator enablement and ordering</a>, and then</p>
</li>
<li>
<p>if the class is an enabled bean, interceptor or decorator, fire an event of type <code>ProcessBeanAttributes</code>, as defined in <a href="#process_bean_attributes"><code>ProcessBeanAttributes</code> event</a>, and then</p>
</li>
<li>
<p>if the class is an enabled bean, interceptor or decorator and if <code>ProcessBeanAttributes.veto()</code> wasn&#8217;t called in previous step, fire an event which is a subtype of <code>ProcessBean</code>, as defined in <a href="#process_bean"><code>ProcessBean</code> event</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For each enabled bean, the container must search the class for producer methods and fields, as defined in <a href="#producer_method">Producer methods</a> and in <a href="#producer_field">Producer fields</a>, including resources, and for each producer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if it is a producer method, fire an event of type <code>ProcessInjectionPoint</code> for each injection point in the method parameters, as defined in <a href="#process_injection_point"><code>ProcessInjectionPoint</code> event</a>, and then</p>
</li>
<li>
<p>fire an event of type <code>ProcessProducer</code>, as defined in <a href="#process_producer"><code>ProcessProducer</code> event</a>, and then</p>
</li>
<li>
<p>if the producer method or field is enabled, fire an event of type <code>ProcessBeanAttributes</code>, as defined in <a href="#process_bean_attributes"><code>ProcessBeanAttributes</code> event</a>, and then</p>
</li>
<li>
<p>if the producer method or field is enabled and if <code>ProcessBeanAttributes.veto()</code> wasn&#8217;t called in previous step, fire an event which is a subtype of <code>ProcessBean</code>, as defined in <a href="#process_bean"><code>ProcessBean</code> event</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For each enabled bean, the container must search for disposer methods as defined in <a href="#disposer_method">Disposer methods</a>, and for each disposer method:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>fire an event of type <code>ProcessInjectionPoint</code> for each injection point in the method parameters, as defined in <a href="#process_injection_point"><code>ProcessInjectionPoint</code> event</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For each enabled bean, the container must search the class for observer methods, and for each observer method:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>fire an event of type <code>ProcessInjectionPoint</code> for each injection point in the method parameters, as defined in <a href="#process_injection_point"><code>ProcessInjectionPoint</code> event</a>, and then</p>
</li>
<li>
<p>fire an event of type <code>ProcessObserverMethod</code>, as defined in <a href="#process_observer_method"><code>ProcessObserverMethod</code> event</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Then, the container registers the <code>Bean</code> and <code>ObserverMethod</code> objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For each enabled bean that is not an interceptor or decorator, the container registers an instance of the <code>Bean</code> interface defined in <a href="#bean">The <code>Bean</code> interface</a>.</p>
</li>
<li>
<p>For each enabled interceptor, the container registers an instance of the <code>Interceptor</code> interface defined in <a href="#interceptor">The <code>Interceptor</code> interface</a>.</p>
</li>
<li>
<p>For each enabled decorator, the container registers an instance of the <code>Decorator</code> interface defined in <a href="#decorator">The <code>Decorator</code> interface</a>.</p>
</li>
<li>
<p>For each observer method of every enabled bean, the container registers an instance of the <code>ObserverMethod</code> interface defined in <a href="#observer_method">The <code>ObserverMethod</code> interface</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<h1 id="part_2" class="sect0"><a class="anchor" href="#part_2"></a>Part II - CDI in Java SE</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>This part of the document specifies additional rules and features when using CDI in Java SE.
All content defined in <a href="#part_1">Part I - Core CDI</a> applies to this part.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="se_bootstrap"><a class="anchor" href="#se_bootstrap"></a>13. Bootstrapping a CDI container in Java SE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Java SE, the CDI container must be explicitly bootstrapped by the user.
This is performed by the <code>SeContainerInitializer</code> abstract class and its static method <code>newInstance()</code>.</p>
</div>
<div class="paragraph">
<p><code>SeContainerInitializer</code> is a <code>ServiceProvider</code> of the service <code>jakarta.enterprise.inject.se.SeContainerInitializer</code> declared in META-INF/services.
This class allows a user to configure the CDI container before it is bootstrapped.
The <code>SeContainerInitializer.initialize()</code> method bootstraps the container and returns a <code>SeContainer</code> instance.</p>
</div>
<div class="paragraph">
<p>User can shutdown the container manually by calling the <code>close()</code> method on <code>SeContainer</code> or automatically using try-with-resources since <code>SeContainer</code> extends <code>AutoCloseable</code> interface.</p>
</div>
<div class="sect2">
<h3 id="se_container_initializer"><a class="anchor" href="#se_container_initializer"></a>13.1. <code>SeContainerInitializer</code> class</h3>
<div class="paragraph">
<p>CDI container can be configured and bootstrapped from <code>jakarta.enterprise.inject.se.SeContainerInitializer</code> abstract class.</p>
</div>
<div class="paragraph">
<p>A CDI implementation is required to provide an implementation of <code>SeContainerInitializer</code> declared as a service provider.
Static method <code>newInstance()</code> uses Java service provider mechanism to obtain an implementation of <code>SeContainerInitializer</code> and return an instance of it.
There must be exactly one provider available, otherwise an IllegalStateException is thrown.</p>
</div>
<div class="paragraph">
<p><code>SeContainerInitializer</code> configuration allows explicit addition of elements to the set of automatically discovered elements.
These additions are done in an internal synthetic bean archive that is added to the set of bean archives discovered by the container during deployment.</p>
</div>
<div class="paragraph">
<p>This synthetic bean archive behaves like an explicit bean archive (as defined in <a href="#bean_archive">Bean archives</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">SeContainerInitializer</span> {
    <span class="directive">public</span> <span class="directive">static</span> SeContainerInitializer newInstance() { ... }
    <span class="directive">public</span> SeContainerInitializer addBeanClasses(<span class="predefined-type">Class</span>&lt;?&gt;... classes);
    <span class="directive">public</span> SeContainerInitializer addPackages(<span class="predefined-type">Class</span>&lt;?&gt;... packageClasses);
    <span class="directive">public</span> SeContainerInitializer addPackages(<span class="type">boolean</span> scanRecursively, <span class="predefined-type">Class</span>&lt;?&gt;... packageClasses);
    <span class="directive">public</span> SeContainerInitializer addPackages(<span class="predefined-type">Package</span>... packages);
    <span class="directive">public</span> SeContainerInitializer addPackages(<span class="type">boolean</span> scanRecursively, <span class="predefined-type">Package</span>... packages);
    <span class="directive">public</span> SeContainerInitializer addExtensions(Extension... extensions);
    <span class="directive">public</span> SeContainerInitializer addExtensions(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> Extension&gt;... extensions);
    <span class="directive">public</span> SeContainerInitializer enableInterceptors(<span class="predefined-type">Class</span>&lt;?&gt;... interceptorClasses);
    <span class="directive">public</span> SeContainerInitializer enableDecorators(<span class="predefined-type">Class</span>&lt;?&gt;... decoratorClasses);
    <span class="directive">public</span> SeContainerInitializer selectAlternatives(<span class="predefined-type">Class</span>&lt;?&gt;... alternativeClasses);
    <span class="directive">public</span> SeContainerInitializer selectAlternativeStereotypes(<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt;... alternativeStereotypeClasses);
    <span class="directive">public</span> SeContainerInitializer addProperty(<span class="predefined-type">String</span> key, <span class="predefined-type">Object</span> value);
    <span class="directive">public</span> SeContainerInitializer setProperties(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; properties);
    <span class="directive">public</span> SeContainerInitializer disableDiscovery();
    <span class="directive">public</span> SeContainerInitializer setClassLoader(<span class="predefined-type">ClassLoader</span> classLoader);
    <span class="directive">public</span> SeContainer initialize();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unless specified differently each method of <code>SeContainerInitializer</code> returns the current <code>SeContainerInitializer</code> object.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>newInstance()</code> static method returns an instance of the implementation of <code>SeContainerInitializer</code> discovered by Java service provider.
Each call returns a new instance of <code>SeContainerInitializer</code>. This method throws <code>IllegalStateException</code> if called in Jakarta EE container.</p>
</li>
<li>
<p><code>addBeanClasses()</code> adds classes to the the synthetic bean archive</p>
</li>
<li>
<p><code>addPackages()</code> adds packages content to the synthetic bean archive.
There are other versions of this method, which enables user to add a package according to class or classes it contains and also to add packages recursively.</p>
</li>
<li>
<p><code>addExtensions()</code> adds the provided extensions (class or instance) to the synthetic bean archive.</p>
</li>
<li>
<p><code>enableInterceptors()</code> adds interceptor classes to the list of enabled interceptors for the synthetic bean archive.</p>
</li>
<li>
<p><code>enableDecorators()</code> adds decorator classes to the list of enabled decorators for the synthetic bean archive.</p>
</li>
<li>
<p><code>selectAlternatives()</code> adds alternatives classes to the list of selected alternatives for the synthetic bean archive.</p>
</li>
<li>
<p><code>selectAlternativeStereotypes()</code> adds alternative stereotype classes to the list of selected alternative stereotypes for the synthetic bean archive.</p>
</li>
<li>
<p><code>addProperty()</code> adds a configuration property to the container</p>
</li>
<li>
<p><code>setProperties()</code> sets the <code>Map</code> of configuration properties for the container.
Original properties <code>Map</code> is replaced by a new instance.</p>
</li>
<li>
<p><code>disableDiscovery()</code> deactivates automatic type scanning and discovery.
All bean archives will be ignored except the implicit bean archive.</p>
</li>
<li>
<p><code>setClassLoader()</code> changes the default class loader for the container</p>
</li>
<li>
<p><code>initialize()</code> bootstraps the container and returns a <code>SeContainer</code> as defined in <a href="#se_container"><code>SeContainer</code> interface</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Every invocation of the <code>SeContainerInitializer.initialize()</code> method returns a new <code>SeContainer</code> instance.
The application context is started automatically by the container on start up.
An implementation does not need to support multiple calls of <code>SeContainerInitializer.initialize()</code> method when the <code>SeContainer</code> is running.</p>
</div>
</div>
<div class="sect2">
<h3 id="se_container"><a class="anchor" href="#se_container"></a>13.2. <code>SeContainer</code> interface</h3>
<div class="paragraph">
<p>The <code>jakarta.enterprise.inject.se.SeContainer</code> interface provides access to the <code>BeanManager</code> and programmatic lookup as defined in <a href="#dynamic_lookup">The <code>Instance</code> interface</a>.
<code>SeContainer</code> also extends <code>AutoCloseable</code>, so when dereferenced, it should shutdown automatically.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">SeContainer</span> <span class="directive">extends</span> Instance&lt;<span class="predefined-type">Object</span>&gt;,AutoCloseable {
    <span class="type">void</span> close();
    <span class="type">boolean</span> isRunning();
    BeanManager getBeanManager();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>close()</code> method explicitly shuts down the container.
If it is called and the container was already shutdown, it throws an <code>IllegalStateException</code>.</p>
</li>
<li>
<p><code>isRunning()</code> method returns <code>true</code> if called before container shuts down and <code>false</code> after.</p>
</li>
<li>
<p><code>getBeanManager()</code> method returns the <code>BeanManager</code> (as defined in <a href="#beanmanager">The <code>BeanManager</code> object</a>) for the running container.
If it is called and the container was already shutdown, it throws an <code>IllegalStateException</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>SeContainer implements <code>jakarta.enterprise.inject.Instance</code> and therefore might be used to perform programmatic lookup as defined in <a href="#dynamic_lookup">The <code>Instance</code> interface</a>.
If no qualifier is passed to <code>SeContainer.select()</code> method, the <code>@Default</code> qualifier is assumed.</p>
</div>
<div class="paragraph">
<p>If any <code>Instance.select()</code> method is called and the container was already shutdown, the <code>IllegalStateException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>The following code examples demonstrate the options of handling container shutdown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span>... args) {
    SeContainerInitializer containerInit = SeContainerInitializer.newInstance();
    SeContainer container = containerInit.initialize();
    <span class="comment">// retrieve a bean and do work with it</span>
    MyBean myBean = container.select(MyBean.class).get();
    myBean.doWork();
    <span class="comment">// when done</span>
    container.close();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span>... args) {
    <span class="keyword">try</span>(SeContainer container = SeContainerInitializer.newInstance().initialize()) {
        <span class="comment">// start the container, retrieve a bean and do work with it</span>
        MyBean myBean = container.select(MyBean.class).get();
        myBean.doWork();
    }
    <span class="comment">// shuts down automatically after the try with resources block.</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contexts_se"><a class="anchor" href="#contexts_se"></a>14. Scopes and contexts in Java SE</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="builtin_contexts_se"><a class="anchor" href="#builtin_contexts_se"></a>14.1. Context management for built-in scopes in Java SE</h3>
<div class="paragraph">
<p>When running in Java SE, the container must extend the rules defined in <a href="#builtin_contexts">Context management for built-in scopes</a> and is also required to ensure the following rules for built-in context implementation.</p>
</div>
<div class="sect3">
<h4 id="application_context_se"><a class="anchor" href="#application_context_se"></a>14.1.1. Application context lifecycle in Java SE</h4>
<div class="paragraph">
<p>When running in Java SE the container must extend the rules defined in <a href="#application_context">Application context lifecycle</a> and is also required to ensure the following rules.</p>
</div>
<div class="paragraph">
<p>The application scope is active:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>during any method invocation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The application context is shared between all method invocations that execute within the same container.</p>
</div>
<div class="paragraph">
<p>The application context is destroyed when the container is shut down.</p>
</div>
<div class="paragraph">
<p>The payload of the event fired when the application context is initialized or destroyed is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>any <code>java.lang.Object</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="packaging_deployment_se"><a class="anchor" href="#packaging_deployment_se"></a>15. Packaging and deployment in Java SE</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="bean_archive_se"><a class="anchor" href="#bean_archive_se"></a>15.1. Bean archive in Java SE</h3>
<div class="paragraph">
<p>When running in Java SE, the container must extend the rules defined in <a href="#bean_archive">Bean archives</a> and also ensure that :</p>
</div>
<div class="paragraph">
<p>An archive which doesn&#8217;t contain a beans.xml file can&#8217;t be discovered as an <em>implicit bean archive</em> unless:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the application is launched with system property <code>jakarta.enterprise.inject.scan.implicit</code> set to <code>true</code>, or</p>
</li>
<li>
<p>the container was initialized with a map containing an entry parameter with <code>jakarta.enterprise.inject.scan.implicit</code> as key and <code>Boolean.TRUE</code> as value.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spi_se"><a class="anchor" href="#spi_se"></a>16. Portable extensions in Java SE</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="beanmanager_se"><a class="anchor" href="#beanmanager_se"></a>16.1. The <code>BeanManager</code> object in Java SE</h3>
<div class="sect3">
<h4 id="provider_se"><a class="anchor" href="#provider_se"></a>16.1.1. Obtaining a reference to the CDI container in Java SE</h4>
<div class="paragraph">
<p>In Java SE, while the access to CDI container and <code>BeanManager</code> described in <a href="#provider">Obtaining a reference to the CDI container</a> is available, the preferred way to access them is through <code>SeContainer</code> interface as described in <a href="#se_container"><code>SeContainer</code> interface</a>.</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="part_3" class="sect0"><a class="anchor" href="#part_3"></a>Part III - CDI in Jakarta EE</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>This part of the document, specifies additional rules or features when using CDI in a Jakarta EE container.
All content defined in <a href="#part_1">Part I - Core CDI</a> applies to this part.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concepts_ee"><a class="anchor" href="#concepts_ee"></a>17. Extended Concepts for Jakarta EE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the concepts defined in <a href="#concepts">Concepts</a> with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A Jakarta EE component is a <em>bean</em> if the lifecycle of its instances may be managed by the container according to the lifecycle context model defined in <a href="#contexts">Scopes and contexts</a></p>
</li>
<li>
<p>Contextual instances of a bean may be used in EL expressions that are evaluated in the same context</p>
</li>
<li>
<p>For some Jakarta EE components - like environment resources, defined in <a href="#resources">Resources</a>  - the developer provides only the annotations and the bean implementation is provided by the container.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="capabilities_ee"><a class="anchor" href="#capabilities_ee"></a>17.1. Functionality provided by the container to the bean in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the capabilities defined in <a href="#capabilities">Functionality provided by the container to the bean</a>, by providing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>scoped resolution by bean name when used in a Unified EL expression, as defined by <a href="#name_resolution">Name resolution</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bean_types_ee"><a class="anchor" href="#bean_types_ee"></a>17.2. Bean types for Jakarta EE component</h3>
<div class="paragraph">
<p>As managed beans, EJB session beans may have multiple bean types depending on their client-visible types.
For instance, this session bean has only the local interfaces <code>BookShop</code> and <code>Auditable</code>, along with <code>Object</code>, as bean types, since the bean class is not a client-visible type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Stateful</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">BookShopBean</span>
        <span class="directive">extends</span> Business
        <span class="directive">implements</span> BookShop, Auditable {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rules for determining the (unrestricted) set of bean types for Jakarta EE components are defined in  <a href="#session_bean_types">Bean types of a session bean</a> and <a href="#resource_types">Bean types of a resource</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="scopes_ee"><a class="anchor" href="#scopes_ee"></a>17.3. Scopes</h3>
<div class="paragraph">
<p>Jakarta EE components such as servlets, EJBs and JavaBeans do not have a well-defined <em>scope</em>.
These components are either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>singletons</em>, such as EJB singleton session beans, whose state is shared between all clients,</p>
</li>
<li>
<p><em>stateless objects</em>, such as servlets and stateless session beans, which do not contain client-visible state, or</p>
</li>
<li>
<p>objects that must be explicitly created and destroyed by their client, such as JavaBeans and stateful session beans, whose state is shared by explicit reference passing between clients.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>CDI scopes add to Jakarta EE these missing well-defined lifecycle context as defined in <a href="#scopes">Scopes</a>.</p>
</div>
<div class="sect3">
<h4 id="builtin_scopes_ee"><a class="anchor" href="#builtin_scopes_ee"></a>17.3.1. Built-in scope types in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the implementations of the @RequestScoped, @ApplicationScoped and @SessionScoped annotations provided by the container, represent the standard scopes defined by the Java Servlets specification.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="default_bean_discovery_ee"><a class="anchor" href="#default_bean_discovery_ee"></a>17.4. Default bean discovery mode for Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, If the <em>bean discovery mode</em> is <code>annotated</code>, the container must extend the rules defined in <a href="#default_bean_discovery">Default bean discovery mode</a> with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>bean classes of EJB sessions beans, are discovered, and</p>
</li>
<li>
<p>producer methods that are on an EJB session bean are discovered, and</p>
</li>
<li>
<p>producer fields that are on an EJB session bean are discovered, and</p>
</li>
<li>
<p>disposer methods that are on an EJB session bean are discovered, and</p>
</li>
<li>
<p>observer methods that are on an EJB session bean are discovered.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="names_ee"><a class="anchor" href="#names_ee"></a>17.5. Bean names in Jakarta EE</h3>
<div class="paragraph">
<p>A bean with a name may be referred to by its name in Unified EL expressions.</p>
</div>
<div class="paragraph">
<p>There is no relationship between the bean name of an EJB session bean and the EJB name of the bean.</p>
</div>
<div class="paragraph">
<p>Bean names allow the direct use of beans in JSP or JSF pages, as defined in <a href="#el">Integration with Unified EL</a>.
For example, a bean with the name <code>products</code> could be used like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;h:outputText</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{products.total}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="default_name_ee"><a class="anchor" href="#default_name_ee"></a>17.5.1. Default bean names for EJB session beans</h4>
<div class="paragraph">
<p>In the circumstances listed in <a href="#default_name">Default bean names</a>, the rule for determining default name for an EJB session bean are defined in <a href="#session_bean_name">Default bean name for a session bean</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementation_ee"><a class="anchor" href="#implementation_ee"></a>18. Addition to programming model for Jakarta EE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#implementation">Programming model</a>, and must also provide built-in support for injection and contextual lifecycle management of the following kinds of bean:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Session beans</p>
</li>
<li>
<p>Resources (Jakarta EE resources, persistence contexts, persistence units, remote EJBs and web services)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Jakarta EE and embeddable EJB containers are required by the Jakarta EE and EJB specifications to support EJB session beans and the Jakarta EE component environment.
Other containers are not required to provide support for injection or lifecycle management of session beans or resources.</p>
</div>
<div class="sect2">
<h3 id="managed_beans_ee"><a class="anchor" href="#managed_beans_ee"></a>18.1. Managed beans in Jakarta EE</h3>
<div class="sect3">
<h4 id="what_classes_are_beans_ee"><a class="anchor" href="#what_classes_are_beans_ee"></a>18.1.1. Which Java classes are managed beans in Jakarta EE?</h4>
<div class="paragraph">
<p>When running in Jakarta EE, A top-level Java class is a managed bean if it meets requirements described in <a href="#what_classes_are_beans">Which Java classes are managed beans?</a> or if it is defined to be a managed bean by any other Jakarta EE specification and if</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is not annotated with an EJB component-defining annotation or declared as an EJB bean class in <code>ejb-jar.xml</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="session_beans"><a class="anchor" href="#session_beans"></a>18.2. EJB Session beans</h3>
<div class="paragraph">
<p>A <em>session bean</em> is a bean that is implemented by a session bean with an EJB 3.x client view that is not annotated with <code>@Vetoed</code> or in a package annotated <code>@Vetoed</code>. The basic lifecycle and semantics of EJB session beans are defined by the EJB specification.</p>
</div>
<div class="paragraph">
<p>A stateless session bean must belong to the <code>@Dependent</code> pseudo-scope. A singleton session bean must belong to either the <code>@ApplicationScoped</code> scope or to the <code>@Dependent</code> pseudo-scope. If a session bean specifies an illegal scope, the container automatically detects the problem and treats it as a definition error.
A stateful session bean may have any scope.</p>
</div>
<div class="paragraph">
<p>When a contextual instance of a session bean is obtained via the dependency injection service, the behavior of <code>SessionContext.getInvokedBusinessInterface()</code> is specific to the container implementation.
Portable applications should not rely upon the value returned by this method.</p>
</div>
<div class="paragraph">
<p>If the bean class of a session bean is annotated <code>@Interceptor</code> or <code>@Decorator</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If the session bean class is a generic type, it must have scope <code>@Dependent</code>. If a session bean with a parameterized bean class declares any scope other than <code>@Dependent</code>, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="sect3">
<h4 id="session_bean_ejb_remove_method"><a class="anchor" href="#session_bean_ejb_remove_method"></a>18.2.1. EJB remove methods of session beans</h4>
<div class="paragraph">
<p>If a session bean is a stateful session bean:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the scope is <code>@Dependent</code>, the application <em>may</em> call any EJB remove method of a contextual instance of the session bean.</p>
</li>
<li>
<p>Otherwise, the application <em>may not</em> directly call any EJB remove method of any contextual instance of the session bean.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The session bean is not required to have an EJB remove method in order for the container to destroy it.</p>
</div>
<div class="paragraph">
<p>If the application directly calls an EJB remove method of a contextual instance of a session bean that is a stateful session bean and declares any scope other than <code>@Dependent</code>, an <code>UnsupportedOperationException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>If the application directly calls an EJB remove method of a contextual instance of a session bean that is a stateful session bean and has scope <code>@Dependent</code> then no parameters are passed to the method by the container.
Furthermore, the container ignores the instance instead of destroying it when <code>Contextual.destroy()</code> is called, as defined in <a href="#stateful_lifecycle">Lifecycle of EJB stateful session beans</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="session_bean_types"><a class="anchor" href="#session_bean_types"></a>18.2.2. Bean types of a session bean</h4>
<div class="paragraph">
<p>The unrestricted set of bean types for a session bean contains all local interfaces of the bean and their superinterfaces.
If the session bean has a no-interface view, the unrestricted set of bean types contains the bean class and all superclasses.
In addition, <code>java.lang.Object</code> is a bean type of every session bean.</p>
</div>
<div class="paragraph">
<p>Remote interfaces are not included in the set of bean types.</p>
</div>
<div class="paragraph">
<p>The resulting set of bean types for a session bean consists only of <a href="#legal_bean_types">legal bean types</a>, all other types are removed from the set of bean types.</p>
</div>
</div>
<div class="sect3">
<h4 id="declaring_session_bean"><a class="anchor" href="#declaring_session_bean"></a>18.2.3. Declaring a session bean</h4>
<div class="paragraph">
<p>A session bean does not require any special annotations apart from the component-defining annotation (or XML declaration) required by the EJB specification.
The following EJBs are beans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Singleton</span>
<span class="type">class</span> <span class="class">Shop</span> { .. }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Stateless</span>
<span class="type">class</span> <span class="class">PaymentProcessorImpl</span> <span class="directive">implements</span> PaymentProcessor { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A bean class may also specify a scope, bean name, stereotypes and/or qualifiers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ConversationScoped</span> <span class="annotation">@Stateful</span> <span class="annotation">@Default</span> <span class="annotation">@Model</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ShoppingCart</span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A session bean class may extend another bean class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Stateless</span>
<span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">loginAction</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">LoginActionImpl</span> <span class="directive">implements</span> LoginAction { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Stateless</span>
<span class="annotation">@Mock</span>
<span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">loginAction</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockLoginActionImpl</span> <span class="directive">extends</span> LoginActionImpl { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="specialize_session_bean"><a class="anchor" href="#specialize_session_bean"></a>18.2.4. Specializing a session bean</h4>
<div class="paragraph">
<p>If a bean class of a session bean X is annotated <code>@Specializes</code>, then the bean class of X must directly extend the bean class of another session bean Y.
Then X <em>directly specializes</em> Y, as defined in <a href="#specialization">Specialization</a>.</p>
</div>
<div class="paragraph">
<p>If the bean class of X does not directly extend the bean class of another session bean, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>For example, <code>MockLoginActionBean</code> directly specializes <code>LoginActionBean</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Stateless</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">LoginActionBean</span> <span class="directive">implements</span> LoginAction { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Stateless</span> <span class="annotation">@Mock</span> <span class="annotation">@Specializes</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MockLoginActionBean</span> <span class="directive">extends</span> LoginActionBean <span class="directive">implements</span> LoginAction { ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="session_bean_name"><a class="anchor" href="#session_bean_name"></a>18.2.5. Default bean name for a session bean</h4>
<div class="paragraph">
<p>The default name for a session bean is the unqualified class name of the session bean class, after converting the first character to lower case.</p>
</div>
<div class="paragraph">
<p>For example, if the bean class is named <code>ProductList</code>, the default bean name is <code>productList</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producer_method_ee"><a class="anchor" href="#producer_method_ee"></a>18.3. Producer methods on EJB session bean</h3>
<div class="paragraph">
<p>A producer method defined in an EJB session bean follows the rules defined in <a href="#producer_method">Producer methods</a> with the following addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A producer method defined in an EJB session bean must be either a business method exposed by a local business interface of the EJB or a static method of the bean class.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="declaring_producer_method_ee"><a class="anchor" href="#declaring_producer_method_ee"></a>18.3.1. Declaring a producer method in an EJB session bean</h4>
<div class="paragraph">
<p>A producer method declaration in an EJB session bean follows the rules defined in <a href="#declaring_producer_method">Declaring a producer method</a> with the following addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if a non-static method of a session bean class is annotated <code>@Produces</code>, and the method is not a business method exposed by a local business interface of the session bean, the container automatically detects the problem and treats it as a definition error.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producer_field_ee"><a class="anchor" href="#producer_field_ee"></a>18.4. Producer field on EJB session bean</h3>
<div class="paragraph">
<p>A producer field defined in an EJB session bean follows the rules defined in <a href="#producer_field">Producer fields</a> with the following addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A producer field defined in an EJB session bean must be a static field of the bean class.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="declaring_producer_field_ee"><a class="anchor" href="#declaring_producer_field_ee"></a>18.4.1. Declaring a producer field in an EJB session bean</h4>
<div class="paragraph">
<p>A producer field declaration in an EJB session bean follows the rules defined in <a href="#declaring_producer_field">Declaring a producer field</a> with the following addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a non-static field of an EJB session bean class is annotated <code>@Produces</code>, the container automatically detects the problem and treats it as a definition error.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="disposer_method_ee"><a class="anchor" href="#disposer_method_ee"></a>18.5. Disposer methods on EJB session bean</h3>
<div class="paragraph">
<p>A disposer method defined in an EJB session bean follows the rules defined in <a href="#disposer_method">Disposer methods</a> with the following addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A disposer method defined in an EJB session bean must be either a business method exposed by a local business interface of the EJB or a static method of the bean class.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="declaring_disposer_method_ee"><a class="anchor" href="#declaring_disposer_method_ee"></a>18.5.1. Declaring a disposer method on an EJB session bean</h4>
<div class="paragraph">
<p>A disposer method declaration in an EJB session bean follows the rules defined in <a href="#declaring_disposer_method">Declaring a disposer method</a> with the following addition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a non-static method of an EJB session bean class has a parameter annotated <code>@Disposes</code>, and the method is not a business method exposed by a local business interface of the session bean, the container automatically detects the problem and treats it as a definition error.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="javaee_components"><a class="anchor" href="#javaee_components"></a>18.6. Jakarta EE components</h3>
<div class="paragraph">
<p>Most Jakarta EE components support injection and interception, as defined in the Jakarta EE Platform, Specification, table EE.5-1, but are not considered beans (as defined by this specification). EJBs, as defined in <a href="#session_beans">EJB Session beans</a> are the exception.</p>
</div>
<div class="paragraph">
<p>The instance used by the container to service an invocation of a Jakarta EE component will not be the same instance obtained when using <code>@Inject</code>, instantiated by the container to invoke a producer method, observer method or disposer method, or instantiated by the container to access the value of a producer field.
It is recommended that Jakarta EE components should not define observer methods, producer methods, producer fields or disposer methods.
It is safe to annotate Jakarta EE components with <code>@Vetoed</code> to prevent them being considered beans.</p>
</div>
</div>
<div class="sect2">
<h3 id="resources"><a class="anchor" href="#resources"></a>18.7. Resources</h3>
<div class="paragraph">
<p>A <em>resource</em> is a bean that represents a reference to a resource, persistence context, persistence unit, remote EJB or web service in the Jakarta EE component environment.</p>
</div>
<div class="paragraph">
<p>By declaring a resource, we enable an object from the Jakarta EE component environment to be injected by specifying only its type and qualifiers at the injection point.
For example, if <code>@CustomerDatabase</code> is a qualifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@CustomerDatabase</span> Datasource customerData;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@CustomerDatabase</span> EntityManager customerDatabaseEntityManager;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> <span class="annotation">@CustomerDatabase</span> EntityManagerFactory customerDatabaseEntityManagerFactory;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Inject</span> PaymentService remotePaymentService;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The container is not required to support resources with scope other than <code>@Dependent</code>. Portable applications should not define resources with any scope other than <code>@Dependent</code>.</p>
</div>
<div class="paragraph">
<p>A resource may not have a bean name.</p>
</div>
<div class="sect3">
<h4 id="declaring_resource"><a class="anchor" href="#declaring_resource"></a>18.7.1. Declaring a resource</h4>
<div class="paragraph">
<p>A resource may be declared by specifying a Jakarta EE component environment injection annotation as part of a producer field declaration.
The producer field may be static.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For a Jakarta EE resource, <code>@Resource</code> must be specified.</p>
</li>
<li>
<p>For a persistence context, <code>@PersistenceContext</code> must be specified.</p>
</li>
<li>
<p>For a persistence unit, <code>@PersistenceUnit</code> must be specified.</p>
</li>
<li>
<p>For a remote EJB, <code>@EJB</code> must be specified.</p>
</li>
<li>
<p>For a web service, <code>@WebServiceRef</code> must be specified.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The injection annotation specifies the metadata needed to obtain the resource, entity manager, entity manager factory, remote EJB instance or web service reference from the component environment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@WebServiceRef</span>(lookup=<span class="string"><span class="delimiter">&quot;</span><span class="content">java:app/service/PaymentService</span><span class="delimiter">&quot;</span></span>)
PaymentService paymentService;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@EJB</span>(ejbLink=<span class="string"><span class="delimiter">&quot;</span><span class="content">../their.jar#PaymentService</span><span class="delimiter">&quot;</span></span>)
PaymentService paymentService;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@Resource</span>(lookup=<span class="string"><span class="delimiter">&quot;</span><span class="content">java:global/env/jdbc/CustomerDatasource</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@CustomerDatabase</span> Datasource customerDatabase;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@PersistenceContext</span>(unitName=<span class="string"><span class="delimiter">&quot;</span><span class="content">CustomerDatabase</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@CustomerDatabase</span> EntityManager customerDatabasePersistenceContext;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Produces</span> <span class="annotation">@PersistenceUnit</span>(unitName=<span class="string"><span class="delimiter">&quot;</span><span class="content">CustomerDatabase</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@CustomerDatabase</span> EntityManagerFactory customerDatabasePersistenceUnit;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean type and qualifiers of the resource are determined by the producer field declaration.</p>
</div>
<div class="paragraph">
<p>If the producer field declaration specifies a bean name, the container automatically detects the problem and treats it as a definition error.</p>
</div>
<div class="paragraph">
<p>If the matching object in the Jakarta EE component environment is not of the same type as the producer field declaration, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
<div class="sect3">
<h4 id="resource_types"><a class="anchor" href="#resource_types"></a>18.7.2. Bean types of a resource</h4>
<div class="paragraph">
<p>The unrestricted set of bean types for a resource is determined by the declared type of the producer field, as specified by <a href="#producer_field_types">Bean types of a producer field</a>.</p>
</div>
<div class="paragraph">
<p>The resulting set of bean types for a resource consists only of <a href="#legal_bean_types">legal bean types</a>, all other types are removed from the set of bean types.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="additional_builtin_beans"><a class="anchor" href="#additional_builtin_beans"></a>18.8. Additional built-in beans</h3>
<div class="paragraph">
<p>A Jakarta EE or embeddable EJB container must provide the following built-in beans, all of which have qualifier <code>@Default</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a bean with bean type <code>jakarta.transaction.UserTransaction</code>, allowing injection of a reference to the JTA <code>UserTransaction</code>, and</p>
</li>
<li>
<p>a bean with bean type <code>java.security.Principal</code>, allowing injection of a <code>Principal</code> representing the current caller identity.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A servlet container must provide the following built-in beans, all of which have qualifier <code>@Default</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a bean with bean type <code>jakarta.servlet.http.HttpServletRequest</code>, allowing injection of a reference to the <code>HttpServletRequest</code></p>
</li>
<li>
<p>a bean with bean type <code>jakarta.servlet.http.HttpSession</code>, allowing injection of a reference to the <code>HttpSession</code>,</p>
</li>
<li>
<p>a bean with bean type <code>jakarta.servlet.ServletContext</code>, allowing injection of a reference to the <code>ServletContext</code>,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These beans are passivation capable dependencies, as defined in <a href="#passivation_capable_dependency">Passivation capable dependencies</a>.</p>
</div>
<div class="paragraph">
<p>If a Jakarta EE component class has an injection point of type <code>UserTransaction</code> and qualifier <code>@Default</code>, and may not validly make use of the JTA <code>UserTransaction</code> according to the Jakarta EE platform specification, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
<div class="sect2">
<h3 id="injected_fields_ee"><a class="anchor" href="#injected_fields_ee"></a>18.9. Injected fields in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for bean classes in <a href="#injected_fields">Injected fields</a> to Jakarta EE component classes supporting injection.</p>
</div>
</div>
<div class="sect2">
<h3 id="initializer_methods_ee"><a class="anchor" href="#initializer_methods_ee"></a>18.10. Initializer methods in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for bean classes in <a href="#initializer_methods">Initializer methods</a> to Jakarta EE component classes supporting injection.
The container must also ensure that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An initializer method defined in an EJB session bean is <em>not</em> required to be a business method of the session bean.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new_ee"><a class="anchor" href="#new_ee"></a>18.11. <code>@New</code> qualified beans in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#new"><code>@New</code> qualified beans</a> to EJB session beans.</p>
</div>
</div>
<div class="sect2">
<h3 id="type_level_inheritance_ee"><a class="anchor" href="#type_level_inheritance_ee"></a>18.12. Inheritance of type-level metadata in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#type_level_inheritance">Inheritance of type-level metadata</a> to EJB session beans.</p>
</div>
</div>
<div class="sect2">
<h3 id="member_level_inheritance_ee"><a class="anchor" href="#member_level_inheritance_ee"></a>18.13. Inheritance of member-level metadata in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#member_level_inheritance">Inheritance of member-level metadata</a> to EJB session beans.</p>
</div>
</div>
<div class="sect2">
<h3 id="specialization_ee"><a class="anchor" href="#specialization_ee"></a>18.14. Specialization in Jakarta EE</h3>
<div class="sect3">
<h4 id="direct_and_indirect_specialization_ee"><a class="anchor" href="#direct_and_indirect_specialization_ee"></a>18.14.1. Direct and indirect specialization in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#member_level_inheritance">Inheritance of member-level metadata</a> and is also required to support specialization for EJB session beans as defined in <a href="#specialize_session_bean">Specializing a session bean</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="injection_el_resolution_ee"><a class="anchor" href="#injection_el_resolution_ee"></a>19. Dependency injection, lookup and EL in Jakarta EE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#injection_and_resolution">Dependency injection and lookup</a> and may also provide references to contextual instances by Unified EL expression evaluation.</p>
</div>
<div class="paragraph">
<p>When resolving a name in an EL expression, the container considers the bean name and selected alternatives.</p>
</div>
<div class="sect2">
<h3 id="selection_ee"><a class="anchor" href="#selection_ee"></a>19.1. Modularity in Jakarta EE</h3>
<div class="paragraph">
<p>In the Jakarta EE module architecture, any Jakarta EE module or library is a module. The Jakarta EE module is a bean archive if it contains a <code>beans.xml</code> file, as defined in <a href="#bean_archive">Bean archives</a>.</p>
</div>
<div class="paragraph">
<p>When running in Jakarta EE, the container must follow the same accessibility rules for beans and alternatives defined in <a href="#selection">Modularity</a> for JSP/JSF pages using EL resolution and make sure that only beans available from injection in the module that defines the JSP/JSF pages are resolved.</p>
</div>
<div class="paragraph">
<p>In the Jakarta EE module architecture, a bean class is accessible in a module if and only if it is required to be accessible according to the class loading requirements defined by the Jakarta EE platform specification.</p>
</div>
<div class="paragraph">
<p>Note that, in some Jakarta EE implementations, a bean class might be accessible to some other class even when this is not required by the Jakarta EE platform specification.
For the purposes of this specification, a class is not considered accessible to another class unless accessibility is explicitly required by the Jakarta EE platform specification.</p>
</div>
<div class="paragraph">
<p>An alternative is not available for injection, lookup or EL resolution to classes or JSP/JSF pages in a module unless the module is a bean archive and the alternative is explicitly <em>selected</em> for the bean archive or the application.</p>
</div>
<div class="sect3">
<h4 id="declaring_selected_alternatives_application_ee"><a class="anchor" href="#declaring_selected_alternatives_application_ee"></a>19.1.1. Declaring selected alternatives for an application in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#declaring_selected_alternatives_application">Declaring selected alternatives for an application</a> to EJB session beans.</p>
</div>
</div>
<div class="sect3">
<h4 id="declaring_selected_alternatives_bean_archive_ee"><a class="anchor" href="#declaring_selected_alternatives_bean_archive_ee"></a>19.1.2. Declaring selected alternatives for a bean archive in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#declaring_selected_alternatives_bean_archive">Declaring selected alternatives for a bean archive</a> to EJB session beans.</p>
</div>
</div>
<div class="sect3">
<h4 id="unsatisfied_and_ambig_dependencies_ee"><a class="anchor" href="#unsatisfied_and_ambig_dependencies_ee"></a>19.1.3. Unsatisfied and ambiguous dependencies in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#unsatisfied_and_ambig_dependencies">Unsatisfied and ambiguous dependencies</a> and must also validate all injection points of all Jakarta EE component classes supporting injection</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="name_resolution_ee"><a class="anchor" href="#name_resolution_ee"></a>19.2. EL name resolution</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#name_resolution">Name resolution</a> and must also support name resolution for name used in Expression Language</p>
</div>
<div class="paragraph">
<p>An EL name resolves to a bean if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the name can be resolved to a bean according to rules in <a href="#name_resolution">Name resolution</a>, and</p>
</li>
<li>
<p>the bean is available for injection in the war containing the JSP or JSF page with the EL expression.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="ambig_names_ee"><a class="anchor" href="#ambig_names_ee"></a>19.2.1. Ambiguous EL names</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#ambig_names">Ambiguous names</a> to names used in Expression Language.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="injection_ee"><a class="anchor" href="#injection_ee"></a>19.3. Dependency injection in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#injection">Dependency injection</a> and is also required to perform dependency injection whenever it creates the following contextual objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>contextual instances of EJB session beans.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container is also required to perform dependency injection whenever it instantiates any of the following non-contextual objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>non-contextual instances of EJB session beans (for example, session beans obtained by the application from JNDI or injected using <code>@EJB</code>), and</p>
</li>
<li>
<p>instances of any other Jakarta EE component class supporting injection.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A Java EE 5 container is not required to support injection for non-contextual objects.</p>
</div>
<div class="sect3">
<h4 id="instantiation_ee"><a class="anchor" href="#instantiation_ee"></a>19.3.1. Injection using the bean constructor in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#instantiation">Injection using the bean constructor</a> to EJB session beans.</p>
</div>
</div>
<div class="sect3">
<h4 id="fields_initializer_methods_ee"><a class="anchor" href="#fields_initializer_methods_ee"></a>19.3.2. Injection of fields and initializer methods in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#fields_initializer_methods">Injection of fields and initializer methods</a> to EJB session beans and to any other Jakarta EE component class supporting injection.</p>
</div>
<div class="paragraph">
<p>The container is also required to ensure that:</p>
</div>
<div class="paragraph">
<p>-* Initializer methods declared by a class X in the type hierarchy of the bean are called after all Jakarta EE component environment resource dependencies declared by X or by superclasses of X have been injected.
-* Any <code>@PostConstruct</code> callback declared by a class X in the type hierarchy of the bean is called after all Jakarta EE component environment resource dependencies declared by X or by superclasses of X have been injected.
-* Any servlet <code>init()</code> method is called after all initializer methods have been called, all injected fields have been initialized and all Jakarta EE component environment resource dependencies have been injected.</p>
</div>
</div>
<div class="sect3">
<h4 id="dependent_objects_destruction_ee"><a class="anchor" href="#dependent_objects_destruction_ee"></a>19.3.3. Destruction of dependent objects in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#dependent_objects_destruction">Destruction of dependent objects</a> to any other Jakarta EE component class supporting injection and perform destruction after the servlet <code>destroy()</code> method is called.</p>
</div>
</div>
<div class="sect3">
<h4 id="bean_metadata_ee"><a class="anchor" href="#bean_metadata_ee"></a>19.3.4. Bean metadata in Jakarta EE</h4>
<div class="paragraph">
<p>Interceptor and decorator instances associated with Jakarta EE components that are not considered beans (as defined by this specification) cannot obtain information about the beans they intercept and decorate (as defined in <a href="#bean_metadata">Bean metadata</a>) and thus <code>null</code> is injected into relevant injection points.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contexts_ee"><a class="anchor" href="#contexts_ee"></a>20. Scopes and contexts in Jakarta EE</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="dependent_context_ee"><a class="anchor" href="#dependent_context_ee"></a>20.1. Dependent pseudo-scope in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#dependent_context">Dependent pseudo-scope</a> and must also ensure that if a bean is declared to have <code>@Dependent</code> scope:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a Unified EL expression in a JSF or JSP page that refers to the bean by its bean name is evaluated, at most one instance of the bean is instantiated.
This instance exists to service just a single evaluation of the EL expression.
It is reused if the bean name appears multiple times in the EL expression, but is never reused when the EL expression is evaluated again, or when another EL expression is evaluated.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="dependent_objects_ee"><a class="anchor" href="#dependent_objects_ee"></a>20.1.1. Dependent objects in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for bean in <a href="#dependent_objects">Dependent objects</a> to Jakarta EE component class instance.</p>
</div>
</div>
<div class="sect3">
<h4 id="dependent_destruction_ee"><a class="anchor" href="#dependent_destruction_ee"></a>20.1.2. Destruction of objects with scope <code>@Dependent</code> in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for bean in <a href="#dependent_destruction">Destruction of objects with scope <code>@Dependent</code></a> to Jakarta EE component class instance, and must also ensure that :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>all <code>@Dependent</code> scoped contextual instances created during evaluation of a Unified EL expression in a JSP or JSF page are destroyed when the evaluation completes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="dependent_scope_el"><a class="anchor" href="#dependent_scope_el"></a>20.1.3. Dependent pseudo-scope and Unified EL</h4>
<div class="paragraph">
<p>Suppose a Unified EL expression in a JSF or JSP page refers to a bean with scope <code>@Dependent</code> by its bean name. Each time the EL expression is evaluated:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the bean is instantiated at most once, and</p>
</li>
<li>
<p>the resulting instance is reused for every appearance of the bean name, and</p>
</li>
<li>
<p>the resulting instance is destroyed when the evaluation completes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Portable extensions that integrate with the container via Unified EL should also ensure that these rules are enforced.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="passivating_scope_ee"><a class="anchor" href="#passivating_scope_ee"></a>20.2. Passivation and passivating scopes in Jakarta EE</h3>
<div class="sect3">
<h4 id="passivation_capable_ee"><a class="anchor" href="#passivation_capable_ee"></a>20.2.1. Passivation capable beans in Jakarta EE</h4>
<div class="ulist">
<ul>
<li>
<p>As defined by the EJB specification, an EJB stateful session beans is passivation capable if:</p>
<div class="ulist">
<ul>
<li>
<p>interceptors and decorators of the bean are passivation capable, and,</p>
</li>
<li>
<p>the EJB stateful session bean does not have the <code>passivationCapable</code> flag set to <code>false</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>As defined by the EJB specification, an EJB stateless session bean or an EJB singleton session bean is not passivation capable.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="passivation_capable_dependency_ee"><a class="anchor" href="#passivation_capable_dependency_ee"></a>20.2.2. Passivation capable dependencies in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#passivation_capable_dependency">Passivation capable dependencies</a>, and must also guarantee that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>all EJB stateless session beans are passivation capable dependencies,</p>
</li>
<li>
<p>all EJB singleton session beans are passivation capable dependencies,</p>
</li>
<li>
<p>all passivation capable EJB stateful session beans are passivation capable dependencies, and</p>
</li>
<li>
<p>all Jakarta EE resources are passivation capable dependencies.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="passivation_validation_ee"><a class="anchor" href="#passivation_validation_ee"></a>20.2.3. Validation of passivation capable beans and dependencies in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#passivation_validation">Validation of passivation capable beans and dependencies</a> to EJB session beans.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="builtin_contexts_ee"><a class="anchor" href="#builtin_contexts_ee"></a>20.3. Context management for built-in scopes in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#builtin_contexts">Context management for built-in scopes</a> and is also required to ensure the following rules for built-in context implementation.</p>
</div>
<div class="paragraph">
<p>The built-in request and application context objects are active during servlet, web service and EJB invocations, and the built in session and request context objects are active during servlet and web service invocations.</p>
</div>
<div class="sect3">
<h4 id="request_context_ee"><a class="anchor" href="#request_context_ee"></a>20.3.1. Request context lifecycle in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE the container must extend the rules defined in <a href="#request_context">Request context lifecycle</a> and is also required to implement request context with the following rules.</p>
</div>
<div class="paragraph">
<p>The request context is active:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>during the <code>service()</code> method of any servlet in the web application, during the <code>doFilter()</code> method of any servlet filter and when the container calls any <code>ServletRequestListener</code> or <code>AsyncListener</code>,</p>
</li>
<li>
<p>during any Jakarta EE web service invocation,</p>
</li>
<li>
<p>during any remote method invocation of any EJB, during any asynchronous method invocation of any EJB, during any call to an EJB timeout method and during message delivery to any EJB message-driven bean.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The request context is destroyed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>at the end of the servlet request, after the <code>service()</code> method, all <code>doFilter()</code> methods, and all <code>requestDestroyed()</code> and <code>onComplete()</code> notifications return,</p>
</li>
<li>
<p>after the web service invocation completes,</p>
</li>
<li>
<p>after the EJB remote method invocation, asynchronous method invocation, timeout or message delivery completes if it did not already exist when the invocation occurred.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The payload of the event fired when the request context is initialized or destroyed is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <code>ServletRequest</code> if the context is initialized or destroyed due to a servlet request, or</p>
</li>
<li>
<p>the <code>ServletRequest</code> if the context is initialized or destroyed due to a web service invocation, or</p>
</li>
<li>
<p>any <code>java.lang.Object</code> for other types of request.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="session_context_ee"><a class="anchor" href="#session_context_ee"></a>20.3.2. Session context lifecycle in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE the container is required to implement session context with the following rules.</p>
</div>
<div class="paragraph">
<p>The session scope is active:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>during the <code>service()</code> method of any servlet in the web application, during the <code>doFilter()</code> method of any servlet filter and when the container calls any <code>HttpSessionListener</code>, <code>AsyncListener</code> or <code>ServletRequestListener</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The session context is shared between all servlet requests that occur in the same HTTP session.
The session context is destroyed when the <code>HTTPSession</code> times out, after all <code>HttpSessionListener</code> s have been called, and at the very end of any request in which <code>invalidate()</code> was called, after all filters and <code>ServletRequestListener</code> s have been called.</p>
</div>
<div class="paragraph">
<p>An event with qualifier <code>@Initialized(SessionScoped.class)</code> is synchronously fired when the session context is initialized.
An event with qualifier <code>@BeforeDestroyed(SessionScoped.class)</code> is synchronously fired when the session context is about to be destroyed, i.e. before the actual destruction.
An event with qualifier <code>@Destroyed(SessionScoped.class)</code> is synchronously fired when the session context is destroyed, i.e. after the actual destruction.
The event payload is <code>jakarta.servlet.http.HttpSession</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="application_context_ee"><a class="anchor" href="#application_context_ee"></a>20.3.3. Application context lifecycle in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE the container must extend the rules defined in <a href="#application_context">Application context lifecycle</a> and is also required to implement application context with the following rules.</p>
</div>
<div class="paragraph">
<p>The application scope is active:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>during the <code>service()</code> method of any servlet in the web application, during the <code>doFilter()</code> method of any servlet filter and when the container calls any <code>ServletContextListener</code>, <code>HttpSessionListener</code>, <code>AsyncListener</code> or <code>ServletRequestListener</code>,</p>
</li>
<li>
<p>during any Jakarta EE web service invocation,</p>
</li>
<li>
<p>during any asynchronous invocation of an event observer,</p>
</li>
<li>
<p>during any remote method invocation of any EJB, during any asynchronous method invocation of any EJB, during any call to an EJB timeout method and during message delivery to any EJB message-driven bean,</p>
</li>
<li>
<p>when the disposer method or <code>@PreDestroy</code> callback of any bean with any normal scope other than <code>@ApplicationScoped</code> is called, and</p>
</li>
<li>
<p>during <code>@PostConstruct</code> callback of any bean.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The application context is shared between all servlet requests, web service invocations, asynchronous invocation of an event observer, EJB remote method invocations, EJB asynchronous method invocations, EJB timeouts and message deliveries to message-driven beans that execute within the same application.
The application context is destroyed when the application is shut down.</p>
</div>
<div class="paragraph">
<p>The payload of the event fired when the application context is initialized or destroyed is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <code>ServletContext</code> if the application is a web application deployed to a Servlet container, or</p>
</li>
<li>
<p>any <code>java.lang.Object</code> for other types of application.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="conversation_context_ee"><a class="anchor" href="#conversation_context_ee"></a>20.3.4. Conversation context lifecycle in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE the container is required to implement conversation context with the following rules.</p>
</div>
<div class="paragraph">
<p>The conversation scope is active during all Servlet requests.</p>
</div>
<div class="paragraph">
<p>An event with qualifier <code>@Initialized(ConversationScoped.class)</code> is synchronously fired when the conversation context is initialized.
An event with qualifier <code>@BeforeDestroyed(ConversationScoped.class)</code> is synchronously fired when the conversation is about to be destroyed, i.e. before the actual destruction.
An event with qualifier <code>@Destroyed(ConversationScoped.class)</code> is synchronously fired when the conversation is destroyed, i.e. after the actual destruction.
The event payload is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the conversation id if the conversation context is destroyed and is not associated with a current Servlet request, or</p>
</li>
<li>
<p>the <code>ServletRequest</code> if the application is a web application deployed to a Servlet container, or</p>
</li>
<li>
<p>any <code>java.lang.Object</code> for other types of application.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The conversation context provides access to state associated with a particular <em>conversation</em>.
Every Servlet request has an associated conversation.
This association is managed automatically by the container according to the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any Servlet request has exactly one associated conversation.</p>
</li>
<li>
<p>The container provides a filter with the name "CDI Conversation Filter", which may be mapped in <code>web.xml</code>, allowing the user alter when the conversation is associated with the servlet request.
If this filter is not mapped in any <code>web.xml</code> in the application, the conversation associated with a Servlet request is determined at the beginning of the request before calling any <code>service()</code> method of any servlet in the web application, calling the <code>doFilter()</code> method of any servlet filter in the web application and before the container calls any <code>ServletRequestListener</code> or <code>AsyncListener</code> in the web application.</p>
</li>
<li>
<p>The implementation should determine the conversation associated with the Servlet request in a way that does not prevent other filters or servlet from setting the request character encoding or parsing the request body themselves.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any conversation is in one of two states: <em>transient</em> or <em>long-running</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By default, a conversation is transient</p>
</li>
<li>
<p>A transient conversation may be marked long-running by calling <code>Conversation.begin()</code></p>
</li>
<li>
<p>A long-running conversation may be marked transient by calling <code>Conversation.end()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All long-running conversations have a string-valued unique identifier, which may be set by the application when the conversation is marked long-running, or generated by the container.</p>
</div>
<div class="paragraph">
<p>If the conversation associated with the current Servlet request is in the <em>transient</em> state at the end of a Servlet request, it is destroyed, and the conversation context is also destroyed.</p>
</div>
<div class="paragraph">
<p>If the conversation associated with the current Servlet request is in the <em>long-running</em> state at the end of a Servlet request, it is not destroyed.
The long-running conversation associated with a request may be propagated to any Servlet request via use of a request parameter named <code>cid</code> containing the unique identifier of the conversation.
In this case, the application must manage this request parameter.</p>
</div>
<div class="paragraph">
<p>If the current Servlet request is a JSF request, and the conversation is in <em>long-running</em> state, it is propagated according to the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The long-running conversation context associated with a request that renders a JSF view is automatically propagated to any faces request (JSF form submission) that originates from that rendered page.</p>
</li>
<li>
<p>The long-running conversation context associated with a request that results in a JSF redirect (a redirect resulting from a navigation rule or JSF <code>NavigationHandler</code>) is automatically propagated to the resulting non-faces request, and to any other subsequent request to the same URL.
This is accomplished via use of a request parameter named <code>cid</code> containing the unique identifier of the conversation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When no conversation is propagated to a Servlet request, or if a request parameter named <code>conversationPropagation</code> has the value <code>none</code> the request is associated with a new transient conversation.</p>
</div>
<div class="paragraph">
<p>All long-running conversations are scoped to a particular HTTP servlet session and may not cross session boundaries.</p>
</div>
<div class="paragraph">
<p>In the following cases, a propagated long-running conversation cannot be restored and reassociated with the request:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the HTTP servlet session is invalidated, all long-running conversation contexts created during the current session are destroyed, after the servlet <code>service()</code> method completes.</p>
</li>
<li>
<p>The container is permitted to arbitrarily destroy any long-running conversation that is associated with no current Servlet request, in order to conserve resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>conversation timeout</em>, which may be specified by calling <code>Conversation.setTimeout()</code> is a hint to the container that a conversation should not be destroyed if it has been active within the last given interval in milliseconds.</p>
</div>
<div class="paragraph">
<p>If the propagated conversation cannot be restored, the container must associate the request with a new transient conversation and throw an exception of type <code>jakarta.enterprise.context.NonexistentConversationException</code>.</p>
</div>
<div class="paragraph">
<p>The container ensures that a long-running conversation may be associated with at most one request at a time, by blocking or rejecting concurrent requests.
If the container rejects a request, it must associate the request with a new transient conversation and throw an exception of type <code>jakarta.enterprise.context.BusyConversationException</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lifecycle_ee"><a class="anchor" href="#lifecycle_ee"></a>21. Lifecycle of contextual instances</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="biz_method_ee"><a class="anchor" href="#biz_method_ee"></a>21.1. Container invocations and interception in Jakarta EE</h3>
<div class="paragraph">
<p>When the application invokes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a business method of a session bean via an EJB remote or local reference,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>the invocation is treated as a <em>business method invocation</em>.</p>
</div>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#biz_method">Container invocations and interception</a>, with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invocation of EJB timer service timeouts by the container are not business method invocations, but are intercepted by interceptors for EJB timeouts.</p>
</li>
<li>
<p>Only an invocation of business method on an EJB session bean is subject to EJB services such as declarative transaction management, concurrency, security and asynchronicity, as defined by the EJB specification.</p>
</li>
<li>
<p>Additionally, invocations of message listener methods of message-driven beans during message delivery are passed through method interceptors.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="stateful_lifecycle"><a class="anchor" href="#stateful_lifecycle"></a>21.1.1. Lifecycle of EJB stateful session beans</h4>
<div class="paragraph">
<p>When the <code>create()</code> method of a <code>Bean</code> object that represents an EJB stateful session bean that is called, the container creates and returns a container-specific internal local reference to a new EJB session bean instance. The reference must be passivation capable. This reference is not directly exposed to the application.
When the <code>create()</code> method of a <code>Bean</code> object that represents an EJB stateful session bean that is called, the container creates and returns a container-specific internal local reference to a new EJB session bean instance. The reference must be passivation capable. This reference is not directly exposed to the application.</p>
</div>
<div class="paragraph">
<p>Before injecting or returning a contextual instance to the application, the container transforms its internal reference into an object that implements the bean types expected by the application and delegates method invocations to the underlying EJB stateful session bean instance. This object must be passivation capable.</p>
</div>
<div class="paragraph">
<p>When the <code>destroy()</code> method is called, and if the underlying EJB was not already removed by direct invocation of a remove method by the application, the container removes the EJB stateful session bean.
The <code>@PreDestroy</code> callback must be invoked by the container.</p>
</div>
<div class="paragraph">
<p>Note that the container performs additional work when the underlying EJB is created and removed, as defined in <a href="#injection">Dependency injection</a></p>
</div>
</div>
<div class="sect3">
<h4 id="stateless_lifecycle"><a class="anchor" href="#stateless_lifecycle"></a>21.1.2. Lifecycle of EJB stateless and singleton session beans</h4>
<div class="paragraph">
<p>When the <code>create()</code> method of a <code>Bean</code> object that represents an EJB stateless session or singleton session bean is called, the container creates and returns a container-specific internal local reference to the EJB session bean.
This reference is not directly exposed to the application.</p>
</div>
<div class="paragraph">
<p>Before injecting or returning a contextual instance to the application, the container transforms its internal reference into an object that implements the bean types expected by the application and delegates method invocations to the underlying EJB session bean.
This object must be passivation capable.</p>
</div>
<div class="paragraph">
<p>When the <code>destroy()</code> method is called, the container simply discards this internal reference.</p>
</div>
<div class="paragraph">
<p>Note that the container performs additional work when the underlying EJB is created and removed, as defined in <a href="#injection">Dependency injection</a></p>
</div>
</div>
<div class="sect3">
<h4 id="resource_lifecycle"><a class="anchor" href="#resource_lifecycle"></a>21.1.3. Lifecycle of resources</h4>
<div class="paragraph">
<p>When the <code>create()</code> method of a <code>Bean</code> object that represents a resource is called, the container creates and returns a container-specific internal reference to the Jakarta EE component environment resource, entity manager, entity manager factory, remote EJB instance or web service reference. This reference is not directly exposed to the application.</p>
</div>
<div class="paragraph">
<p>Before injecting or returning a contextual instance to the application, the container transforms its internal reference into an object that implements the bean types expected by the application and delegates method invocations to the underlying resource, entity manager, entity manager factory, remote EJB instance or web service reference. This object must be passivation capable.</p>
</div>
<div class="paragraph">
<p>The container must perform ordinary Jakarta EE component environment injection upon any non-static field that functions as a resource declaration, as defined by the Jakarta EE platform and Common Annotations for the Java platform specifications.
The container is not required to perform Jakarta EE component environment injection upon a static field.
Portable applications should not rely upon the value of a static field that functions as a resource declaration.</p>
</div>
<div class="paragraph">
<p>References to EJBs and web services are always dependent scoped and a new instance must be obtained for every injection performed.</p>
</div>
<div class="paragraph">
<p>For an entity manager associated with a resource definition, it must behave as though it were injected directly using <code>@PersistenceContext</code>.</p>
</div>
<div class="paragraph">
<p>When the <code>destroy()</code> method of a bean which represents a remote stateful EJB reference is called, the container will <em>not</em> automatically destroy the EJB reference. The application must explicitly call the method annotated <code>@Remove</code>. This behavior differs to that specified in <a href="#stateful_lifecycle">Lifecycle of EJB stateful session beans</a> for beans which represent a local stateful EJB reference</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="decorators_ee"><a class="anchor" href="#decorators_ee"></a>22. Decorators in Jakarta EE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for managed beans in <a href="#decorators">Decorators</a> to EJB session beans.</p>
</div>
<div class="sect2">
<h3 id="decorator_bean_ee"><a class="anchor" href="#decorator_bean_ee"></a>22.1. Decorator beans in Jakarta EE</h3>
<div class="paragraph">
<p>Decorators of an EJB session bean must comply with the bean provider programming restrictions defined by the EJB specification.
Decorators of an EJB stateful session bean must comply with the rules for instance passivation and conversational state defined by the EJB specification.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="interceptors_ee"><a class="anchor" href="#interceptors_ee"></a>23. Interceptor bindings in Jakarta EE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>EJB session and message-driven beans support interception as defined in <a href="#interceptors">Interceptor bindings</a>.</p>
</div>
<div class="sect2">
<h3 id="enabled_interceptors_ee"><a class="anchor" href="#enabled_interceptors_ee"></a>23.1. Interceptor enablement and ordering in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#enabled_interceptors">Interceptor enablement and ordering</a> and also ensured that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Interceptors declared using interceptor bindings are called after interceptors declared using the <code>@Interceptor</code> annotation (or using the corresponding element of a deployment descriptor).</p>
</li>
<li>
<p>Interceptors declared using interceptor bindings are called before any around-invoke, around-timeout, or lifecycle event callback methods declared on the target class or any superclass of the target class.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="interceptor_resolution_ee"><a class="anchor" href="#interceptor_resolution_ee"></a>23.2. Interceptor resolution in Jakarta EE</h3>
<div class="paragraph">
<p>For a custom implementation of the <code>Interceptor</code> interface defined in <a href="#interceptor">The <code>Interceptor</code> interface</a>, the container also calls <code>intercepts()</code> to determine if the interceptor intercepts an EJB timeout method invocation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="events_ee"><a class="anchor" href="#events_ee"></a>24. Events in Jakarta EE</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="observer_methods_ee"><a class="anchor" href="#observer_methods_ee"></a>24.1. Observer methods in EJB session beans</h3>
<div class="paragraph">
<p>An observer method may also be a non-abstract method of an EJB session bean class.
It must be either a business method exposed by a local business interface of the EJB or a static method of the bean class.</p>
</div>
<div class="sect3">
<h4 id="observes_ee"><a class="anchor" href="#observes_ee"></a>24.1.1. Declaring an observer method in an EJB</h4>
<div class="paragraph">
<p>If a non-static method of a session bean class has a parameter annotated <code>@Observes</code> or <code>@ObservesAsync</code>, and the method is not a business method exposed by a local business interface of the EJB, the container automatically detects the problem and treats it as a definition error.</p>
</div>
</div>
<div class="sect3">
<h4 id="observer_method_invocation_context_ee"><a class="anchor" href="#observer_method_invocation_context_ee"></a>24.1.2. Observer method invocation context in Jakarta EE</h4>
<div class="paragraph">
<p>When Running in Jakarta EE, the container must extend the rules defined in <a href="#observer_method_invocation_context">Observer method invocation context</a> and must also ensure that all kinds of observers are called in the same client security context as the invocation of <code>Event.fire()</code> or <code>Event.fireAsync()</code> or <code>BeanManager.fireEvent()</code>.</p>
</div>
<div class="paragraph">
<p>The transaction and security contexts for a business method exposed by a local business interface of an EJB session bean also depend upon the transaction attribute and <code>@RunAs</code> descriptor, if any.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spi_ee"><a class="anchor" href="#spi_ee"></a>25. Portable extensions in Jakarta EE</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="bean_ee"><a class="anchor" href="#bean_ee"></a>25.1. The <code>Bean</code> interface in Jakarta EE</h3>
<div class="paragraph">
<p>When Running in Jakarta EE, the container must extend the rules defined in <a href="#bean">The <code>Bean</code> interface</a> for managed bean to EJB session bean.</p>
</div>
<div class="sect3">
<h4 id="interceptor_ee"><a class="anchor" href="#interceptor_ee"></a>25.1.1. The <code>Interceptor</code> interface in Jakarta EE</h4>
<div class="paragraph">
<p>When Running in Jakarta EE, the container must extend the rules defined in <a href="#interceptor">The <code>Interceptor</code> interface</a> and must also ensure that</p>
</div>
<div class="paragraph">
<p><code>PRE_PASSIVATE</code>, <code>POST_ACTIVATE</code> and <code>AROUND_TIMEOUT</code> InterceptorType values are linked to EJB lifecycle callback or timeout method.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="injectiontarget_ee"><a class="anchor" href="#injectiontarget_ee"></a>25.2. <code>InjectionTarget</code> interface in Jakarta EE</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined for <code>InjectionTarget</code> in <a href="#injectiontarget">The <code>Producer</code> and <code>InjectionTarget</code> interfaces</a> and must also ensure that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>when <code>inject()</code> is called, The container performs Jakarta EE component environment injection, according to the semantics required by the Jakarta EE platform specification, sets the value of all injected fields, and calls all initializer methods, as defined in <a href="#fields_initializer_methods_ee">Injection of fields and initializer methods in Jakarta EE</a>.</p>
</li>
<li>
<p><code>@PostConstruct</code> callback is called according to the semantics required by the Jakarta EE platform specification.</p>
</li>
<li>
<p><code>@PreDestroy</code> callback is called according to the semantics required by the Jakarta EE platform specification.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="beanmanager_ee"><a class="anchor" href="#beanmanager_ee"></a>25.3. The <code>BeanManager</code> object in Jakarta EE</h3>
<div class="sect3">
<h4 id="provider_ee"><a class="anchor" href="#provider_ee"></a>25.3.1. Obtaining a reference to the CDI container in Jakarta EE</h4>
<div class="paragraph">
<p>A Jakarta EE container is required to provide a CDI provider that will allow access to the current container for any Jakarta EE application or Jakarta EE module which contains enabled beans.</p>
</div>
<div class="paragraph">
<p>Jakarta EE Components may obtain an instance of <code>BeanManager</code> from JNDI by looking up the name <code>java:comp/BeanManager</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="bm_wrap_expressionfactory"><a class="anchor" href="#bm_wrap_expressionfactory"></a>25.3.2. Wrapping a Unified EL <code>ExpressionFactory</code></h4>
<div class="paragraph">
<p>The method <code>BeanManager.wrapExpressionFactory()</code> returns a wrapper <code>jakarta.el.ExpressionFactory</code> that delegates <code>MethodExpression</code> and <code>ValueExpression</code> creation to the given <code>ExpressionFactory</code>. When a Unified EL expression is evaluated using a <code>MethodExpression</code> or <code>ValueExpression</code> returned by the wrapper <code>ExpressionFactory</code>, the rules defined in <a href="#dependent_scope_el">Dependent pseudo-scope and Unified EL</a> are enforced by the container.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> ExpressionFactory wrapExpressionFactory(ExpressionFactory expressionFactory);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="alternative_metadata_sources_ee"><a class="anchor" href="#alternative_metadata_sources_ee"></a>25.4. Alternative metadata sources and EJB</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#alternative_metadata_sources">Alternative metadata sources</a> and ensure that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>when an <code>AnnotatedType</code> represents an EJB session bean class, <code>Annotated.getTypeClosure()</code> must returns the EJB session bean types as defined in <a href="#session_bean_types">Bean types of a session bean</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="init_events_ee"><a class="anchor" href="#init_events_ee"></a>25.5. Addition to Container lifecycle events in Jakarta EE</h3>
<div class="sect3">
<h4 id="process_annotated_type_ee"><a class="anchor" href="#process_annotated_type_ee"></a>25.5.1. <code>ProcessAnnotatedType</code> event in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#process_annotated_type"><code>ProcessAnnotatedType</code> event</a> to Jakarta EE component and EJB session bean classes.</p>
</div>
</div>
<div class="sect3">
<h4 id="process_injection_point_ee"><a class="anchor" href="#process_injection_point_ee"></a>25.5.2. <code>ProcessInjectionPoint</code> event and EJB</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must also fire an event for every injection point of every Jakarta EE component class supporting injection that may be instantiated by the container at runtime, including every managed bean declared using <code>@ManagedBean</code>, EJB session or message-driven bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="process_injection_target_ee"><a class="anchor" href="#process_injection_target_ee"></a>25.5.3. <code>ProcessInjectionTarget</code> event and EJB</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must also fire an event for every Jakarta EE component class supporting injection that may be instantiated by the container at runtime, including every managed bean declared using <code>@ManagedBean</code>, EJB session or message-driven bean.</p>
</div>
<div class="paragraph">
<p>The container must extend the rules defined in <a href="#process_injection_target"><code>ProcessInjectionTarget</code> event</a> for managed bean to EJB session bean and other Jakarta EE component class supporting injection.</p>
</div>
<div class="paragraph">
<p>For example, this observer decorates the <code>InjectionTarget</code> for all servlets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">&lt;T <span class="directive">extends</span> Servlet&gt; <span class="type">void</span> decorateServlet(<span class="annotation">@Observes</span> ProcessInjectionTarget&lt;T&gt; pit) {
    pit.setInjectionTarget( decorate( pit.getInjectionTarget() ) );
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="process_bean_attributes_ee"><a class="anchor" href="#process_bean_attributes_ee"></a>25.5.4. <code>ProcessBeanAttributes</code> event and EJB</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#process_bean_attributes"><code>ProcessBeanAttributes</code> event</a> to EJB session bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="process_bean_ee"><a class="anchor" href="#process_bean_ee"></a>25.5.5. <code>ProcessBean</code> event and EJB</h4>
<div class="paragraph">
<p>In addition to definition given in <a href="#process_bean"><code>ProcessBean</code> event</a> the following apply:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For a session bean with bean class <code>X</code>, the container must raise an event of type <code>ProcessSessionBean&lt;X&gt;</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Resources are considered to be producer fields.</p>
</div>
<div class="paragraph">
<p>When running in Jakarta EE, the interface <code>jakarta.enterprise.inject.spi.ProcessBean</code> is also a supertype of <code>jakarta.enterprise.inject.spi.ProcessSession</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ProcessSessionBean</span>&lt;X&gt;
        <span class="directive">extends</span> ProcessManagedBean&lt;<span class="predefined-type">Object</span>&gt; {
    <span class="directive">public</span> <span class="predefined-type">String</span> getEjbName();
    <span class="directive">public</span> SessionBeanType getSessionBeanType();
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getEjbName()</code> returns the EJB name of the session bean.</p>
</li>
<li>
<p><code>getSessionBeanType()</code> returns a <code>jakarta.enterprise.inject.spi.SessionBeanType</code> representing the kind of session bean.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">enum</span> SessionBeanType { STATELESS, STATEFUL, SINGLETON }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="packaging_deployment_ee"><a class="anchor" href="#packaging_deployment_ee"></a>26. Packaging and deployment in Jakarta EE</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="bean_archive_ee"><a class="anchor" href="#bean_archive_ee"></a>26.1. Bean archive with EJB Session Beans</h3>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#bean_archive">Bean archives</a> with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <em>implicit bean archive</em> may also contain EJB session beans, and</p>
</li>
<li>
<p>EJB session bean should be considered as bean class with bean defining annotation when determining if and archive is an <em>implicit bean archive</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When determining which archives are bean archives, the container must also consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>EJB jars or application client jars</p>
</li>
<li>
<p>The <code>WEB-INF/classes</code> directory of a war</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container is not required to support application client jar bean archives.</p>
</div>
<div class="paragraph">
<p>A Jakarta EE container is required by the Jakarta EE specification to support Jakarta EE modules.</p>
</div>
<div class="paragraph">
<p>In a war, the <code>beans.xml</code> file must be named:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>WEB-INF/beans.xml</code>  or <code>WEB-INF/classes/META-INF/beans.xml</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a war has a file named <code>beans.xml</code> in both the <code>WEB-INF</code> directory and in the <code>WEB-INF/classes/META-INF</code> directory, then non-portable behavior results.
Portable applications must have a <code>beans.xml</code> file in only one of the <code>WEB-INF</code> or the <code>WEB-INF/classes/META-INF</code> directories.</p>
</div>
<div class="paragraph">
<p>The following additional rules apply regarding container search for beans:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In an application deployed as an ear, the container searches every bean archive bundled with or referenced by the ear, including bean archives bundled with or referenced by wars, EJB jars and rars contained in the ear.
The bean archives might be library jars, EJB jars or war <code>WEB-INF/classes</code> directories.</p>
</li>
<li>
<p>In an application deployed as a war, the container searches every bean archive bundled with or referenced by the war.
The bean archives might be library jars or the <code>WEB-INF/classes</code> directory.</p>
</li>
<li>
<p>In an application deployed as an EJB jar, the container searches the EJB jar, if it is a bean archive, and every bean archive referenced by the EJB jar.</p>
</li>
<li>
<p>In an application deployed as a rar, the container searches every bean archive bundled with or referenced by the rar.</p>
</li>
<li>
<p>An embeddable EJB container searches each bean archive in the JVM classpath that is listed in the value of the embeddable container initialization property <code>jakarta.ejb.embeddable.modules</code>, or every bean archive in the JVM classpath if the property is not specified.
The bean archives might be directories, library jars or EJB jars.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="type_bean_discovery_ee"><a class="anchor" href="#type_bean_discovery_ee"></a>26.2. Type and Bean discovery for EJB</h3>
<div class="paragraph">
<p>In Jakarta EE, the container automatically discovers EJB session beans and other Jakarta EE component class supporting injection, in bean archives like it does for managed bean as defined in <a href="#type_bean_discovery">Type and Bean discovery</a>.</p>
</div>
<div class="sect3">
<h4 id="bean_discovery_steps_ee"><a class="anchor" href="#bean_discovery_steps_ee"></a>26.2.1. Bean discovery in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#bean_discovery_steps">Bean discovery</a> and must also discover each EJB session beans.</p>
</div>
</div>
<div class="sect3">
<h4 id="trimmed_bean_archive_ee"><a class="anchor" href="#trimmed_bean_archive_ee"></a>26.2.2. Trimmed bean archive in Jakarta EE</h4>
<div class="paragraph">
<p>When running in Jakarta EE, the container must extend the rules defined in <a href="#trimmed_bean_archive">Trimmed bean archive</a> and must ensure that EJB session beans are not removed from the set of discovered types.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="el"><a class="anchor" href="#el"></a>26.3. Integration with Unified EL</h3>
<div class="paragraph">
<p>The container must provide a Unified EL <code>ELResolver</code> to the servlet engine and JSF implementation that resolves bean names using the rules of name resolution defined in <a href="#name_resolution">Name resolution</a> and resolving ambiguities according to <a href="#ambig_names">Ambiguous names</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a name used in an EL expression does not resolve to any bean, the <code>ELResolver</code> must return a null value.</p>
</li>
<li>
<p>Otherwise, if a name used in an EL expression resolves to exactly one bean, the <code>ELResolver</code> must return a contextual instance of the bean, as defined in <a href="#contextual_instance">Contextual instance of a bean</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
 3.0<br>
Last updated 2020-08-26 16:23:47 GMT
</div>
</div>
</body>
</html>