<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.2) on Tue Jun 21 14:45:04 UTC 2022 -->
<title>Push (Jakarta EE Web Profile API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2022-06-21">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Push (Jakarta EE Web Profile API)";
        }
    }
    catch(err) {
    }
//-->
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Push.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><br>Jakarta EE Web Profile API v10.0.0</div>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">jakarta.faces.push</a></div>
<h2 title="Annotation Type Push" class="title">Annotation Type Push</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre><a href="../../inject/Qualifier.html" title="annotation in jakarta.inject">@Qualifier</a>
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/Retention.html?is-external=true" title="class or interface in java.lang.annotation" class="externalLink">@Retention</a>(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/RetentionPolicy.html?is-external=true#RUNTIME" title="class or interface in java.lang.annotation" class="externalLink">RUNTIME</a>)
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/Target.html?is-external=true" title="class or interface in java.lang.annotation" class="externalLink">@Target</a>({<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/ElementType.html?is-external=true#METHOD" title="class or interface in java.lang.annotation" class="externalLink">METHOD</a>,<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/ElementType.html?is-external=true#FIELD" title="class or interface in java.lang.annotation" class="externalLink">FIELD</a>,<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/annotation/ElementType.html?is-external=true#PARAMETER" title="class or interface in java.lang.annotation" class="externalLink">PARAMETER</a>})
public @interface <span class="memberNameLabel">Push</span></pre>
<div class="block"><p class="changed_added_2_3">
 The CDI annotation <code>&#64;</code><a href="Push.html" title="annotation in jakarta.faces.push"><code>Push</code></a> allows you to inject a <a href="PushContext.html" title="interface in jakarta.faces.push"><code>PushContext</code></a> associated with a given
 <code>&lt;f:websocket&gt;</code> channel in any container managed artifact in WAR.

 <pre>
 &#64;Inject
 &#64;Push
 private PushContext channelName;
 </pre>


 <h2 id="configuration"><a href="#configuration">Configuration</a></h2>
 <p>
 First enable the websocket endpoint by below boolean context parameter in <code>web.xml</code>.

 <pre>
 &lt;context-param&gt;
     &lt;param-name&gt;jakarta.faces.ENABLE_WEBSOCKET_ENDPOINT&lt;/param-name&gt;
     &lt;param-value&gt;true&lt;/param-value&gt;
 &lt;/context-param&gt;
 </pre>


 <h2 id="usage-client"><a href="#usage-client">Usage (client)</a></h2>
 <p>
 Declare <strong><code>&lt;f:websocket&gt;</code></strong> tag in the Jakarta Faces view with at least a
 <strong><code>channel</code></strong> name and an <strong><code>onmessage</code></strong> JavaScript listener
 function. The channel name may not be a Jakarta Expression Language expression and it may only contain alphanumeric
 characters, hyphens, underscores and periods.
 <p>
 Here's an example which refers an existing JavaScript listener function.

 <pre>
 &lt;f:websocket channel="someChannel" onmessage="someWebsocketListener" /&gt;
 </pre>

 <pre>
 function someWebsocketListener(message, channel, event) {
     console.log(message);
 }
 </pre>
 <p>
 Here's an example which declares an inline JavaScript listener function.

 <pre>
 &lt;f:websocket channel="someChannel" onmessage="function(message) { console.log(message); }" /&gt;
 </pre>
 <p>
 The <code>onmessage</code> JavaScript listener function will be invoked with three arguments:
 <ul>
 <li><code>message</code>: the push message as JSON object.</li>
 <li><code>channel</code>: the channel name.</li>
 <li><code>event</code>: the raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent"><code>
 MessageEvent</code></a> instance.</li>
 </ul>
 <p>
 In case your server is configured to run WS container on a different TCP port than the HTTP container, then you can
 use the optional <strong><code>jakarta.faces.WEBSOCKET_ENDPOINT_PORT</code></strong> integer context parameter in
 <code>web.xml</code> to explicitly specify the port.

 <pre>
 &lt;context-param&gt;
     &lt;param-name&gt;jakarta.faces.WEBSOCKET_ENDPOINT_PORT&lt;/param-name&gt;
     &lt;param-value&gt;8000&lt;/param-value&gt;
 &lt;/context-param&gt;
 </pre>
 <p>
 When successfully connected, the websocket is by default open as long as the document is open, and it will
 auto-reconnect at increasing intervals when the connection is closed/aborted as result of e.g. a network error or
 server restart. It will not auto-reconnect when the very first connection attempt already fails. The websocket will
 be implicitly closed once the document is unloaded.


 <h2 id="usage-server"><a href="#usage-server">Usage (server)</a></h2>
 <p>
 In WAR side, you can inject <strong><a href="PushContext.html" title="interface in jakarta.faces.push"><code>PushContext</code></a></strong> via <strong><code>&#64;</code><a href="Push.html" title="annotation in jakarta.faces.push"><code>Push</code></a></strong>
 annotation on the given channel name in any CDI/container managed artifact such as <code>@Named</code>,
 <code>@WebServlet</code>, etc wherever you'd like to send a push message and then invoke
 <strong><a href="PushContext.html#send(java.lang.Object)"><code>PushContext.send(Object)</code></a></strong> with any Java object representing the push message.

 <pre>
 &#64;Inject
 &#64;Push
 private PushContext someChannel;

 public void sendMessage(Object message) {
     someChannel.send(message);
 }
 </pre>
 <p>
 By default the name of the channel is taken from the name of the variable into which injection takes place. The
 channel name can be optionally specified via the <code>channel</code> attribute. The example below injects the push
 context for channel name <code>foo</code> into a variable named <code>bar</code>.

 <pre>
 &#64;Inject
 &#64;Push(channel = "foo")
 private PushContext bar;
 </pre>
 <p>
 The message object will be encoded as JSON and be delivered as <code>message</code> argument of the
 <code>onmessage</code> JavaScript listener function associated with the <code>channel</code> name. It can be a plain
 vanilla <code>String</code>, but it can also be a collection, map and even a javabean.
 <p>
 Although websockets support two-way communication, the <code>&lt;f:websocket&gt;</code> push is designed for one-way
 communication, from server to client. In case you intend to send some data from client to server, continue using
 Jakarta Faces ajax the usual way. This has among others the advantage of maintaining the Jakarta Faces
 view state, the HTTP session and, importantly, all security constraints on business service methods.


 <h2 id="scopes-and-users"><a href="#scopes-and-users">Scopes and users</a></h2>
 <p>
 By default the websocket is <code>application</code> scoped, i.e. any view/session throughout the web application
 having the same websocket channel open will receive the same push message. The push message can be sent by all users
 and the application itself.
 <p>
 The optional <strong><code>scope</code></strong> attribute can be set to <code>session</code> to restrict the push
 messages to all views in the current user session only. The push message can only be sent by the user itself and not
 by the application.

 <pre>
 &lt;f:websocket channel="someChannel" scope="session" ... /&gt;
 </pre>
 <p>
 The <code>scope</code> attribute can also be set to <code>view</code> to restrict the push messages to the current
 view only. The push message will not show up in other views in the same session even if it's the same URL. The push
 message can only be sent by the user itself and not by the application.

 <pre>
 &lt;f:websocket channel="someChannel" scope="view" ... /&gt;
 </pre>
 <p>
 The <code>scope</code> attribute may not be a Jakarta Expression Language expression and allowed values are
 <code>application</code>, <code>session</code> and <code>view</code>, case insensitive.
 <p>
 Additionally, the optional <strong><code>user</code></strong> attribute can be set to the unique identifier of the
 logged-in user, usually the login name or the user ID. This way the push message can be targeted to a specific user
 and can also be sent by other users and the application itself. The value of the <code>user</code> attribute must at
 least implement <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html?is-external=true" title="class or interface in java.io" class="externalLink"><code>Serializable</code></a> and have a low memory footprint, so putting entire user entity is not
 recommended.
 <p>
 E.g. when you're using container managed authentication or a related framework/library:

 <pre>
 &lt;f:websocket channel="someChannel" user="#{request.remoteUser}" ... /&gt;
 </pre>
 <p>
 Or when you have a custom user entity around in Jakarta Expression Language as <code>#{someLoggedInUser}</code> which
 has an <code>id</code> property representing its identifier:

 <pre>
 &lt;f:websocket channel="someChannel" user="#{someLoggedInUser.id}" ... /&gt;
 </pre>
 <p>
 When the <code>user</code> attribute is specified, then the <code>scope</code> defaults to <code>session</code> and
 cannot be set to <code>application</code>.
 <p>
 In the server side, the push message can be targeted to the user specified in the <code>user</code> attribute via
 <strong><a href="PushContext.html#send(java.lang.Object,S)"><code>PushContext.send(Object, Serializable)</code></a></strong>. The push message can be sent by all users and the
 application itself.

 <pre>
 &#64;Inject
 &#64;Push
 private PushContext someChannel;

 public void sendMessage(Object message, User recipientUser) {
     Long recipientUserId = recipientUser.getId();
     someChannel.send(message, recipientUserId);
 }
 </pre>
 <p>
 Multiple users can be targeted by passing a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink"><code>Collection</code></a> holding user identifiers to
 <strong><a href="PushContext.html#send(java.lang.Object,java.util.Collection)"><code>PushContext.send(Object, Collection)</code></a></strong>.

 <pre>
 public void sendMessage(Object message, Group recipientGroup) {
     Collection&lt;Long&gt; recipientUserIds = recipientGroup.getUserIds();
     someChannel.send(message, recipientUserIds);
 }
 </pre>


 <h2 id="connecting"><a href="#connecting">Conditionally connecting</a></h2>
 <p>
 You can use the optional <strong><code>connected</code></strong> attribute to control whether to auto-connect the
 websocket or not.

 <pre>
 &lt;f:websocket ... connected="#{bean.pushable}" /&gt;
 </pre>
 <p>
 It defaults to <code>true</code> and it's under the covers interpreted as a JavaScript instruction whether to open or
 close the websocket push connection. If the value is a Jakarta Expression Language expression and it becomes
 <code>false</code> during an ajax request, then the push connection will explicitly be closed during oncomplete of
 that ajax request.
 <p>
 You can also explicitly set it to <code>false</code> and manually open the push connection in client side by invoking
 <strong><code>faces.push.open(clientId)</code></strong>, passing the component's client ID.

 <pre>
 &lt;h:commandButton ... onclick="faces.push.open('foo')"&gt;
     &lt;f:ajax ... /&gt;
 &lt;/h:commandButton&gt;
 &lt;f:websocket id="foo" channel="bar" scope="view" ... connected="false" /&gt;
 </pre>
 <p>
 In case you intend to have an one-time push and don't expect more messages, you can optionally explicitly close the
 push connection from client side by invoking <strong><code>faces.push.close(clientId)</code></strong>, passing the
 component's client ID. For example, in the <code>onmessage</code> JavaScript listener function as below:

 <pre>
 function someWebsocketListener(message) {
     // ...
     faces.push.close('foo');
 }
 </pre>


 <h2 id="events-client"><a href="#events-client">Events (client)</a></h2>
 <p>
 The optional <strong><code>onopen</code></strong> JavaScript listener function can be used to listen on open of a
 websocket in client side. This will be invoked on the very first connection attempt, regardless of whether it will be
 successful or not. This will not be invoked when the websocket auto-reconnects a broken connection after the first
 successful connection.

 <pre>
 &lt;f:websocket ... onopen="websocketOpenListener" /&gt;
 </pre>

 <pre>
 function websocketOpenListener(channel) {
     // ...
 }
 </pre>
 <p>
 The <code>onopen</code> JavaScript listener function will be invoked with one argument:
 <ul>
 <li><code>channel</code>: the channel name, useful in case you intend to have a global listener.</li>
 </ul>
 <p class="changed_added_4_0">
 The optional <strong><code>onerror</code></strong> JavaScript listener function can be used to listen on a connection
 error whereby the websocket will attempt to reconnect. This will be invoked when the websocket can make an
 auto-reconnect attempt on a broken connection after the first successful connection. This will be <em>not</em>
 invoked when the very first connection attempt fails, or the server has returned close reason code <code>1000</code>
 (normal closure) or <code>1008</code> (policy violated), or the maximum reconnect attempts has exceeded. Instead,
 the <code>onclose</code> will be invoked.
 <pre>
 &lt;o:socket ... onerror="websocketErrorListener" /&gt;
 </pre>
 <pre>
 function websocketErrorListener(code, channel, event) {
     if (code == 1001) {
         // Server has returned an unexpected response code. E.g. 503, because it's shutting down.
     } else if (code == 1006) {
         // Server is not reachable anymore. I.e. it's not anymore listening on TCP/IP requests.
     } else {
         // Any other reason which is usually not -1, 1000 or 1008, as the onclose will be invoked instead.
     }

     // In any case, the websocket will attempt to reconnect. This function will be invoked again.
     // Once the websocket gives up reconnecting, the onclose will finally be invoked.
 }
 </pre>
 <p>
 The <code>onerror</code> JavaScript listener function will be invoked with three arguments:
 <ul>
 <li><code>code</code>: the close reason code as integer. See also
 <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC 6455 section 7.4.1</a> and <a href="../../websocket/CloseReason.CloseCodes.html" title="enum in jakarta.websocket"><code>CloseReason.CloseCodes</code></a> API for
 an elaborate list of all close codes.</li>
 <li><code>channel</code>: the channel name, useful in case you intend to have a global listener.</li>
 <li><code>event</code>: the raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent"><code>
 CloseEvent</code></a> instance, useful in case you intend to inspect it.</li>
 </ul>
 <p class="changed_modified_4_0">
 The optional <strong><code>onclose</code></strong> JavaScript listener function can be used to listen on (ab)normal
 close of a websocket. This will be invoked when the very first connection attempt fails, or the server has returned
 close reason code <code>1000</code> (normal closure) or <code>1008</code> (policy violated), or the maximum reconnect
 attempts has exceeded. This will <em>not</em> be invoked when the websocket can make an auto-reconnect attempt on a
 broken connection after the first successful connection. Instead, the <code>onerror</code> will be invoked.

 <pre>
 &lt;f:websocket ... onclose="websocketCloseListener" /&gt;
 </pre>

 <pre>
 function websocketCloseListener(code, channel, event) {
     if (code == -1) {
         // websockets not supported by client.
     } else if (code == 1000) {
         // Normal close (as result of expired session or view).
     } else {
         // Abnormal close reason (as result of an error).
     }
 }
 </pre>
 <p>
 The <code>onclose</code> JavaScript listener function will be invoked with three arguments:
 <ul>
 <li><code>code</code>: the close reason code as integer. If this is <code>-1</code>, then the websocket is simply
 not <a href="http://caniuse.com/websockets">supported</a> by the client. If this is <code>1000</code>, then it was
 normally closed due to an expired session or view. Else if this is not <code>1000</code>, then there may be an error.
 See also <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC 6455 section 7.4.1</a> and <a href="../../websocket/CloseReason.CloseCodes.html" title="enum in jakarta.websocket"><code>CloseReason.CloseCodes</code></a>
 API for an elaborate list of all close codes.</li>
 <li><code>channel</code>: the channel name.</li>
 <li><code>event</code>: the raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent"><code>
 CloseEvent</code></a> instance.</li>
 </ul>
 <p>
 When a session or view scoped websocket is automatically closed with close reason code <code>1000</code> by the server
 (and thus not manually by the client via <code>faces.push.close(clientId)</code>), then it means that the session or
 view has expired.


 <h2 id="events-server"><a href="#events-server">Events (server)</a></h2>
 <p>
 When a websocket has been opened, a new CDI <strong><a href="../event/WebsocketEvent.html" title="class in jakarta.faces.event"><code>WebsocketEvent</code></a></strong> will be fired with
 <strong><code>&#64;</code><a href="../event/WebsocketEvent.Opened.html" title="annotation in jakarta.faces.event"><code>WebsocketEvent.Opened</code></a></strong> qualifier. When a websocket has been closed, a new CDI
 <a href="../event/WebsocketEvent.html" title="class in jakarta.faces.event"><code>WebsocketEvent</code></a> will be fired with <strong><code>&#64;</code><a href="../event/WebsocketEvent.Closed.html" title="annotation in jakarta.faces.event"><code>WebsocketEvent.Closed</code></a></strong> qualifier. They can only
 be observed and collected in an application scoped CDI bean as below.

 <pre>
 &#64;ApplicationScoped
 public class WebsocketObserver {

     public void onOpen(&#64;Observes &#64;Opened WebsocketEvent event) {
         String channel = event.getChannel(); // Returns &lt;f:websocket channel&gt;.
         Long userId = event.getUser(); // Returns &lt;f:websocket user&gt;, if any.
         // ...
     }

     public void onClose(&#64;Observes &#64;Closed WebsocketEvent event) {
         String channel = event.getChannel(); // Returns &lt;f:websocket channel&gt;.
         Long userId = event.getUser(); // Returns &lt;f:websocket user&gt;, if any.
         CloseCode code = event.getCloseCode(); // Returns close reason code.
         // ...
     }

 }
 </pre>


 <h2 id="security"><a href="#security">Security considerations</a></h2>
 <p>
 If the websocket is declared in a page which is only restricted to logged-in users with a specific role, then you may
 want to add the URL of the push handshake request URL to the set of restricted URLs.
 <p>
 The push handshake request URL is composed of the URI prefix <strong><code>/jakarta.faces.push/</code></strong>,
 followed by channel name. So, in case of for example container managed security which has already restricted an
 example page <code>/user/foo.xhtml</code> to logged-in users with the example role <code>USER</code> on the example
 URL pattern <code>/user/*</code> in <code>web.xml</code> like below,

 <pre>
 &lt;security-constraint&gt;
     &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Restrict access to role USER.&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;
     &lt;/web-resource-collection&gt;
     &lt;auth-constraint&gt;
         &lt;role-name&gt;USER&lt;/role-name&gt;
     &lt;/auth-constraint&gt;
 &lt;/security-constraint&gt;
 </pre>
 <p>
 .. and the page <code>/user/foo.xhtml</code> in turn contains a <code>&lt;f:websocket channel="foo"&gt;</code>, then
 you need to add a restriction on push handshake request URL pattern of <code>/jakarta.faces.push/foo</code> like
 below.

 <pre>
 &lt;security-constraint&gt;
     &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Restrict access to role USER.&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;
         &lt;url-pattern&gt;/jakarta.faces.push/foo&lt;/url-pattern&gt;
     &lt;/web-resource-collection&gt;
     &lt;auth-constraint&gt;
         &lt;role-name&gt;USER&lt;/role-name&gt;
     &lt;/auth-constraint&gt;
 &lt;/security-constraint&gt;
 </pre>
 <p>
 As extra security, particularly for those public channels which can't be restricted by security constraints, the
 <code>&lt;f:websocket&gt;</code> will register all so far declared channels in the current HTTP session, and any
 incoming websocket open request will be checked whether they match the so far registered channels in the current
 HTTP session. In case the channel is unknown (e.g. randomly guessed or spoofed by endusers or manually reconnected
 after the session is expired), then the websocket will immediately be closed with close reason code
 <a href="../../websocket/CloseReason.CloseCodes.html#VIOLATED_POLICY"><code>CloseReason.CloseCodes.VIOLATED_POLICY</code></a> (<code>1008</code>). Also, when the HTTP session gets destroyed, all session and
 view scoped channels which are still open will explicitly be closed from server side with close reason code
 <a href="../../websocket/CloseReason.CloseCodes.html#NORMAL_CLOSURE"><code>CloseReason.CloseCodes.NORMAL_CLOSURE</code></a> (<code>1000</code>). Only application scoped websockets remain open and are still
 reachable from server end even when the session or view associated with the page in client side is expired.


 <h2 id="ui"><a href="#ui">Ajax support</a></h2>
 <p>
 In case you'd like to perform complex UI updates depending on the received push message, then you can nest
 <code>&lt;f:ajax&gt;</code> inside <code>&lt;f:websocket&gt;</code>. Here's an example:

 <pre>
 &lt;h:panelGroup id="foo"&gt;
     ... (some complex UI here) ...
 &lt;/h:panelGroup&gt;

 &lt;h:form&gt;
     &lt;f:websocket channel="someChannel" scope="view"&gt;
         &lt;f:ajax event="someEvent" listener="#{bean.pushed}" render=":foo" /&gt;
     &lt;/f:websocket&gt;
 &lt;/h:form&gt;
 </pre>
 <p>
 Here, the push message simply represents the ajax event name. You can use any custom event name.

 <pre>
 someChannel.send("someEvent");
 </pre>
 <p>
 An alternative is to combine <code>&lt;w:websocket&gt;</code> with <code>&lt;h:commandScript&gt;</code>. E.g.

 <pre>
 &lt;h:panelGroup id="foo"&gt;
     ... (some complex UI here) ...
 &lt;/h:panelGroup&gt;

 &lt;f:websocket channel="someChannel" scope="view" onmessage="someCommandScript" /&gt;
 &lt;h:form&gt;
     &lt;h:commandScript name="someCommandScript" action="#{bean.pushed}" render=":foo" /&gt;
 &lt;/h:form&gt;
 </pre>
 <p>
 If you pass a <code>Map&lt;String,V&gt;</code> or a JavaBean as push message object, then all entries/properties will
 transparently be available as request parameters in the command script method <code>#{bean.pushed}</code>.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.3</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="PushContext.html" title="interface in jakarta.faces.push"><code>PushContext</code></a>, 
<a href="../component/UIWebsocket.html" title="class in jakarta.faces.component"><code>UIWebsocket</code></a>, 
<a href="../event/WebsocketEvent.html" title="class in jakarta.faces.event"><code>WebsocketEvent</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="annotation.type.optional.element.summary">
<!--   -->
</a>
<h3>Optional Element Summary</h3>
<table class="memberSummary">
<caption><span>Optional Elements</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Optional Element</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#channel()">channel</a></span></code></th>
<td class="colLast">
<div class="block">(Optional) The name of the push channel.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="annotation.type.element.detail">
<!--   -->
</a>
<h3>Element Detail</h3>
<a id="channel()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>channel</h4>
<pre><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;channel</pre>
<div class="block">(Optional) The name of the push channel. If not specified the name of the injection target field will be used.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The name of the push channel.</dd>
</dl>
<dl>
<dt>Default:</dt>
<dd>""</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Push.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><br>Jakarta EE Web Profile API v10.0.0</div>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small><p align="left">Copyright &#169; 2018,2022 Eclipse Foundation.<br>Use is subject to <a href="../../../doc-files/speclicense.html" target="_top">license terms</a>.</small></p>
</footer>
</body>
</html>
