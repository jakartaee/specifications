<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.2) on Tue Jun 21 14:45:34 UTC 2022 -->
<title>jakarta.inject (Jakarta EE Platform API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2022-06-21">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="jakarta.inject (Jakarta EE Platform API)";
        }
    }
    catch(err) {
    }
//-->
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><br>Jakarta EE Platform API v10.0.0</div>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<main role="main">
<div class="header">
<h1 title="Package" class="title">Package&nbsp;jakarta.inject</h1>
</div>
<div class="contentContainer">
<section role="region"><a id="package.description">
<!--   -->
</a>
<div class="block">This package specifies a means for obtaining objects in such a way as to
 maximize reusability, testability and maintainability compared to
 traditional approaches such as constructors, factories, and service
 locators (e.g., JNDI).&nbsp;This process, known as <i>dependency
 injection</i>, is beneficial to most nontrivial applications.

 <p>Many types depend on other types. For example, a <code>Stopwatch</code> might
 depend on a <code>TimeSource</code>. The types on which a type depends are
 known as its <i>dependencies</i>. The process of finding an instance of a
 dependency to use at run time is known as <i>resolving</i> the dependency.
 If no such instance can be found, the dependency is said to be
 <i>unsatisfied</i>, and the application is broken.

 <p>In the absence of dependency injection, an object can resolve its
 dependencies in a few ways. It can invoke a constructor, hard-wiring an
 object directly to its dependency's implementation and life cycle:

 <pre>   class Stopwatch {
     final TimeSource timeSource;
     Stopwatch () {
       timeSource = <b>new AtomicClock(...)</b>;
     }
     void start() { ... }
     long stop() { ... }
   }</pre>

 <p>If more flexibility is needed, the object can call out to a factory or
 service locator:

 <pre>   class Stopwatch {
     final TimeSource timeSource;
     Stopwatch () {
       timeSource = <b>DefaultTimeSource.getInstance()</b>;
     }
     void start() { ... }
     long stop() { ... }
   }</pre>

 <p>In deciding between these traditional approaches to dependency
 resolution, a programmer must make trade-offs. Constructors are more
 concise but restrictive. Factories decouple the client and implementation
 to some extent but require boilerplate code. Service locators decouple even
 further but reduce compile time type safety. All three approaches inhibit
 unit testing. For example, if the programmer uses a factory, each test
 against code that depends on the factory will have to mock out the factory
 and remember to clean up after itself or else risk side effects:

 <pre>   void testStopwatch() {
     <b>TimeSource original = DefaultTimeSource.getInstance();
     DefaultTimeSource.setInstance(new MockTimeSource());
     try {</b>
       // Now, we can actually test Stopwatch.
       Stopwatch sw = new Stopwatch();
       ...
     <b>} finally {
       DefaultTimeSource.setInstance(original);
     }</b>
   }</pre>

 <p>In practice, supporting this ability to mock out a factory results in
 even more boilerplate code. Tests that mock out and clean up after multiple
 dependencies quickly get out of hand. To make matters worse, a programmer
 must predict accurately how much flexibility will be needed in the future
 or else suffer the consequences. If a programmer initially elects to use a
 constructor but later decides that more flexibility is required, the
 programmer must replace every call to the constructor. If the programmer
 errs on the side of caution and write factories up front, it may result in
 a lot of unnecessary boilerplate code, adding noise, complexity, and
 error-proneness.

 <p><i>Dependency injection</i> addresses all of these issues. Instead of
 the programmer calling a constructor or factory, a tool called a
 <i>dependency injector</i> passes dependencies to objects:

 <pre>   class Stopwatch {
     final TimeSource timeSource;
     <b>@Inject Stopwatch(TimeSource timeSource)</b> {
       this.timeSource = timeSource;
     }
     void start() { ... }
     long stop() { ... }
   }</pre>

 <p>The injector further passes dependencies to other dependencies until it
 constructs the entire object graph. For example, suppose the programmer
 asked an injector to create a <code>StopwatchWidget</code> instance:

 <pre>   /** GUI for a Stopwatch &#42;/
   class StopwatchWidget {
     &#64;Inject StopwatchWidget(Stopwatch sw) { ... }
     ...
   }</pre>

 <p>The injector might:
 <ol>
   <li>Find a <code>TimeSource</code>
   <li>Construct a <code>Stopwatch</code> with the <code>TimeSource</code>
   <li>Construct a <code>StopwatchWidget</code> with the <code>Stopwatch</code>
 </ol>

 <p>This leaves the programmer's code clean, flexible, and relatively free
 of dependency-related infrastructure.

 <p>In unit tests, the programmer can now construct objects directly
 (without an injector) and pass in mock dependencies. The programmer no
 longer needs to set up and tear down factories or service locators in each
 test. This greatly simplifies our unit test:

 <pre>   void testStopwatch() {
     Stopwatch sw = new Stopwatch(new MockTimeSource());
     ...
   }</pre>

 <p>The total decrease in unit-test complexity is proportional to the
 product of the number of unit tests and the number of dependencies.

 <p><b>This package provides dependency injection annotations that enable
 portable classes</b>, but it leaves external dependency configuration up to
 the injector implementation. Programmers annotate constructors, methods,
 and fields to advertise their injectability (constructor injection is
 demonstrated in the examples above). A dependency injector identifies a
 class's dependencies by inspecting these annotations, and injects the
 dependencies at run time. Moreover, the injector can verify that all
 dependencies have been satisfied at <i>build time</i>. A service locator,
 by contrast, cannot detect unsatisfied dependencies until run time.

 <p>Injector implementations can take many forms. An injector could
 configure itself using XML, annotations, a DSL (domain-specific language),
 or even plain Java code. An injector could rely on reflection or code
 generation. An injector that uses compile-time code generation may not even
 have its own run time representation. Other injectors may not be able to
 generate code at all, neither at compile nor run time. A "container", for
 some definition, can be an injector, but this package specification aims to
 minimize restrictions on injector implementations.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="Inject.html" title="annotation in jakarta.inject"><code>@Inject</code></a></dd>
</dl>
</section>
<ul class="blockList">
<li class="blockList">
<table class="typeSummary">
<caption><span>Interface Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Interface</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="Provider.html" title="interface in jakarta.inject">Provider</a>&lt;T&gt;</th>
<td class="colLast">
<div class="block">Provides instances of <code>T</code>.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="typeSummary">
<caption><span>Annotation Types Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Annotation Type</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="Inject.html" title="annotation in jakarta.inject">Inject</a></th>
<td class="colLast">
<div class="block">Identifies injectable constructors, methods, and fields.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="Named.html" title="annotation in jakarta.inject">Named</a></th>
<td class="colLast">
<div class="block">String-based <a href="Qualifier.html" title="annotation in jakarta.inject">qualifier</a>.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="Qualifier.html" title="annotation in jakarta.inject">Qualifier</a></th>
<td class="colLast">
<div class="block">Identifies qualifier annotations.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colFirst" scope="row"><a href="Scope.html" title="annotation in jakarta.inject">Scope</a></th>
<td class="colLast">
<div class="block">Identifies scope annotations.</div>
</td>
</tr>
<tr class="altColor">
<th class="colFirst" scope="row"><a href="Singleton.html" title="annotation in jakarta.inject">Singleton</a></th>
<td class="colLast">
<div class="block">Identifies a type that the injector only instantiates once.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><br>Jakarta EE Platform API v10.0.0</div>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small><p align="left">Copyright &#169; 2018,2022 Eclipse Foundation.<br>Use is subject to <a href="../../doc-files/speclicense.html" target="_top">license terms</a>.</small></p>
</footer>
</body>
</html>
