<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (21) on Mon Dec 18 16:44:31 UTC 2023 -->
<title>jakarta.inject (Jakarta EE Core Profile API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2023-12-18">
<meta name="description" content="declaration: package: jakarta.inject">
<meta name="generator" content="javadoc/PackageWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="package-declaration-page">
<script type="text/javascript">var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><br>Jakarta EE Core Profile API v11.0.0-M1</div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li class="nav-bar-cell1-rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html#package">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Package:</p>
<ul>
<li><a href="#package-description">Description</a></li>
<li>Related Packages</li>
<li><a href="#class-summary">Classes and Interfaces</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Package:&nbsp;</li>
<li><a href="#package-description">Description</a>&nbsp;|&nbsp;</li>
<li>Related Packages&nbsp;|&nbsp;</li>
<li><a href="#class-summary">Classes and Interfaces</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<div class="header">
<h1 title="Package jakarta.inject" class="title">Package jakarta.inject</h1>
</div>
<hr>
<div class="package-signature">package <span class="element-name">jakarta.inject</span></div>
<section class="package-description" id="package-description">
<div class="block">This package specifies a means for obtaining objects in such a way as to
 maximize reusability, testability and maintainability compared to
 traditional approaches such as constructors, factories, and service
 locators (e.g., JNDI).&nbsp;This process, known as <i>dependency
 injection</i>, is beneficial to most nontrivial applications.

 <p>Many types depend on other types. For example, a <code>Stopwatch</code> might
 depend on a <code>TimeSource</code>. The types on which a type depends are
 known as its <i>dependencies</i>. The process of finding an instance of a
 dependency to use at run time is known as <i>resolving</i> the dependency.
 If no such instance can be found, the dependency is said to be
 <i>unsatisfied</i>, and the application is broken.

 <p>In the absence of dependency injection, an object can resolve its
 dependencies in a few ways. It can invoke a constructor, hard-wiring an
 object directly to its dependency's implementation and life cycle:

 <pre>   class Stopwatch {
     final TimeSource timeSource;
     Stopwatch () {
       timeSource = <b>new AtomicClock(...)</b>;
     }
     void start() { ... }
     long stop() { ... }
   }</pre>

 <p>If more flexibility is needed, the object can call out to a factory or
 service locator:

 <pre>   class Stopwatch {
     final TimeSource timeSource;
     Stopwatch () {
       timeSource = <b>DefaultTimeSource.getInstance()</b>;
     }
     void start() { ... }
     long stop() { ... }
   }</pre>

 <p>In deciding between these traditional approaches to dependency
 resolution, a programmer must make trade-offs. Constructors are more
 concise but restrictive. Factories decouple the client and implementation
 to some extent but require boilerplate code. Service locators decouple even
 further but reduce compile time type safety. All three approaches inhibit
 unit testing. For example, if the programmer uses a factory, each test
 against code that depends on the factory will have to mock out the factory
 and remember to clean up after itself or else risk side effects:

 <pre>   void testStopwatch() {
     <b>TimeSource original = DefaultTimeSource.getInstance();
     DefaultTimeSource.setInstance(new MockTimeSource());
     try {</b>
       // Now, we can actually test Stopwatch.
       Stopwatch sw = new Stopwatch();
       ...
     <b>} finally {
       DefaultTimeSource.setInstance(original);
     }</b>
   }</pre>

 <p>In practice, supporting this ability to mock out a factory results in
 even more boilerplate code. Tests that mock out and clean up after multiple
 dependencies quickly get out of hand. To make matters worse, a programmer
 must predict accurately how much flexibility will be needed in the future
 or else suffer the consequences. If a programmer initially elects to use a
 constructor but later decides that more flexibility is required, the
 programmer must replace every call to the constructor. If the programmer
 errs on the side of caution and write factories up front, it may result in
 a lot of unnecessary boilerplate code, adding noise, complexity, and
 error-proneness.

 <p><i>Dependency injection</i> addresses all of these issues. Instead of
 the programmer calling a constructor or factory, a tool called a
 <i>dependency injector</i> passes dependencies to objects:

 <pre>   class Stopwatch {
     final TimeSource timeSource;
     <b>@Inject Stopwatch(TimeSource timeSource)</b> {
       this.timeSource = timeSource;
     }
     void start() { ... }
     long stop() { ... }
   }</pre>

 <p>The injector further passes dependencies to other dependencies until it
 constructs the entire object graph. For example, suppose the programmer
 asked an injector to create a <code>StopwatchWidget</code> instance:

 <pre>   /** GUI for a Stopwatch &#42;/
   class StopwatchWidget {
     &#64;Inject StopwatchWidget(Stopwatch sw) { ... }
     ...
   }</pre>

 <p>The injector might:
 <ol>
   <li>Find a <code>TimeSource</code>
   <li>Construct a <code>Stopwatch</code> with the <code>TimeSource</code>
   <li>Construct a <code>StopwatchWidget</code> with the <code>Stopwatch</code>
 </ol>

 <p>This leaves the programmer's code clean, flexible, and relatively free
 of dependency-related infrastructure.

 <p>In unit tests, the programmer can now construct objects directly
 (without an injector) and pass in mock dependencies. The programmer no
 longer needs to set up and tear down factories or service locators in each
 test. This greatly simplifies our unit test:

 <pre>   void testStopwatch() {
     Stopwatch sw = new Stopwatch(new MockTimeSource());
     ...
   }</pre>

 <p>The total decrease in unit-test complexity is proportional to the
 product of the number of unit tests and the number of dependencies.

 <p><b>This package provides dependency injection annotations that enable
 portable classes</b>, but it leaves external dependency configuration up to
 the injector implementation. Programmers annotate constructors, methods,
 and fields to advertise their injectability (constructor injection is
 demonstrated in the examples above). A dependency injector identifies a
 class's dependencies by inspecting these annotations, and injects the
 dependencies at run time. Moreover, the injector can verify that all
 dependencies have been satisfied at <i>build time</i>. A service locator,
 by contrast, cannot detect unsatisfied dependencies until run time.

 <p>Injector implementations can take many forms. An injector could
 configure itself using XML, annotations, a DSL (domain-specific language),
 or even plain Java code. An injector could rely on reflection or code
 generation. An injector that uses compile-time code generation may not even
 have its own run time representation. Other injectors may not be able to
 generate code at all, neither at compile nor run time. A "container", for
 some definition, can be an injector, but this package specification aims to
 minimize restrictions on injector implementations.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="Inject.html" title="annotation interface in jakarta.inject"><code>@Inject</code></a></li>
</ul>
</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<li>
<div id="class-summary">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="class-summary-tab0" role="tab" aria-selected="true" aria-controls="class-summary.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary', 2)" class="active-table-tab">All Classes and Interfaces</button><button id="class-summary-tab1" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab1', 2)" class="table-tab">Interfaces</button><button id="class-summary-tab6" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab6', 2)" class="table-tab">Annotation Interfaces</button></div>
<div id="class-summary.tabpanel" role="tabpanel">
<div class="summary-table two-column-summary" aria-labelledby="class-summary-tab0">
<div class="table-header col-first">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color class-summary class-summary-tab6"><a href="Inject.html" title="annotation interface in jakarta.inject">Inject</a></div>
<div class="col-last even-row-color class-summary class-summary-tab6">
<div class="block">Identifies injectable constructors, methods, and fields.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab6"><a href="Named.html" title="annotation interface in jakarta.inject">Named</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab6">
<div class="block">String-based <a href="Qualifier.html" title="annotation interface in jakarta.inject">qualifier</a>.</div>
</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="Provider.html" title="interface in jakarta.inject">Provider</a>&lt;T&gt;</div>
<div class="col-last even-row-color class-summary class-summary-tab1">
<div class="block">Provides instances of <code>T</code>.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab6"><a href="Qualifier.html" title="annotation interface in jakarta.inject">Qualifier</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab6">
<div class="block">Identifies qualifier annotations.</div>
</div>
<div class="col-first even-row-color class-summary class-summary-tab6"><a href="Scope.html" title="annotation interface in jakarta.inject">Scope</a></div>
<div class="col-last even-row-color class-summary class-summary-tab6">
<div class="block">Identifies scope annotations.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab6"><a href="Singleton.html" title="annotation interface in jakarta.inject">Singleton</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab6">
<div class="block">Identifies a type that the injector only instantiates once.</div>
</div>
</div>
</div>
</div>
</li>
</ul>
</section>
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><p align="left">Copyright &#169; 2018,2023 Eclipse Foundation.<br>Use is subject to <a href="../../doc-files/speclicense.html" target="_top">license terms</a>.</small></p>
</footer>
</div>
</div>
</body>
</html>
