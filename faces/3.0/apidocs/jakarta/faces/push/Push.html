<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (14.0.1) on Tue Oct 06 14:36:15 CEST 2020 -->
<title>Push (Jakarta Server Faces API documentation)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2020-10-06">
<meta name="description" content="declaration: package: jakarta.faces.push, annotation type: Push">
<meta name="generator" content="javadoc/AnnotationTypeWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flexBox">
<header role="banner" class="flexHeader">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Push.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><br>Jakarta Server Faces API v3.0.0</div>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="skipNav"><a id="skip.navbar.top">
<!--   -->
</a></div>
</nav>
</header>
<div class="flexContent">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">jakarta.faces.push</a></div>
<h1 title="Annotation Type Push" class="title">Annotation Type Push</h1>
</div>
<div class="contentContainer">
<section class="description">
<hr>
<pre>@Qualifier
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true" title="class or interface in java.lang.annotation" class="externalLink">@Retention</a>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html?is-external=true#RUNTIME" title="class or interface in java.lang.annotation" class="externalLink">RUNTIME</a>)
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true" title="class or interface in java.lang.annotation" class="externalLink">@Target</a>({<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#METHOD" title="class or interface in java.lang.annotation" class="externalLink">METHOD</a>,<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#FIELD" title="class or interface in java.lang.annotation" class="externalLink">FIELD</a>,<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#PARAMETER" title="class or interface in java.lang.annotation" class="externalLink">PARAMETER</a>})
public @interface <span class="memberNameLabel">Push</span></pre>
<div class="block"><p class="changed_added_2_3">
 The CDI annotation <code>&#64;</code><a href="Push.html" title="annotation in jakarta.faces.push"><code>Push</code></a> allows you to inject a <a href="PushContext.html" title="interface in jakarta.faces.push"><code>PushContext</code></a> associated with a given
 <code>&lt;f:websocket&gt;</code> channel in any container managed artifact in WAR.

 <pre>
 &#64;Inject
 &#64;Push
 private PushContext channelName;
 </pre>


 <h3 id="configuration"><a href="#configuration">Configuration</a></h3>
 <p>
 First enable the web socket endpoint by below boolean context parameter in <code>web.xml</code>.

 <pre>
 &lt;context-param&gt;
     &lt;param-name&gt;jakarta.faces.ENABLE_WEBSOCKET_ENDPOINT&lt;/param-name&gt;
     &lt;param-value&gt;true&lt;/param-value&gt;
 &lt;/context-param&gt;
 </pre>


 <h3 id="usage-client"><a href="#usage-client">Usage (client)</a></h3>
 <p>
 Declare <strong><code>&lt;f:websocket&gt;</code></strong> tag in the Jakarta Server Faces view with at least a
 <strong><code>channel</code></strong> name and an <strong><code>onmessage</code></strong> JavaScript listener
 function. The channel name may not be a Jakarta Expression Language expression and it may only contain alphanumeric
 characters, hyphens, underscores and periods.
 <p>
 Here's an example which refers an existing JavaScript listener function.

 <pre>
 &lt;f:websocket channel="someChannel" onmessage="someWebsocketListener" /&gt;
 </pre>

 <pre>
 function someWebsocketListener(message, channel, event) {
     console.log(message);
 }
 </pre>
 <p>
 Here's an example which declares an inline JavaScript listener function.

 <pre>
 &lt;f:websocket channel="someChannel" onmessage="function(message) { console.log(message); }" /&gt;
 </pre>
 <p>
 The <code>onmessage</code> JavaScript listener function will be invoked with three arguments:
 <ul>
 <li><code>message</code>: the push message as JSON object.</li>
 <li><code>channel</code>: the channel name.</li>
 <li><code>event</code>: the raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent"><code>
 MessageEvent</code></a> instance.</li>
 </ul>
 <p>
 In case your server is configured to run WS container on a different TCP port than the HTTP container, then you can
 use the optional <strong><code>jakarta.faces.WEBSOCKET_ENDPOINT_PORT</code></strong> integer context parameter in
 <code>web.xml</code> to explicitly specify the port.

 <pre>
 &lt;context-param&gt;
     &lt;param-name&gt;jakarta.faces.WEBSOCKET_ENDPOINT_PORT&lt;/param-name&gt;
     &lt;param-value&gt;8000&lt;/param-value&gt;
 &lt;/context-param&gt;
 </pre>
 <p>
 When successfully connected, the web socket is by default open as long as the document is open, and it will
 auto-reconnect at increasing intervals when the connection is closed/aborted as result of e.g. a network error or
 server restart. It will not auto-reconnect when the very first connection attempt already fails. The web socket will
 be implicitly closed once the document is unloaded.


 <h3 id="usage-server"><a href="#usage-server">Usage (server)</a></h3>
 <p>
 In WAR side, you can inject <strong><a href="PushContext.html" title="interface in jakarta.faces.push"><code>PushContext</code></a></strong> via <strong><code>&#64;</code><a href="Push.html" title="annotation in jakarta.faces.push"><code>Push</code></a></strong>
 annotation on the given channel name in any CDI/container managed artifact such as <code>@Named</code>,
 <code>@WebServlet</code>, etc wherever you'd like to send a push message and then invoke
 <strong><a href="PushContext.html#send(java.lang.Object)"><code>PushContext.send(Object)</code></a></strong> with any Java object representing the push message.

 <pre>
 &#64;Inject
 &#64;Push
 private PushContext someChannel;

 public void sendMessage(Object message) {
     someChannel.send(message);
 }
 </pre>
 <p>
 By default the name of the channel is taken from the name of the variable into which injection takes place. The
 channel name can be optionally specified via the <code>channel</code> attribute. The example below injects the push
 context for channel name <code>foo</code> into a variable named <code>bar</code>.

 <pre>
 &#64;Inject
 &#64;Push(channel = "foo")
 private PushContext bar;
 </pre>
 <p>
 The message object will be encoded as JSON and be delivered as <code>message</code> argument of the
 <code>onmessage</code> JavaScript listener function associated with the <code>channel</code> name. It can be a plain
 vanilla <code>String</code>, but it can also be a collection, map and even a javabean.
 <p>
 Although web sockets support two-way communication, the <code>&lt;f:websocket&gt;</code> push is designed for one-way
 communication, from server to client. In case you intend to send some data from client to server, continue using
 Jakarta Server Faces ajax the usual way. This has among others the advantage of maintaining the Jakarta Server Faces
 view state, the HTTP session and, importantly, all security constraints on business service methods.


 <h3 id="scopes-and-users"><a href="#scopes-and-users">Scopes and users</a></h3>
 <p>
 By default the web socket is <code>application</code> scoped, i.e. any view/session throughout the web application
 having the same web socket channel open will receive the same push message. The push message can be sent by all users
 and the application itself.
 <p>
 The optional <strong><code>scope</code></strong> attribute can be set to <code>session</code> to restrict the push
 messages to all views in the current user session only. The push message can only be sent by the user itself and not
 by the application.

 <pre>
 &lt;f:websocket channel="someChannel" scope="session" ... /&gt;
 </pre>
 <p>
 The <code>scope</code> attribute can also be set to <code>view</code> to restrict the push messages to the current
 view only. The push message will not show up in other views in the same session even if it's the same URL. The push
 message can only be sent by the user itself and not by the application.

 <pre>
 &lt;f:websocket channel="someChannel" scope="view" ... /&gt;
 </pre>
 <p>
 The <code>scope</code> attribute may not be a Jakarta Expression Language expression and allowed values are
 <code>application</code>, <code>session</code> and <code>view</code>, case insensitive.
 <p>
 Additionally, the optional <strong><code>user</code></strong> attribute can be set to the unique identifier of the
 logged-in user, usually the login name or the user ID. This way the push message can be targeted to a specific user
 and can also be sent by other users and the application itself. The value of the <code>user</code> attribute must at
 least implement <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io" class="externalLink"><code>Serializable</code></a> and have a low memory footprint, so putting entire user entity is not
 recommended.
 <p>
 E.g. when you're using container managed authentication or a related framework/library:

 <pre>
 &lt;f:websocket channel="someChannel" user="#{request.remoteUser}" ... /&gt;
 </pre>
 <p>
 Or when you have a custom user entity around in Jakarta Expression Language as <code>#{someLoggedInUser}</code> which
 has an <code>id</code> property representing its identifier:

 <pre>
 &lt;f:websocket channel="someChannel" user="#{someLoggedInUser.id}" ... /&gt;
 </pre>
 <p>
 When the <code>user</code> attribute is specified, then the <code>scope</code> defaults to <code>session</code> and
 cannot be set to <code>application</code>.
 <p>
 In the server side, the push message can be targeted to the user specified in the <code>user</code> attribute via
 <strong><a href="PushContext.html#send(java.lang.Object,S)"><code>PushContext.send(Object, Serializable)</code></a></strong>. The push message can be sent by all users and the
 application itself.

 <pre>
 &#64;Inject
 &#64;Push
 private PushContext someChannel;

 public void sendMessage(Object message, User recipientUser) {
     Long recipientUserId = recipientUser.getId();
     someChannel.send(message, recipientUserId);
 }
 </pre>
 <p>
 Multiple users can be targeted by passing a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util" class="externalLink"><code>Collection</code></a> holding user identifiers to
 <strong><a href="PushContext.html#send(java.lang.Object,java.util.Collection)"><code>PushContext.send(Object, Collection)</code></a></strong>.

 <pre>
 public void sendMessage(Object message, Group recipientGroup) {
     Collection&lt;Long&gt; recipientUserIds = recipientGroup.getUserIds();
     someChannel.send(message, recipientUserIds);
 }
 </pre>


 <h3 id="connecting"><a href="#connecting">Conditionally connecting</a></h3>
 <p>
 You can use the optional <strong><code>connected</code></strong> attribute to control whether to auto-connect the web
 socket or not.

 <pre>
 &lt;f:websocket ... connected="#{bean.pushable}" /&gt;
 </pre>
 <p>
 It defaults to <code>true</code> and it's under the covers interpreted as a JavaScript instruction whether to open or
 close the web socket push connection. If the value is a Jakarta Expression Language expression and it becomes
 <code>false</code> during an ajax request, then the push connection will explicitly be closed during oncomplete of
 that ajax request.
 <p>
 You can also explicitly set it to <code>false</code> and manually open the push connection in client side by invoking
 <strong><code>jsf.push.open(clientId)</code></strong>, passing the component's client ID.

 <pre>
 &lt;h:commandButton ... onclick="jsf.push.open('foo')"&gt;
     &lt;f:ajax ... /&gt;
 &lt;/h:commandButton&gt;
 &lt;f:websocket id="foo" channel="bar" scope="view" ... connected="false" /&gt;
 </pre>
 <p>
 In case you intend to have an one-time push and don't expect more messages, you can optionally explicitly close the
 push connection from client side by invoking <strong><code>jsf.push.close(clientId)</code></strong>, passing the
 component's client ID. For example, in the <code>onmessage</code> JavaScript listener function as below:

 <pre>
 function someWebsocketListener(message) {
     // ...
     jsf.push.close('foo');
 }
 </pre>


 <h3 id="events-client"><a href="#events-client">Events (client)</a></h3>
 <p>
 The optional <strong><code>onopen</code></strong> JavaScript listener function can be used to listen on open of a web
 socket in client side. This will be invoked on the very first connection attempt, regardless of whether it will be
 successful or not. This will not be invoked when the web socket auto-reconnects a broken connection after the first
 successful connection.

 <pre>
 &lt;f:websocket ... onopen="websocketOpenListener" /&gt;
 </pre>

 <pre>
 function websocketOpenListener(channel) {
     // ...
 }
 </pre>
 <p>
 The <code>onopen</code> JavaScript listener function will be invoked with one argument:
 <ul>
 <li><code>channel</code>: the channel name, useful in case you intend to have a global listener.</li>
 </ul>
 <p>
 The optional <strong><code>onclose</code></strong> JavaScript listener function can be used to listen on (ab)normal
 close of a web socket. This will be invoked when the very first connection attempt fails, or the server has returned
 close reason code <code>1000</code> (normal closure) or <code>1008</code> (policy violated), or the maximum reconnect
 attempts has exceeded. This will not be invoked when the web socket can make an auto-reconnect attempt on a broken
 connection after the first successful connection.

 <pre>
 &lt;f:websocket ... onclose="websocketCloseListener" /&gt;
 </pre>

 <pre>
 function websocketCloseListener(code, channel, event) {
     if (code == -1) {
         // Web sockets not supported by client.
     } else if (code == 1000) {
         // Normal close (as result of expired session or view).
     } else {
         // Abnormal close reason (as result of an error).
     }
 }
 </pre>
 <p>
 The <code>onclose</code> JavaScript listener function will be invoked with three arguments:
 <ul>
 <li><code>code</code>: the close reason code as integer. If this is <code>-1</code>, then the web socket is simply
 not <a href="http://caniuse.com/websockets">supported</a> by the client. If this is <code>1000</code>, then it was
 normally closed. Else if this is not <code>1000</code>, then there may be an error. See also
 <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC 6455 section 7.4.1</a> and <code>CloseReason.CloseCodes</code> API for
 an elaborate list of all close codes.</li>
 <li><code>channel</code>: the channel name.</li>
 <li><code>event</code>: the raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent"><code>
 CloseEvent</code></a> instance.</li>
 </ul>
 <p>
 When a session or view scoped socket is automatically closed with close reason code <code>1000</code> by the server
 (and thus not manually by the client via <code>jsf.push.close(clientId)</code>), then it means that the session or
 view has expired.


 <h3 id="events-server"><a href="#events-server">Events (server)</a></h3>
 <p>
 When a web socket has been opened, a new CDI <strong><a href="../event/WebsocketEvent.html" title="class in jakarta.faces.event"><code>WebsocketEvent</code></a></strong> will be fired with
 <strong><code>&#64;</code><a href="../event/WebsocketEvent.Opened.html" title="annotation in jakarta.faces.event"><code>WebsocketEvent.Opened</code></a></strong> qualifier. When a web socket has been closed, a new CDI
 <a href="../event/WebsocketEvent.html" title="class in jakarta.faces.event"><code>WebsocketEvent</code></a> will be fired with <strong><code>&#64;</code><a href="../event/WebsocketEvent.Closed.html" title="annotation in jakarta.faces.event"><code>WebsocketEvent.Closed</code></a></strong> qualifier. They can only
 be observed and collected in an application scoped CDI bean as below.

 <pre>
 &#64;ApplicationScoped
 public class WebsocketObserver {

     public void onOpen(&#64;Observes &#64;Opened WebsocketEvent event) {
         String channel = event.getChannel(); // Returns &lt;f:websocket channel&gt;.
         Long userId = event.getUser(); // Returns &lt;f:websocket user&gt;, if any.
         // ...
     }

     public void onClose(&#64;Observes &#64;Closed WebsocketEvent event) {
         String channel = event.getChannel(); // Returns &lt;f:websocket channel&gt;.
         Long userId = event.getUser(); // Returns &lt;f:websocket user&gt;, if any.
         CloseCode code = event.getCloseCode(); // Returns close reason code.
         // ...
     }

 }
 </pre>


 <h3 id="security"><a href="#security">Security considerations</a></h3>
 <p>
 If the socket is declared in a page which is only restricted to logged-in users with a specific role, then you may
 want to add the URL of the push handshake request URL to the set of restricted URLs.
 <p>
 The push handshake request URL is composed of the URI prefix <strong><code>/jakarta.faces.push/</code></strong>,
 followed by channel name. So, in case of for example container managed security which has already restricted an
 example page <code>/user/foo.xhtml</code> to logged-in users with the example role <code>USER</code> on the example
 URL pattern <code>/user/*</code> in <code>web.xml</code> like below,

 <pre>
 &lt;security-constraint&gt;
     &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Restrict access to role USER.&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;
     &lt;/web-resource-collection&gt;
     &lt;auth-constraint&gt;
         &lt;role-name&gt;USER&lt;/role-name&gt;
     &lt;/auth-constraint&gt;
 &lt;/security-constraint&gt;
 </pre>
 <p>
 .. and the page <code>/user/foo.xhtml</code> in turn contains a <code>&lt;f:websocket channel="foo"&gt;</code>, then
 you need to add a restriction on push handshake request URL pattern of <code>/jakarta.faces.push/foo</code> like
 below.

 <pre>
 &lt;security-constraint&gt;
     &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Restrict access to role USER.&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;
         &lt;url-pattern&gt;/jakarta.faces.push/foo&lt;/url-pattern&gt;
     &lt;/web-resource-collection&gt;
     &lt;auth-constraint&gt;
         &lt;role-name&gt;USER&lt;/role-name&gt;
     &lt;/auth-constraint&gt;
 &lt;/security-constraint&gt;
 </pre>
 <p>
 As extra security, particularly for those public channels which can't be restricted by security constraints, the
 <code>&lt;f:websocket&gt;</code> will register all so far declared channels in the current HTTP session, and any
 incoming web socket open request will be checked whether they match the so far registered channels in the current
 HTTP session. In case the channel is unknown (e.g. randomly guessed or spoofed by endusers or manually reconnected
 after the session is expired), then the web socket will immediately be closed with close reason code
 <code>CloseReason.CloseCodes.VIOLATED_POLICY</code> (<code>1008</code>). Also, when the HTTP session gets destroyed, all session and
 view scoped channels which are still open will explicitly be closed from server side with close reason code
 <code>CloseReason.CloseCodes.NORMAL_CLOSURE</code> (<code>1000</code>). Only application scoped sockets remain open and are still
 reachable from server end even when the session or view associated with the page in client side is expired.


 <h3 id="ui"><a href="#ui">Ajax support</a></h3>
 <p>
 In case you'd like to perform complex UI updates depending on the received push message, then you can nest
 <code>&lt;f:ajax&gt;</code> inside <code>&lt;f:websocket&gt;</code>. Here's an example:

 <pre>
 &lt;h:panelGroup id="foo"&gt;
     ... (some complex UI here) ...
 &lt;/h:panelGroup&gt;

 &lt;h:form&gt;
     &lt;f:websocket channel="someChannel" scope="view"&gt;
         &lt;f:ajax event="someEvent" listener="#{bean.pushed}" render=":foo" /&gt;
     &lt;/f:websocket&gt;
 &lt;/h:form&gt;
 </pre>
 <p>
 Here, the push message simply represents the ajax event name. You can use any custom event name.

 <pre>
 someChannel.send("someEvent");
 </pre>
 <p>
 An alternative is to combine <code>&lt;w:websocket&gt;</code> with <code>&lt;h:commandScript&gt;</code>. E.g.

 <pre>
 &lt;h:panelGroup id="foo"&gt;
     ... (some complex UI here) ...
 &lt;/h:panelGroup&gt;

 &lt;f:websocket channel="someChannel" scope="view" onmessage="someCommandScript" /&gt;
 &lt;h:form&gt;
     &lt;h:commandScript name="someCommandScript" action="#{bean.pushed}" render=":foo" /&gt;
 &lt;/h:form&gt;
 </pre>
 <p>
 If you pass a <code>Map&lt;String,V&gt;</code> or a JavaBean as push message object, then all entries/properties will
 transparently be available as request parameters in the command script method <code>#{bean.pushed}</code>.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.3</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="PushContext.html" title="interface in jakarta.faces.push"><code>PushContext</code></a>, 
<a href="../component/UIWebsocket.html" title="class in jakarta.faces.component"><code>UIWebsocket</code></a>, 
<a href="../event/WebsocketEvent.html" title="class in jakarta.faces.event"><code>WebsocketEvent</code></a></dd>
</dl>
</section>
<section class="summary">
<ul class="blockList">
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->
<li class="blockList">
<section class="memberSummary"><a id="annotation.type.optional.element.summary">
<!--   -->
</a>
<h2>Optional Element Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Optional Elements</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Optional Element</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#channel()">channel</a></span></code></th>
<td class="colLast">
<div class="block">(Optional) The name of the push channel.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== -->
<li class="blockList">
<section class="memberDetails"><a id="annotation.type.element.detail">
<!--   -->
</a>
<h2>Element Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="channel()">channel</a></h3>
<div class="memberSignature"><span class="returnType"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></span>&nbsp;<span class="memberName">channel</span></div>
<div class="block">(Optional) The name of the push channel. If not specified the name of the injection target field will be used.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The name of the push channel.</dd>
</dl>
<dl>
<dt>Default:</dt>
<dd>""</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Push.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><br>Jakarta Server Faces API v3.0.0</div>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Comments to: <a href="mailto:faces-dev@eclipse.org">faces-dev@eclipse.org</a>.<br> Copyright &#169; 2019, 2020 Eclipse Foundation. All rights reserved.<br> Use is subject to <a href="../../../doc-files/speclicense.html" target="_top">license terms</a>.</small></p>
</footer>
</div>
</div>
</body>
</html>
